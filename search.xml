<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>BTC一---密码学基础</title>
    <url>/2020/08/29/%E5%AF%86%E7%A0%81%E5%AD%A6%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h1 id="密码学基础"><a href="#密码学基础" class="headerlink" title="密码学基础"></a>密码学基础</h1><h1 id="1-哈希"><a href="#1-哈希" class="headerlink" title="1.哈希"></a>1.哈希</h1><p>​    比特币属于加密货币，但是区块链上所有的交易都是公开的，包括账户的地址，转账的金额。</p>
<p>比特币用到了密码学的两个内容：哈希和签名</p>
<p>哈希在比特币中：<code>cryptographic hash function</code></p>
<p>它在密码学中要求的两个性质：</p>
<p>​    ①<code>collision</code>（哈希碰撞） 和<code> resistance</code>：没有什么高效的方法人为的制造哈希碰撞，</p>
<p>​        解释为对于一个x，没有什么高效的办法，找到另一个y，使<code>H(x) = H(y)</code>。</p>
<p>​        用法：对于一个m，哈希值为H(m),没有办法篡改内容，而又不被检测出来，因为找不到另外一个m’，使得<code>H(m) = H(m&#39;)</code>。</p>
<p>​        在理论上，这个性质是证明不出来的，只能依靠实际的经验 例如：md5，我们以前没有办法找到制造哈希碰撞的办法，然而现在却可以。</p>
<a id="more"></a>

<p><img src="/2020/08/29/%E5%AF%86%E7%A0%81%E5%AD%A6%E5%8E%9F%E7%90%86/QQ%E6%88%AA%E5%9B%BE20200730213309.png"></p>
<p>  如果我们有一个256位的哈希值，他的输出空间就为2^256，但是输入空间是无限的，根据鸽笼原理（抽屉原理），必然会导致哈希碰撞。</p>
<p>②<code>hiding</code>:哈希函数的计算过程是单向的，不可逆的,x可以计算得到H(x),但是H(x)计算不出x，也就是说，H(x)哈希值没有泄漏x的信息。</p>
<p>这个性质的前提是，x的输入范围要足够的大，使得蛮力，遍历破解的方法是不可行的，输入的分布还要比较均匀，各种取值的概率差不多。</p>
<p><img src="/2020/08/29/%E5%AF%86%E7%A0%81%E5%AD%A6%E5%8E%9F%E7%90%86/QQ%E6%88%AA%E5%9B%BE20200730215143.png"></p>
<p><img src="/2020/08/29/%E5%AF%86%E7%A0%81%E5%AD%A6%E5%8E%9F%E7%90%86/QQ%E6%88%AA%E5%9B%BE20200730215658.png"></p>
<p>将预测结果作为x,算出一个哈希值,将这个哈希值可以公布出去，因为有<code>hiding</code>的性质，只知道这个哈希值，是不能知道预测结果是什么的，在第二天收盘之后，再将预测值公布出去，因为存在<code>collision  resistance</code>的性质，这个预测结果是不可能的被篡改的，这就是一个<code>sealed envelope</code>的功能。</p>
<p>x—-&gt;H(x)</p>
<p><img src="/2020/08/29/%E5%AF%86%E7%A0%81%E5%AD%A6%E5%8E%9F%E7%90%86/QQ%E6%88%AA%E5%9B%BE20200730220318.png"></p>
<p>在实际操作中，不是直接对x取哈希值，而是再x后面加上一个<code>nonce</code>（随机数），保证x的随机性，和分布均匀</p>
<p>哈希函数除了在密码学中要求的这两个性质之外。</p>
<p>在比特币中还要求<code>puzzle friendly</code></p>
<p>哈希值的计算结果是不能被预测的，如果想要得到某个范围之间的哈希值，只能一个一个输入结果去试</p>
<p>那这个性质为什么叫<code>puzzle friendly</code>呢</p>
<blockquote>
<p>在比特币中的挖矿：实际上就是找一个nonce（随机数），这个nonce和区块的块头里的其他信息，合在一起，作为输入，取出一个哈希，这个哈希值要小于等于某个指定的目标阈值</p>
<p><img src="/2020/08/29/%E5%AF%86%E7%A0%81%E5%AD%A6%E5%8E%9F%E7%90%86/QQ%E6%88%AA%E5%9B%BE20200730221330.png"></p>
<p>比特币即区块链，区块链是一个一个区块组成的链表，每个区块有一个块头，块头中有很多的域，其中有一个域是我们可以设置的nonce，挖矿的过程就是不停地去试不同的随机数，使得整个块头取哈希值之后落在指定的范围之内（&lt;=target space）。</p>
<p>puzzle friendly 就是说挖矿的过程，没有捷径，只能靠不停地去试大量的nonce，才能找到符合要求的解，所以这个过程才可以被称为“<strong>工作量证明</strong>（proof of work）”，你找到了nonce，一定是你做了大量的工作，因为没有别的捷径。</p>
<p>虽然挖矿的过程需要大量的工作量，但是只要找到了符合要求的nonce，将这个nonce发布出去，其他人要验证这个nonce是很容易的，只要算一次哈希值就行了。这个就叫做“difficult to solve ，but easy to verify”。</p>
</blockquote>
<p>比特币中用到的哈希函数叫做SHA-256。</p>
<p>SHA:<code>secure Hash Algorithm</code> </p>
<p>我们上面所说的三个性质，他都是满足的</p>
<h1 id="2-签名"><a href="#2-签名" class="headerlink" title="2.签名"></a>2.签名</h1><p>  比特币账户中的账户管理，在日常生活中，可以去中心化的管理机构，比如银行办理手续，</p>
<p>但是在比特币中是去中心化的，那么怎么办理账户呢：每个用户自己决定开户 ，不需要任何人批准，</p>
<p>开户的过程很简单，就是创建一个公钥和私钥的对。</p>
<p><img src="/2020/08/29/%E5%AF%86%E7%A0%81%E5%AD%A6%E5%8E%9F%E7%90%86/QQ%E6%88%AA%E5%9B%BE20200730222824.png"></p>
<p>公私钥是来源于非对称加密体系：<code>asymmetric encryption algorithm</code>。</p>
<p>  最早的加密体系是对称的:<code>symmetric encryption algorithm</code>   —-&gt;两个人之间要进行通讯，但这个过程可能是被窃听的，所以我们两个人之间商量一个密钥，用来加密，发送信息，再用这个密钥来解密，因为这个加密和解密的密钥用的是同一个，所以被称为对称加密体系，这个前提是，有某种安全的渠道，可以把这个密钥分发给通讯的双方（这也是对称加密的一个弱点，密钥的分发不是很方便）</p>
<p><img src="/2020/08/29/%E5%AF%86%E7%A0%81%E5%AD%A6%E5%8E%9F%E7%90%86/QQ%E6%88%AA%E5%9B%BE20200730223101.png"></p>
<p>非对称加密：加密用公钥：<code>public key</code> ，解密用私钥:<code> private key</code>,我要把信息传给你，用你的公钥对信息加密，你收到信息，再用你的私钥解密，得到信息，需要注意的是，加密解密用的公钥私钥，都是接收方的，好处是什么？</p>
<blockquote>
<p>大家都可以知道我的公钥，都可以给我发消息，但是私钥是保存在本地的，不用传给对方，这就解决了对称加密过程，密钥分发带来的不方便的问题</p>
<p>所以比特币创建账户，就是在本地创建一个公钥私钥对，这个公钥就相当于银行账户，私钥相当于银行账户密码，知道私钥就可以把账户上的钱转走。</p>
</blockquote>
<p>  比特币虽然叫加密货币，但是其实他是不加密的，信息都是公开的，那我们要这个公钥私钥干嘛？</p>
<blockquote>
<p>实际上就是用来作签名，在我转比特币给另一个账户的时候，别人怎么知道是不是我转的，还是别人冒名顶替转的？</p>
<p>这个时候就需要我用私钥再这个信息上做一个签名，别人再用我的公钥验证我的私钥生成的签名</p>
<p>万一两个人创建的比特币账户的公私钥对相同怎么办？如果是256位的哈希，产生相同的公私钥对的概率是微乎其微的，</p>
<p>这个概率比地球爆炸的概率还要小！</p>
</blockquote>
<p>在生成比特币账户的公私钥的时候，假设前提是我们有一个好的随机源，如果随机源不好，那么这个时候还是有可能两个人的公私钥是相同的，其实不仅是生成账户的时候，在签名的时候也需要有好的随机源！</p>
<h1 id="3-总结"><a href="#3-总结" class="headerlink" title="3.总结"></a>3.总结</h1><p>  密码学中，两个功能，一个是哈希，一个是签名，这两个功能是可以结合起来使用的；</p>
<p>比特币系统中，一般是先对一个message取一个哈希，然后再对这个哈希值签名。</p>
]]></content>
      <categories>
        <category>区块链</category>
      </categories>
      <tags>
        <tag>区块链</tag>
      </tags>
  </entry>
  <entry>
    <title>BTC四---实现</title>
    <url>/2020/08/30/%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><h2 id="transaction-based-ledger"><a href="#transaction-based-ledger" class="headerlink" title="transaction-based ledger"></a>transaction-based ledger</h2><p>BTC(比特币):基于交易的账本模式（transaction-based ledger），每个区块记录交易信息，但是系统中没有统一的记录，比如需要知道某个账户有多少钱，这个还需要交易记录来推算</p>
<p>比特币的全节点要维护一个UTXO的数据结构</p>
<a id="more"></a>

<p>UTXO:Unspent Transaction Output,还没有被花出去的交易的输出，区块链中有很多交易，有些交易的输出可能被花掉了，有些还没有被花掉，没有被花掉的交易的输出的集合叫做UTXO</p>
<p>UTXO中的每个元素要给出产生这个输出的交易的hash值，以及他在这个交易里是第几个输出，就可以定位到这个UTXO中的输出，那么这个UTXO集合的作用是什么？为什么要维护这样一个数据结构</p>
<p>作用：防范double spending attack，所以全节点要在内存中维护UTXO数据结构，以便快速检测double spending attack，</p>
<p>随着交易的发布，每个交易要消耗UTXO中的输出，同时也会产生一些新的输出</p>
<p>每个交易所有输入的金额，要等于所有输出的金额：total inputs = total outputs</p>
<p>发布区块的那个结点为什么要把你的交易打包在区块里？这样做对她有什么好处吗？</p>
<p>如果只有出块奖励，那么自私的结点就只会打包他自己的交易，同时也节省带宽</p>
<p>所以比特币系统设定了第二个激励机制：交易费（transaction fee），你把我的交易打包在区块里，我给你点小费，所以就会出现total inputs &gt;= total outputs的情况，多的比特币充当了小费</p>
<p><img src="/2020/08/30/%E5%AE%9E%E7%8E%B0/QQ%E6%88%AA%E5%9B%BE20200817210059.png"></p>
<p>目前矿工去争取记账权，主要还是为了得到出块奖励，但是因为21个区块都会减少出块奖励</p>
<p>比特币系统中差不多10分钟会创建一个区块，计算下来差不多每四年就会减半（出块奖励）</p>
<h2 id="区块的例子"><a href="#区块的例子" class="headerlink" title="区块的例子"></a>区块的例子</h2><p>account-based ledger</p>
<p>以太坊就是这种模式，在这种模式总，系统显式的记录每个账户上有多少个币，比特币的隐私保护就比较好一些</p>
<p><img src="/2020/08/30/%E5%AE%9E%E7%8E%B0/image-20200817210819638.png"></p>
<p>Height:是区块的序号，Difficulty：挖矿的难度（每隔2016个区块要调整这个难度，保持出块时间在10分钟左右）</p>
<p><img src="/2020/08/30/%E5%AE%9E%E7%8E%B0/QQ%E6%88%AA%E5%9B%BE20200817211158.png"></p>
<p>注意：计算hash值都是计算block header的哈希值，不包含block body的哈希值</p>
<p>所谓的挖矿，就是不断地调整随机数nonce，使得整个block header的哈希值小于等于给定的目标阈值，这个目标阈值表示成16进制就是前面有一长串的0，所以凡是符合难度要求的区块，它的块头的哈希值，算出来都是要有一长串的0</p>
<p><img src="/2020/08/30/%E5%AE%9E%E7%8E%B0/QQ%E6%88%AA%E5%9B%BE20200817211615.png"></p>
<p><img src="/2020/08/30/%E5%AE%9E%E7%8E%B0/QQ%E6%88%AA%E5%9B%BE20200817211913.png"></p>
<p><img src="/2020/08/30/%E5%AE%9E%E7%8E%B0/QQ%E6%88%AA%E5%9B%BE20200817212243.png"></p>
<p>每个发布的区块里都包含一个特殊的铸币交易</p>
<p><img src="/2020/08/30/%E5%AE%9E%E7%8E%B0/QQ%E6%88%AA%E5%9B%BE20200817212744.png"></p>
<p>这个对Merkle tree的根哈希值有什么影响吗</p>
<p><img src="/2020/08/30/%E5%AE%9E%E7%8E%B0/QQ%E6%88%AA%E5%9B%BE20200817213102.png"></p>
<p>coinbase中的前八个字节当作extra nonce来用nonce从2^32-&gt;2^96</p>
<p>所以真正挖矿的时候是有两层循环的，外层循环调整coinbase域的extra nonce ，算出block header中的根哈希值之后，内层循环在调整header里的nonce</p>
<p><img src="/2020/08/30/%E5%AE%9E%E7%8E%B0/QQ%E6%88%AA%E5%9B%BE20200817213639.png"></p>
<p><img src="/2020/08/30/%E5%AE%9E%E7%8E%B0/QQ%E6%88%AA%E5%9B%BE20200817213948.png"></p>
<h2 id="概率分析"><a href="#概率分析" class="headerlink" title="概率分析"></a>概率分析</h2><p>每次尝试nonce可以看作是Bernoulli trial：a random experiment with binary outcome</p>
<p>挖矿，每次尝试nonce，成功的概率是微乎其微的，大概率是不行的，如果我们做很多的Bernoulli trial，每个实验都是随机的，这些Bernoulli trial就构成了Bernoulli process：a sequence of independent Bernoulli trials，Bernoulli trial的一个性质是无记忆性：memory less，你做大量的实验，前面的结果和后面的结果是没有关系的</p>
<p>实验很多，每次成功的概率很小，多重伯努利可以用Poisson process来近似，我们关心的是，系统中产生下一个区块的时间，这个在概率中可以推导出来出块时间是服从指数分布的exponential distribution</p>
<p>整个系统平均的出块时间是十分钟，这个时间是比特币协议设计出来的</p>
<p>具体到每个矿工，他能够挖到下一个区块的时间，取决于这个矿工的算力占系统算力的百分比，比如说，你的算力占到系统算力的1%，平均下来，系统里每产生一百个区块，其中有一个区块就是你挖矿挖到的，平均你要等1000分钟才能产生一个区块</p>
<p><img src="/2020/08/30/%E5%AE%9E%E7%8E%B0/QQ%E6%88%AA%E5%9B%BE20200817215856.png"></p>
<p>这个性质有时候也叫：process free，过去的process是不算数的</p>
<p>假设一下，如果有某个puzzle不满足process free，会出现什么情况：算力强的矿工具有不成比例的优势，因为算力强的矿工过去做的工作肯定是多的，比如有两个矿工，一个矿工的算力是另一个的十倍，那么他挖到矿的概率也是另一个的十倍，这样就满足process free，如果不满足，就会大于十倍！其实process free 恰恰是挖矿公平性的保证。</p>
<h2 id="比特币的总量"><a href="#比特币的总量" class="headerlink" title="比特币的总量"></a>比特币的总量</h2><p>挖矿获得的出矿奖励，是比特币长生的唯一途径，然而这个值每四年就会减半，比特币的总量呈现几何趋势</p>
<p>genmetric series</p>
<p><img src="/2020/08/30/%E5%AE%9E%E7%8E%B0/QQ%E6%88%AA%E5%9B%BE20200819203300.png"></p>
<p>挖矿对维护比特币系统的安全是至关重要的：Bitcoin is secured by mining，只要大部分算力在诚实的结点手里，系统的安全就可以得到保证。出矿奖励随着出块会减半，那么人们的动力是否会减少呢？从过去的几年来看，恰恰是相反的，比特币的价格是飙升的，如果趋于0之后，是不是就没有动力挖矿了呢？还有第二种激励机制：交易费</p>
<p>比特币的安全性的分析，①假设大部分算力是掌握在诚实的矿工手里，我们能得到什么样的安全保证，能不能保证写入区块里的交易都是合法的？如果落在了10%的不诚实的结点手里，这个节点能不能偷币？能不能把别人账上的钱转给自己？不能，因为他无法伪造别人的签名（需要知道别人的私钥）。如果把这个交易硬写道区块链里呢？</p>
<p><img src="/2020/08/30/%E5%AE%9E%E7%8E%B0/QQ%E6%88%AA%E5%9B%BE20200819204852.png"></p>
<p>②恶意的结点能不能double spending？</p>
<p>如果M-&gt;A存在某种不可逆的效果，那么M-&gt;M’就可以从中获得不当的利益，比如网上购物，M购买了一些商品，然后网站接受比特币支付，M把帐转给这个网站，网站监听到这个交易写入到区块链里了，以为， 支付成功了，所以把商品给了M，M拿到商品之后，又发起了一个交易M-&gt;M’把钱转给自己，然后按照下面这个区块扩展最长合法链，这样上面那个交易就作废了。</p>
<p><img src="/2020/08/30/%E5%AE%9E%E7%8E%B0/QQ%E6%88%AA%E5%9B%BE20200819205358.png"></p>
<p>如何防范double spending？类似上面这种攻击</p>
<p><img src="/2020/08/30/%E5%AE%9E%E7%8E%B0/QQ%E6%88%AA%E5%9B%BE20200819210210.png"></p>
<p><img src="/2020/08/30/%E5%AE%9E%E7%8E%B0/QQ%E6%88%AA%E5%9B%BE20200819210314.png"></p>
<p>区块链是不可篡改的账本：irrevocable ledger，那是不是说凡是写入区块链的内容，永远改不了呢？根据上面的分析可知，这种不可篡改性，只是一种概率上的保证</p>
<p>其实，还有一种zero confirmation，0个确认，这个意思是说，这个转账交易发布出去了，但是还没有被写入区块链里，商家就确认了这个交易，这种在现实生活中还是比较普遍的，</p>
<p>原因：</p>
<p>①比特币协议缺省的设置是：结点接收最先听到的那个交易，两个交易有冲突，最先听到哪个，接收哪个，所以发布一个M-&gt;A,最先听到这个，在zero confirmation的这个位置，诚实的结点有比较大的几率是不会接收M-&gt;M’这个交易的 </p>
<p>②很多购物网站，从你支付成功，到他把货品发给你，是有一定的时间间隔的，如果发现M-&gt;M’这个转账交易没有在最长合法链里，电商就可以选择取消发货。</p>
<p>假设某个有恶意的结点获得了记账权，他还能干什么坏事？</p>
<p> 能不能不把某些合法的交易写道区块链里？这是可以的，但是会少交易费，比特币规定某个区块的大小是有限制的，最多不能超过1M字节，某个节点交易太多，这些交易就只能等到下个区块在发布</p>
<p>selfish mining：在商家等待6个区块的时候，M-&gt;M’先不发布，在私下偷偷的挖矿，但是不发布，等挖矿创建的区块比6个区块多的时候，一下子全部发布，M-&gt;M’这条链就成了最长合法链；正常的情况是，挖到区块，立马发布，要不然就被别人抢了，所以selfish mining有一个前提，恶意的结点的算力要超过诚实的结点的算力，但是是不可能的</p>
<p>selfish mining还有什么目的，上述是分叉攻击的目的，假设我们能不是为了回滚以前的交易，就是为了正常的挖矿，赚取出块奖励，selfish mining有没有什么好处？减少竞争：别人挖了一个，我已经挖了两个，然后直接抛出去两个,让别人做一些无用功。</p>
]]></content>
      <categories>
        <category>区块链</category>
      </categories>
      <tags>
        <tag>区块链</tag>
      </tags>
  </entry>
  <entry>
    <title>BTC三---协议</title>
    <url>/2020/08/30/%E5%8D%8F%E8%AE%AE/</url>
    <content><![CDATA[<h1 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h1><h2 id="1-需要解决的问题"><a href="#1-需要解决的问题" class="headerlink" title="1.需要解决的问题"></a>1.需要解决的问题</h2><p>举个例子，央行可以发行数字货币，每张数字货币上都有央行的私钥的签名</p>
<a id="more"></a>

<p><img src="/2020/08/30/%E5%8D%8F%E8%AE%AE/QQ%E6%88%AA%E5%9B%BE20200810202143.png"></p>
<p>央行的公钥我们大家都知道，所以我收到一个数字货币，我可以验证一下是不是真的，买东西的时候，我把数字货币发给你，同理你也可以验证确实是央行发行的，这就完成了支付的一个过程。</p>
<p>这里用到了密码学中的非对称加密体系，但是没有用到区块链，这样会带来什么问题？</p>
<p>这个数字货币是个文件，我们不能篡改，但是可以复制，可以复制很多份，这和人民币不一样，我把人民币给你了，我就没有人民币了。这就是数字货币和纸质货币的区别</p>
<p>double spending attack（双花攻击），数字货币面临的一个主要挑战，就是防范double spending attack</p>
<p>改进的方案：</p>
<p><img src="/2020/08/30/%E5%8D%8F%E8%AE%AE/QQ%E6%88%AA%E5%9B%BE20200810203047.png"></p>
<p>央行发行的货币，再每个数字货币上添加一个编号，并且在数据库中保存这个编号对应的货币目前在谁手上，收款方不仅验证数字货币的真实性，还需要验证付款方是否合法，央行的 数据库进而修改017对应的数字货币的所有者。</p>
<p>这样做是没有问题的，但是这是一个中心化的方案，数字货币的发行是由央行统一控制的，而且每次交易也是由央行控制的。</p>
<p>那么有没有去中心化的方案呢？将央行这个职能，改成由广大用户共同承担，这就是比特币，这个数字货币系统要解决的问题。</p>
<p>去中心化的货币要解决两个问题：数字货币的发行（没有央行了，都是普通群众，那怎么决定数字货币的发行：什么时候发行，该发行多少）、怎么验证交易的有效性（如何防止double spending attack）</p>
<p>①谁来发行货币？在比特币系统中，是由挖矿来决定的，这个在后面详细讲</p>
<p>②如何防止double spending attack：也是维护一个数据结构，检测数字货币有没有花过，被谁花过，只不过这个数据结构不是由央行来维护，而是由所有的用户来维护，这个数据结构就是区块链</p>
<p>比如用户A，拥有了发行货币的能力</p>
<p><img src="/2020/08/30/%E5%8D%8F%E8%AE%AE/QQ%E6%88%AA%E5%9B%BE20200810204843.png"></p>
<p><strong>比特币中的交易都包含输入和输出两部分，输入部分说明币的来源，输出部分要给出收款人公钥的哈希</strong></p>
<p>这里有两个哈希指针，一个哈希指针是用来连接各个区块，把他们串起来构成一个链表，还有一个指针是用来说明币的来源的（用于证明这个数字货币不是凭空捏造的，同时防范double spending attack）</p>
<p><img src="/2020/08/30/%E5%8D%8F%E8%AE%AE/QQ%E6%88%AA%E5%9B%BE20200810205441.png"></p>
<p>A要给B转钱，需要知道B的地址，这个地址是由B的公钥取哈希，经过一些转换推算得到的，那A要怎么知道B的地址呢？</p>
<p>比特币系统没有提供一种功能去查询某个指定人的所对应的比特币地址，这个需要其他的渠道来获得</p>
<p>A要给B转钱，B要知道A的什么信息？币的来源？（B不需要知道，这个其实是A要知道的）</p>
<p>答案是B要知道A的公钥。B要知道A的身份，好知道这笔钱是哪来的。但是不仅仅是B需要知道A的公钥，所有结点都需要知道A的公钥—-&gt;为了验证A的签名，那问题又来了，怎么知道A的公钥？</p>
<p>输入当中不仅要说明币的来源，还需要说明A的公钥是什么</p>
<p><img src="/2020/08/30/%E5%8D%8F%E8%AE%AE/QQ%E6%88%AA%E5%9B%BE20200810211410.png"></p>
<p><img src="/2020/08/30/%E5%8D%8F%E8%AE%AE/QQ%E6%88%AA%E5%9B%BE20200810211619.png"></p>
<p>在比特币系统中，这些验证的过程，是通过执行脚本来实现的—–&gt;BitCoin Script</p>
<p>将后面交易的输入的执行脚本和前面交易的输出的执行脚本拼接，如果能顺利执行，那么这个验证就是通过的</p>
<p>每个区块由block header 和 block body组成</p>
<p>block header：保存每个区块的一些宏观的信息，包括</p>
<p>①：用的是比特币哪个版本的协议</p>
<p>②hash of previous block header：区块中指向前一个区块的指针</p>
<p><strong>注意：</strong>前一个区块的哈希只算的是区块的块头</p>
<p>③Merkle root hash：整棵Merkle tree的根哈希值</p>
<p>④target：挖矿的难度目标阈值</p>
<p><img src="/2020/08/30/%E5%8D%8F%E8%AE%AE/QQ%E6%88%AA%E5%9B%BE20200810213647.png"></p>
<p>block header存的就是target的一个编码：nBits</p>
<p>⑤nonce：随机数nonce    </p>
<p>block body：</p>
<p>①transaction list：交易列表</p>
<p>貌似所有的结点都需要验证区块链中的每一个交易</p>
<p>实际上区块链分为全节点full node 和轻结点light node 两种结点</p>
<p>full node ：保存所有的信息，验证每一个交易，也叫做fully validating node</p>
<p>light node：并不参数验证，只是利用区块链的一些信息做一些查询之类的工作</p>
<p>交易如何写入区块链，按照什么顺序？账本的内容要取得分布式的共识（distributed consensus）</p>
<p>分布式的共识？举个例子，就是简单的哈希表distributed hash table，就是，一台机器在hash表中插入了一条数据（key-value pair），在别的机器也能查询到。</p>
<h2 id="2-分布式系统中的结论和协议"><a href="#2-分布式系统中的结论和协议" class="headerlink" title="2.分布式系统中的结论和协议"></a>2.分布式系统中的结论和协议</h2><p>分布式系统有很多的不可能结论impossibility result，最著名的一个叫做FLP impossibility result:</p>
<p>在一个异步的系统里（asynchronous system），网络传输时延没有上限，即时只有一个成员是有问题的（faulty），也不可能取得共识</p>
<p>还有一个结论CAP Theorem：</p>
<p>C：consistency（一致性）   A：Availability（可用性）   P：Partition tolerance（分区容错性）</p>
<p>任何一个分布式系统CAP三个性质最多只能满足两个，不可能三个性质都满足。</p>
<p>分布式共识的一个重要协议：Paxos，这个协议能够保证Consistency，如果这个协议达成了共识，那么这个共识一定是一致的，不会说一个成员认为的共识和另外一个成员认为的共识不一样。但是，某些情况下，Paxos协议有可能一直没有办法达成共识，这种可能性在实际系统中是比较小的，但是是客观存在的</p>
<h2 id="3-比特币系统中的分布式共识协议"><a href="#3-比特币系统中的分布式共识协议" class="headerlink" title="3.比特币系统中的分布式共识协议"></a>3.比特币系统中的分布式共识协议</h2><p>需要解决的问题是，某些节点可能是有恶意的，我们假设系统中大多数节点是好的，如何去设计共识协议？</p>
<p>一种想法，既然大多数结点是好的，那直接投票行不行，比如说：某一个结点提出一个候选区块，他根据收到的交易信息，选一下那些交易是合法的，然后把这些交易按照某个顺序打包到一个区块里，候选区块发布给所有的结点，每个结点收到这个区块之后，检查这里面的交易是不是都是合法的，如果都是合法的，那么这个结点就投赞成票，如果有个交易是非法的，就投反对票，最后算出得票，如果超过半数，就将这个候选区块正式接受，写道区块链中</p>
<p>会带来什么问题？</p>
<p>①某个结点提出候选区块，万一这个节点是有恶意的呢，就不停的产生一些非法的交易让系统一直投票，会阻塞系统的发展</p>
<p>②并不能强迫每个节点都投票（行政不作为）</p>
<p>③效率的问题，网络的延迟状况不是很清楚</p>
<p>最大的问题：所有基于投票的方案，首先要确定谁有投票权（需要有membership）。如果这个系统的membership是有严格定义的，不是谁都可以加入的，比如hyperledger，只有某些符合条件的大公司才能加入，这种情况下，基于投票的方案是可行的。</p>
<p>但是比特币系统不是这样的，比特币系统中创建一个账户是很容易的，在本地产生一个公私钥对其他人其实都不知道，只有在你和外部交易的时候别人会知道，这种情况下，有恶意的结点，用一台超级计算机，不停的创建账户，当账户超过总数的一半时，就会对投票产生控制权，这种攻击叫做女巫攻击（sybil attack）。</p>
<p>所以简单的随机投票是不行的</p>
<p>比特币中采用了一个巧妙地机制来解决这个问题，也是投票，但不是按照账户的数目投票，而是用计算力来投票，每个结点都可以在本地组装出一个候选区块，把他认为合法的交易放在这个区块里，就开始尝试各种nonce值，看那个结点可以满足不等式的要求，求出的hash落在指定的范围之内，如果某个节点找到了符合要求的nonce，我们就说他获得了记账权（向比特币这个去中心化的账本里写入下一个区块的权力），只有这样的结点，才有权力发布下一个区块，其他节点要先验证这个区块的合法性，block header 中的nBits（挖矿的难度要求）是否正确，然后验证nonce，总的来说，就是先查询block header中的各种值，然后验证block body中的交易是否合法（是否有合法的签名、是否被花过）</p>
<p>有没有可能这个区块的所有内容都符合要求，但是我们仍然不愿意接受他？</p>
<p><img src="/2020/08/30/%E5%8D%8F%E8%AE%AE/QQ%E6%88%AA%E5%9B%BE20200812212804.png"></p>
<p>分叉攻击，通过像区块链中间插入一个区块，来回滚某个已经发生的交易，但是区块链在正常情况下也会出现分叉，</p>
<p>如果同时有两个结点获得了记账权，就有可能发生，可能会出现两个等长的分叉</p>
<p><img src="/2020/08/30/%E5%8D%8F%E8%AE%AE/QQ%E6%88%AA%E5%9B%BE20200812213645.png"></p>
<p>比特币系统中，缺省情况下，每个结点是接受他最早收到的那个，不同的结点在网络中的位置不同，接受的结点可能也不同，什么叫做接受？在接受一个区块之后会向后扩展区块</p>
<p><img src="/2020/08/30/%E5%8D%8F%E8%AE%AE/QQ%E6%88%AA%E5%9B%BE20200812214435.png"></p>
<p><img src="/2020/08/30/%E5%8D%8F%E8%AE%AE/QQ%E6%88%AA%E5%9B%BE20200812214518.png"></p>
<p>那么为什么要争夺记账权？</p>
<p>记账的结点可以拥有某些权力，决定那些交易被写到区块链里，但是设计的时候不应该让这个权力称为争夺记账权的主要动力，因为我们希望所有的合法的交易都应该被写进区块链里</p>
<p>比特币系统规定，获得记账权的哪个结点，在发布的区块里可以有一个特殊的交易，就是铸币交易，可以发布一定数量的比特币。coinbase transaction（交易）</p>
<p>比特币系统要解决两个问题，一个是谁来决定发行货币，另一个是验证交易的合法性，回过头来说明第一个问题：</p>
<p>coninbase transaction （交易）是比特币系统中发行货币的唯一方法，其他所有的交易都是把已有的比特币从一个账户转移到另一个账户，coinbase transaction不用指明币的来源，那能铸多少个币呢</p>
<p>比特币刚上线时，每一个新增的区块可以铸50 BTC，但是每21万个区块之后，这个奖励就要减半，现在的情况就是12.5 BTC</p>
<p><strong>注意：orphan block中的奖励的比特币就无效了</strong></p>
<h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4.总结"></a>4.总结</h2><p>最后，那么比特币要取得的共识是什么？去中心化账本中的内容要取得共识，只有获得记账权的结点才能往里面写东西，</p>
<p>我们通过算例来获得记账权，每秒钟能够试多少个nonce的数目（hash rate），hash rate越高，得到出块奖励的概率越大</p>
]]></content>
      <categories>
        <category>区块链</category>
      </categories>
      <tags>
        <tag>区块链</tag>
      </tags>
  </entry>
  <entry>
    <title>BTC七---挖矿</title>
    <url>/2020/08/30/%E6%8C%96%E7%9F%BF/</url>
    <content><![CDATA[<h1 id="挖矿"><a href="#挖矿" class="headerlink" title="挖矿"></a>挖矿</h1><h2 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h2><p><img src="/2020/08/30/%E6%8C%96%E7%9F%BF/QQ%E6%88%AA%E5%9B%BE20200828210256.png"></p>
<a id="more"></a>

<p><img src="/2020/08/30/%E6%8C%96%E7%9F%BF/QQ%E6%88%AA%E5%9B%BE20200828210616.png"></p>
<p>比特币网络中大部分节点是轻结点，如果只需要转账，不需要挖矿的话，没必要运行一个全节点。</p>
<p>在挖矿过程中，如果你监听到别人发布了一个区块，这个区块是合法的，也是在延伸最长合法连，这个时候你应该停止已有的挖矿，然后重新在本地组装一个侯选区块，重新挖矿，因为你要沿着这个新发布的区块向下挖的话，那么你本地所组装的这个区块中，包含的交易就会发生变化，有些交易可能已经包含到已经被发布的这个区块里了，block header的内容也会发生变化，Merkle tree的根哈希值，以及指向前一个区块的指针，这样做是不是有些可惜？</p>
<p>其实是不可惜的，因为前面我们提到一个挖矿的性质：无记忆性memory less（process free），所以你是坚持挖原来的区块，还是改成挖一个新组装的区块，成功的机率是一样的。</p>
<p>即时挖到了合法的区块，发布到区块链上，也不是说就是胜利了，有可能你发布的这个区块，最终没有成为最长合法链，</p>
<p>可能存在一些risk condition，别人同时发布了一个合法的区块，或者是存在一些你不知道的double spending，使得你这个区块中某些交易最后是有冲突的。</p>
<p>比特币是怎么保证安全性的？两方面</p>
<p>一方面：密码学上的保证：别人没有你的私钥，就不能伪造你的签名，这个的前提是，系统中拥有大多数算力的矿工是好的，是遵守协议的；</p>
<p>另一方面：共识机制。</p>
<h2 id="挖矿相关"><a href="#挖矿相关" class="headerlink" title="挖矿相关"></a>挖矿相关</h2><p>挖矿的设备：越来越趋向于专业化，最早的时候大家都是用普通的cpu去挖矿。</p>
<p>如果现在，你专门买一台计算机用来挖矿，其实是不划算的，因为计算机中的大部分内存都是闲置的，挖矿只用到其中很小一部分内存，cpu中的大部分部件也是闲置的，因为挖矿的操作只用到了通用cpu中的很少的一部分指令，硬盘和其他很多资源也用不到。</p>
<p>第二代：GPU–&gt;比cpu挖矿的效率高得多，GPU用于大规模的并行计算（像深度学习就用到了GPU，其中有很多矩阵的乘法），但是GPU用来挖矿，其实还是有点浪费的，里面有很多部件仍然处于闲置状态，比如用于浮点数计算的部件（比特币的挖矿只用到了整数计算）</p>
<blockquote>
<p>最近几年，GPU价格上涨的很快，有些人把它归于深度学习的火热，其实有很多GPU是用来挖矿的，不过有个好消息，现在比特币挖矿难度的提升，用GPU挖矿已经划不来了，所以都不竞争去买GPU用于挖矿了。</p>
</blockquote>
<p>现在用什么挖矿？用ASIC（Application Specific Integrated Circuit）芯片，它上面没有多余的电路逻辑，整个芯片就是为了比特币挖矿计算哈希值的操作而设计的，性价比最高，而且，为某一种加密货币设计的ASIC芯片，只能用来挖这一种加密货币，除非这两个加密货币使用同一个mining puzzle，有些加密货币新发行的时候，为了解决能源启动问题，他故意用一个已有的加密货币的mining puzzle，可以吸引更多的人来挖矿，这样的mining puzzle叫做merge mining。</p>
<p>ASIC芯片的研发周期是很长的，比特币的ASIC的芯片需要使用一年的时间，已经算是很快了，创造了ASIC芯片史上的奇迹，在这么长的时间里面，如果比特币的价格发生了很大的变化的话，前期投入的研发费用有可能就打水漂了。</p>
<p>即时在比特币发展的黄金时期，比特币价格上涨，挖矿是有利可图的，但是竞争也是越来越激烈的，定制的ASIC芯片可能用不了几个月就过时了，相当于一个军备竞赛。</p>
<blockquote>
<p>有研究表明，大部分的ASIC矿机，利润是在他上市的前两个月获得的，这个时候的算力在同类产品中最强，所以购买ASIC矿机的时机很重要，现在一般都是提前预定，如果不能及时发货，对矿工就有损利益，有些不良厂商，生产出了矿机，不立即发售，而是自己先用他挖矿</p>
</blockquote>
<p>有些新的加密货币设计的是Alternative mining puzzle 设计的初衷是：ASIC resistance（能够抗ASIC芯片化，目的是为了让通用的计算机也能参与挖矿）</p>
]]></content>
      <categories>
        <category>区块链</category>
      </categories>
      <tags>
        <tag>区块链</tag>
      </tags>
  </entry>
  <entry>
    <title>BTC六---挖矿难度</title>
    <url>/2020/08/30/%E6%8C%96%E7%9F%BF%E9%9A%BE%E5%BA%A6/</url>
    <content><![CDATA[<h1 id="挖矿难度"><a href="#挖矿难度" class="headerlink" title="挖矿难度"></a>挖矿难度</h1><h2 id="为什么要调整挖矿难度"><a href="#为什么要调整挖矿难度" class="headerlink" title="为什么要调整挖矿难度"></a>为什么要调整挖矿难度</h2><p>调整挖矿难度，就是调整目标空间在整个输出空间中所占的比例</p>
<p>比特币的哈希算法是SHA-256，256位的哈希值，所以输出空间位2^256个可能取值，调整目标空间占输出空间的比例，通俗的说，就是这个哈希值前面要多少个零，合法的哈希，算出来，前面至少要有70个零，但是严格的话还是按照定义来计算哈希值。</p>
<a id="more"></a>

<p>另外一种概念：挖矿难度，挖矿难度和目标阈值成反比</p>
<p><img src="/2020/08/30/%E6%8C%96%E7%9F%BF%E9%9A%BE%E5%BA%A6/QQ%E6%88%AA%E5%9B%BE20200826214434.png"></p>
<p>挖矿难度最小就是1，所以这时候target很大，那我们为什么要调整挖矿难度呢？如果不调，会有什么问题：系统中的总算力越来愈强，挖矿难度不变的话，出块时间就会越来越短，一开始没什么人，按照设计是十分钟出一个区块，后来一分钟就可以出一个区块，再到后来，用的设备越来越先进，不到一秒。</p>
<p>这么快不好吗？我每出现一个交易就可以及时的写入区块里，减少了系统的响应时间，这不是好事吗？其实不是件好事，这样会有什么问题吗？</p>
<p>如果两个结点同时发布了一个区块，那么这个时候可能会出现分叉，分叉就成了常态，可能不仅仅是二分叉，分叉如果过多，对于系统达成共识，是没有好处的，也危害到系统的安全性，比特币系统是假设，大部分算力都掌握在诚实的结点手里，系统当中的总算力越强，安全性就越好（发动51% attack的算力要求就更大）</p>
<p><img src="/2020/08/30/%E6%8C%96%E7%9F%BF%E9%9A%BE%E5%BA%A6/QQ%E6%88%AA%E5%9B%BE20200826220208.png"></p>
<p>这个时候，可能10%的算力就可以发动攻击了，所以出块时间，不是越短越好。比特币系统中设计的10分钟的出块原则是不是最优的呢？这个不一定，这个只是说，出块时间要有一个常熟的波动范围，不能无限的减少下去，这个对于支付系统来说，其实还是比较长了。</p>
<p>以太坊就将出块时间降低到了15秒，这样以太坊就要设计一个新的共识协议：ghost，这个之后会提到，以太坊同样也会调整挖矿难度，是出块时间保持稳定；所以，出块时间没有规定多长，但是不管多长，都要保持稳定，而不能无限地减少下去 </p>
<h2 id="如何调整挖矿难度"><a href="#如何调整挖矿难度" class="headerlink" title="如何调整挖矿难度"></a>如何调整挖矿难度</h2><p>比特币中规定了，每隔2016个区块要重新调整目标阈值，大概是每两个星期调整一下</p>
<p><img src="/2020/08/30/%E6%8C%96%E7%9F%BF%E9%9A%BE%E5%BA%A6/QQ%E6%88%AA%E5%9B%BE20200828203802.png"></p>
<p>调整的公式：</p>
<p><img src="/2020/08/30/%E6%8C%96%E7%9F%BF%E9%9A%BE%E5%BA%A6/QQ%E6%88%AA%E5%9B%BE20200828204035.png"></p>
<p>实际的代码中，上调和下调实际上都是有4倍的限制的，最多增大，下调4倍</p>
<p>那么如何让所有的矿工，都调整目标阈值呢？怎么能让大家都听话？如果恶意的区块不调整target，那么诚实的结点不会认可：检查的内容包括nBits（target的编码版本）域</p>
<p><code>比特币系统中总算力的变化情况</code></p>
<p><img src="/2020/08/30/%E6%8C%96%E7%9F%BF%E9%9A%BE%E5%BA%A6/QQ%E6%88%AA%E5%9B%BE20200828205244.png"></p>
<p><code>算力难度的增长情况</code></p>
<p><img src="/2020/08/30/%E6%8C%96%E7%9F%BF%E9%9A%BE%E5%BA%A6/QQ%E6%88%AA%E5%9B%BE20200828205539.png"></p>
<p>符合难度调整的设计目标</p>
<p><code>难度调整曲线</code></p>
<p><img src="/2020/08/30/%E6%8C%96%E7%9F%BF%E9%9A%BE%E5%BA%A6/QQ%E6%88%AA%E5%9B%BE20200828205648.png"></p>
<p>说明挖矿的人越来越多，设备越来越先进</p>
<p><code>每天的出块时间</code></p>
<p><img src="/2020/08/30/%E6%8C%96%E7%9F%BF%E9%9A%BE%E5%BA%A6/QQ%E6%88%AA%E5%9B%BE20200828205804.png"></p>
<p><code>最近半年的出块事件</code></p>
<p><img src="/2020/08/30/%E6%8C%96%E7%9F%BF%E9%9A%BE%E5%BA%A6/QQ%E6%88%AA%E5%9B%BE20200828205845.png"></p>
<p><img src="/2020/08/30/%E6%8C%96%E7%9F%BF%E9%9A%BE%E5%BA%A6/QQ%E6%88%AA%E5%9B%BE20200828210138.png"></p>
]]></content>
      <categories>
        <category>区块链</category>
      </categories>
      <tags>
        <tag>区块链</tag>
      </tags>
  </entry>
  <entry>
    <title>BTC二---比特币中的数据结构</title>
    <url>/2020/08/29/%E6%AF%94%E7%89%B9%E5%B8%81%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<h1 id="比特币中的数据结构"><a href="#比特币中的数据结构" class="headerlink" title="比特币中的数据结构"></a>比特币中的数据结构</h1><h2 id="1-区块链"><a href="#1-区块链" class="headerlink" title="1.区块链"></a>1.区块链</h2><p>这里要用到一个重要的概念叫做哈希指针。</p>
<p>hash pointers，哈希指针，除了要保存这个结构体的地址之外，还要保存这个结构的的哈希值（不仅可以知道这个结构体在内存中的位置，还可以知道这个结构体的内容有没有被篡改）</p>
<p>区块链相比较于普通的链表有何区别？</p>
<a id="more"></a>

<p>①用哈希指针替代了普通的指针</p>
<p><img src="/2020/08/29/%E6%AF%94%E7%89%B9%E5%B8%81%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/QQ%E6%88%AA%E5%9B%BE20200802193317.png"></p>
<p>区块链示例</p>
<p><img src="/2020/08/29/%E6%AF%94%E7%89%B9%E5%B8%81%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/QQ%E6%88%AA%E5%9B%BE20200802193910.png"></p>
<p><img src="/2020/08/29/%E6%AF%94%E7%89%B9%E5%B8%81%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/QQ%E6%88%AA%E5%9B%BE20200802194121.png"></p>
<p>这样做的好处是</p>
<p>tamper-evident log：篡改-证明 日志，当有人篡改了区块链中某一个区块的某个内容，则它的下一个区块的哈希值就对不上了，以此类推，直到最后一个保存在系统中的哈希值也对不上了，这样我们只需要记住保存在系统中的那最后一个哈希值，就可以检测出对任意区块的修改。这也是区块链和普通链表的一个区别。（多米诺骨牌效应）</p>
<p>有了这个性质，系统中就不需要保存整条区块链的内容，比如它可以只保存最近的几千个区块，如果要用到以前的区块怎么办？</p>
<blockquote>
<p>可以问系统中的其他节点，去要这个区块，有些节点可能是有恶意的（去中心化系统），那么如何知道别人给你的区块是不是正确的呢？就用到哈希指针的这个性质！别人给你的最后的那个区块，算一下哈希值，如果和系统中保存的与之对应的后一个区块的哈希值对比之后相同，则正确</p>
</blockquote>
<h2 id="2-Merkle-tree-默克尔树"><a href="#2-Merkle-tree-默克尔树" class="headerlink" title="2.Merkle tree(默克尔树)"></a>2.Merkle tree(默克尔树)</h2><p>和binary tree（二叉树）的区别是，用哈希指针代替了普通的指针</p>
<p><img src="/2020/08/29/%E6%AF%94%E7%89%B9%E5%B8%81%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/QQ%E6%88%AA%E5%9B%BE20200802200344.png"></p>
<p>和链式结构一样，“牵一发而动全身”。</p>
<p>各个区块由哈希指针连接在一起的，每个区块所包含的交易，是组织成一个Merkle tree的形式，最底层的数据块实际上是某个交易。</p>
<p>每个区块都是由block header和block body组成，block header 保存这个Merkle tree 的根哈希值，不保存这个区块的交易信息，而block body保存交易信息</p>
<p><img src="/2020/08/29/%E6%AF%94%E7%89%B9%E5%B8%81%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/QQ%E6%88%AA%E5%9B%BE20200802200930.png"></p>
<p>Merkle tree的作用？</p>
<p>①提供Merkle proof</p>
<p>比特币中的结点分为两类，一类时全节点，还有一类是轻结点</p>
<p>全节点：保存整个区块的内容，block header和block body都有</p>
<p>轻结点：比如手机上的比特币钱包的应用就属于轻结点，只有一个block header</p>
<p>这样就带来一个问题，如果你想向一个轻结点证明某个交易是写入到了区块链中的 ，该怎么证明？</p>
<p>​    比如我想买你的东西，我就需要向你转钱，我对你说，我对你转钱的交易，已经写到了区块链中了，支付已经完成了，</p>
<p>那么你怎么知道，这个交易已经被写入区块链里了呢？这里就需要用到Merkle proof</p>
<p>一个轻结点，向某个全节点发出请求，请求一个能够证明黄色结点这个交易，被包含在这棵Merkle tree里面的Merkle proof</p>
<p><img src="/2020/08/29/%E6%AF%94%E7%89%B9%E5%B8%81%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/QQ%E6%88%AA%E5%9B%BE20200802202232.png"></p>
<p>最后算出的根哈希值，和block header中存储的root hash比较，就可以证明出tx是否在区块链中</p>
<p>这种证明也叫做：</p>
<p>proof of membership</p>
<p>或</p>
<p>proof of inclusion</p>
<p>如果最底下有n个交易：时间复杂度为O(log(n))</p>
<p>那么可不可以证明，区块链中没有某个交易？也就是proof of non-membership</p>
<p>有一种比较笨的方法，就是把这一整颗Merkle tree都传给轻结点，如果hash值都正确，如果某个交易不在叶结点中，则证明了proof of non-membership，时间复杂度为O(n)，有没有比较高效的方法证明不存在？</p>
<p>如果我们对叶结点的排列顺序不了解，那么是没有办法证明交易不在里面的</p>
<p>如果我们对叶结点的排列顺序做一些要求：对每个交易取哈希值，按照这个哈希值从小到大排序，这个时候是有一个好的证明方法的：但是代价是需要排序</p>
<p><img src="/2020/08/29/%E6%AF%94%E7%89%B9%E5%B8%81%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/QQ%E6%88%AA%E5%9B%BE20200802204313.png"></p>
<p>sorted Merkle tree：排好序的Merkle tree</p>
<p>比特币中没有这种排好序的Merkle tree，因为比特币中根本不需要作这种不存在证明，没有硬性需求，所以比特币中的Merkle tree 不要求排序</p>
<h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3.总结"></a>3.总结</h2><p>比特币中的两种数据结构：区块链和Merkle tree</p>
<p>除了这两种数据结构，哈希指针还用在什么地方？</p>
<p>只要这个数据结构是无环的，都可以用哈希指针来代替普通指针，有环会带来一定的问题</p>
<p><img src="/2020/08/29/%E6%AF%94%E7%89%B9%E5%B8%81%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/QQ%E6%88%AA%E5%9B%BE20200802204834.png"></p>
<p>会出现循环依赖的问题，定不下来任何一个区块，找不到创世纪块</p>
]]></content>
      <categories>
        <category>区块链</category>
      </categories>
      <tags>
        <tag>区块链</tag>
      </tags>
  </entry>
  <entry>
    <title>BTC五---网络</title>
    <url>/2020/08/30/%E7%BD%91%E7%BB%9C/</url>
    <content><![CDATA[<h1 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h1><p>新发布的区块，新发布的交易，再区块链中是怎么传播的？</p>
<a id="more"></a>

<p>比特币网络的工作原理</p>
<p>The BitCoin Network，比特币工作在应用层，它的底层是一个P2P Overlay Network，所有结点都是对等的，他不想有些所谓的P2P网络有所谓的超结点(Super node | master node),你要加入比特币网络，你要至少知道一个种子结点（seed node），你和这个种子节点联系，他会告诉你他所知道的网络中的其他节点，节点之间是通过tcp通信的，这样有利于穿破防火墙，你离开的时候也不需要执行其他操作（比如通知其他结点，退出应用程序即可），别的节点没有听到你的消息，过了一段时间就会把你删掉。</p>
<p>比特币网络的设计原则是简单（simple，robust，but not efficient），每个结点维护一个邻居节点的集合，消息传播在网络中采取flooding（泛洪）的方式，结点第一次听到某个消息的时候，把他传播给所有的邻居结点，同时记录一下，这个消息我已经记录过了，下次再收到这个消息的时候，就不用转发给邻居节点了</p>
<p>邻居结点的选取是随机的，没有考虑底层的拓扑结构，和地区没有关系，这样的好处是增强鲁棒性，没有考虑实际的拓扑结构，但是牺牲的是效率，向身边的人转账和向美国的人转账速度其实是差不多的。</p>
<p>比特币系统中每个节点要维护一个等待上链的交易的集合。第二次听到同样的交易就不会传播给邻居结点，避免交易在网络中无限制的传播下去，转发的前提是这个交易得是合法的，这里有一个risk condition：有可能你有两个有冲突的交易，差不多同时被广播到网络上</p>
<p><img src="/2020/08/30/%E7%BD%91%E7%BB%9C/QQ%E6%88%AA%E5%9B%BE20200826201624.png"></p>
<p>新发布的区块在网络中的传播方式和新发布的交易在网络中传播是相似的，每个结点除了要检查区块的内容之外，还要检查一下是否在最长合法链上，越是大的区块，在网络中传播的速度就越慢，比特币协议对区块大小有一个限制，1M字节的限制，1M大小的区块在区块链中的传播时间就已经达到了50秒（传播完）</p>
<p>我们讲的比特币网络，它的传播是属于best effort，一个交易发布到网络上，不一定所有的节点都能收到，而且不同的节点收到这个交易的顺序也不一定是一样的，网络传播存在延迟，有的节点也不一定按照比特币协议的要求转发，比如有的该转发的它不转发，导致某些合法的交易收不到，有些节点也有可能转发一些不该转发的消息，比如有些不合法的交易，他也会转发，这是去中心化系统中所面临的问题</p>
]]></content>
      <categories>
        <category>区块链</category>
      </categories>
      <tags>
        <tag>区块链</tag>
      </tags>
  </entry>
</search>
