<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>CCF一---202006</title>
    <url>/2020/08/29/ccf/202006/</url>
    <content><![CDATA[<h1 id="线性分类器"><a href="#线性分类器" class="headerlink" title="线性分类器"></a>线性分类器</h1><img src="/2020/08/29/ccf/202006/线性分类器(1).png" style="zoom:75%;">

<a id="more"></a>

<img src="/2020/08/29/ccf/202006/线性分类器(2).png" style="zoom:75%;">

<img src="/2020/08/29/ccf/202006/线性分类器(3).png" style="zoom:75%;">

<p>​    思路：读完题目发现，是有关直线和点的分布问题，所以首先想到将点代入原直线方程，如果得到的结果大于0，那么这个点就在直线的上方，反之在下方，按照这个思路，就可以去写代码了。</p>
<p>​    数据结构：考虑到每个点有x坐标（int）、y坐标（int）和类型（String），集合以及数组都不是很好存放point的数据，所以我这里使用Node类存储每个point，然后使用List类型来存放所有的点，使用一个二位数组存放直线的z、x以及y。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x;</span><br><span class="line">        <span class="keyword">int</span> y;</span><br><span class="line">        String type;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>​    初始化用来存储的过程就不用多说，最主要的思路就在于如果计算，因为在原输入中已经给出了是‘A’类型还是‘B’类型，所以在计算之后要判断一下，并且设置一个总的标记<code>flag</code>，和两个A、B的标记<code>flagA</code>、<code>flagB</code>。只要不满足要求（当有两个同类型的点不在同一边）<code>flag</code>就设为false，结束循环，如果满足就一直进行下去，最后，如果<code>flag</code>为true，仍要判断<code>flagA</code>和<code>flagB</code>是否相等，如果相等，仍然不满足要求，输出No。</p>
<p>以下就是我写的代码（测试为100分）:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x;</span><br><span class="line">        <span class="keyword">int</span> y;</span><br><span class="line">        String type;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">int</span> n = scanner.nextInt();</span><br><span class="line">        <span class="keyword">int</span> m = scanner.nextInt();</span><br><span class="line">        List&lt;Node&gt; points = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">// 初始化所有的点的集合</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; n ; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> x = scanner.nextInt();</span><br><span class="line">            <span class="keyword">int</span> y = scanner.nextInt();</span><br><span class="line">            String type = scanner.next();</span><br><span class="line">            Node node = <span class="keyword">new</span> Node();</span><br><span class="line">            node.x = x;</span><br><span class="line">            node.y = y;</span><br><span class="line">            node.type = type;</span><br><span class="line">            points.add(node);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> [][] line = <span class="keyword">new</span> <span class="keyword">int</span>[m][<span class="number">3</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; m ; i++)&#123;</span><br><span class="line">            line[i][<span class="number">0</span>] = scanner.nextInt();</span><br><span class="line">            line[i][<span class="number">1</span>] = scanner.nextInt();</span><br><span class="line">            line[i][<span class="number">2</span>] = scanner.nextInt();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; m ; i++)&#123;</span><br><span class="line">            <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">int</span> flagA = -<span class="number">1</span> , flagB = -<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> z = line[i][<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> x = line[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">int</span> y = line[i][<span class="number">2</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; n ; j++)&#123;</span><br><span class="line">                Node node = points.get(j);</span><br><span class="line">                <span class="comment">// 大于零说明在这条直线上方</span></span><br><span class="line">                <span class="keyword">int</span> t = (z + node.x*x + node.y*y) &gt; <span class="number">0</span> ? <span class="number">1</span>: <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span>(node.type.equals(<span class="string">&quot;A&quot;</span>) )&#123;</span><br><span class="line">                    <span class="keyword">if</span>(flagA == -<span class="number">1</span>)&#123;</span><br><span class="line">                        <span class="comment">// 初始化A类的flag</span></span><br><span class="line">                        flagA = t;</span><br><span class="line">                    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (flagA != t)&#123;</span><br><span class="line">                        flag = <span class="keyword">false</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span> (node.type.equals(<span class="string">&quot;B&quot;</span>))&#123;</span><br><span class="line">                    <span class="keyword">if</span> (flagB == -<span class="number">1</span>)&#123;</span><br><span class="line">                        flagB = t;</span><br><span class="line">                    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(flagB != t)&#123;</span><br><span class="line">                        flag = <span class="keyword">false</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(flag &amp;&amp; flagA != flagB)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Yes&quot;</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;No&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>CCF</tag>
      </tags>
  </entry>
  <entry>
    <title>LOL-show项目工程日志</title>
    <url>/2020/08/30/Java/LOL-show%E9%A1%B9%E7%9B%AE%E5%B7%A5%E7%A8%8B%E6%97%A5%E5%BF%97/</url>
    <content><![CDATA[<h1 id="初衷"><a href="#初衷" class="headerlink" title="初衷"></a>初衷</h1><p>  在我学习完了ssm框架，以及跟着B站视频练习了一个<code>尚筹网</code>的项目之后，准备在暑假巩固所学的框架搭建过程，以及业务逻辑、数据库建表、前端页面的知识，本人喜欢打游戏，所以便有了LOL-show这个项目。</p>
<p>如果你想要学习该项目，那么你可以访问我的github！</p>
<a id="more"></a>

<h1 id="工程结构"><a href="#工程结构" class="headerlink" title="工程结构"></a>工程结构</h1><p><img src="/2020/08/30/Java/LOL-show%E9%A1%B9%E7%9B%AE%E5%B7%A5%E7%A8%8B%E6%97%A5%E5%BF%97/LOL-show-%E5%B7%A5%E7%A8%8B%E5%9B%BE.png"></p>
<p>端口号规定：</p>
<p>eureka:1000</p>
<p>zuul:80</p>
<p>mysql:2000</p>
<p>redis:3000</p>
<p>hero:4000</p>
<p>member:5000</p>
<p>market:6000</p>
<p>order:7000</p>
<p>pay:8000</p>
<h1 id="数据库建表语句"><a href="#数据库建表语句" class="headerlink" title="数据库建表语句"></a>数据库建表语句</h1><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> lol_area(</span><br><span class="line"><span class="keyword">id</span> <span class="built_in">int</span>(<span class="number">11</span>) auto_increment,</span><br><span class="line">area_name <span class="built_in">varchar</span>(<span class="number">100</span>) <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">primary <span class="keyword">key</span>(<span class="keyword">id</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> lol_area(area_name)</span><br><span class="line"> <span class="keyword">values</span></span><br><span class="line"> (<span class="string">&quot;比尔吉沃特&quot;</span>),</span><br><span class="line"> (<span class="string">&quot;德玛西亚&quot;</span>),</span><br><span class="line"> (<span class="string">&quot;弗雷尔卓德&quot;</span>),</span><br><span class="line"> (<span class="string">&quot;无畏先锋&quot;</span>),</span><br><span class="line"> (<span class="string">&quot;恕瑞玛&quot;</span>),</span><br><span class="line"> (<span class="string">&quot;扭曲丛林&quot;</span>),</span><br><span class="line"> (<span class="string">&quot;巨龙之巢&quot;</span>),</span><br><span class="line"> (<span class="string">&quot;艾欧尼亚&quot;</span>),</span><br><span class="line"> (<span class="string">&quot;祖安&quot;</span>),</span><br><span class="line"> (<span class="string">&quot;诺克萨斯&quot;</span>),</span><br><span class="line"> (<span class="string">&quot;班德尔城&quot;</span>),</span><br><span class="line"> (<span class="string">&quot;皮尔特沃夫&quot;</span>),</span><br><span class="line"> (<span class="string">&quot;皮尔特沃夫&quot;</span>),</span><br><span class="line"> (<span class="string">&quot;战争学院&quot;</span>),</span><br><span class="line"> (<span class="string">&quot;巨神峰&quot;</span>),</span><br><span class="line"> (<span class="string">&quot;雷瑟守备&quot;</span>),</span><br><span class="line"> (<span class="string">&quot;钢铁烈阳&quot;</span>),</span><br><span class="line"> (<span class="string">&quot;裁决之地&quot;</span>),</span><br><span class="line"> (<span class="string">&quot;黑色玫瑰&quot;</span>),</span><br><span class="line"> (<span class="string">&quot;暗影岛&quot;</span>),</span><br><span class="line"> (<span class="string">&quot;均衡教派&quot;</span>),</span><br><span class="line"> (<span class="string">&quot;水晶之痕&quot;</span>),</span><br><span class="line"> (<span class="string">&quot;影流&quot;</span>),</span><br><span class="line"> (<span class="string">&quot;守望之海&quot;</span>),</span><br><span class="line"> (<span class="string">&quot;征服之海&quot;</span>),</span><br><span class="line"> (<span class="string">&quot;卡拉曼达&quot;</span>),</span><br><span class="line"> (<span class="string">&quot;皮城警备&quot;</span>);</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">create</span> <span class="keyword">table</span> lol_member(</span><br><span class="line"> <span class="keyword">id</span> <span class="built_in">int</span>(<span class="number">11</span>) auto_increment,</span><br><span class="line"> user_name <span class="built_in">varchar</span>(<span class="number">100</span>),</span><br><span class="line"> role_name <span class="built_in">varchar</span>(<span class="number">100</span>),</span><br><span class="line"> age <span class="built_in">int</span>(<span class="number">11</span>),</span><br><span class="line"> <span class="keyword">password</span> <span class="built_in">varchar</span>(<span class="number">255</span>),</span><br><span class="line"> phone_num <span class="built_in">varchar</span>(<span class="number">100</span>),</span><br><span class="line"> area_id <span class="built_in">int</span>(<span class="number">100</span>),</span><br><span class="line"> primary <span class="keyword">key</span>(<span class="keyword">id</span>)</span><br><span class="line"> );</span><br><span class="line"> </span><br><span class="line"> <span class="comment">-- 用户计划表</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> lol_plan(</span><br><span class="line"><span class="keyword">id</span> <span class="built_in">int</span>(<span class="number">11</span>) auto_increment,</span><br><span class="line">plan_date <span class="built_in">varchar</span>(<span class="number">100</span>),</span><br><span class="line">plan_event <span class="built_in">varchar</span>(<span class="number">300</span>),</span><br><span class="line">last_time <span class="built_in">Integer</span>(<span class="number">11</span>),</span><br><span class="line">member_id <span class="built_in">Integer</span>(<span class="number">11</span>),</span><br><span class="line">primary <span class="keyword">key</span>(<span class="keyword">id</span>)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 英雄表</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> lol_hero(</span><br><span class="line"><span class="keyword">id</span> <span class="built_in">int</span>(<span class="number">11</span>) auto_increment,</span><br><span class="line">full_name <span class="built_in">varchar</span>(<span class="number">100</span>),</span><br><span class="line">nick_name <span class="built_in">varchar</span>(<span class="number">100</span>),</span><br><span class="line">back_story <span class="built_in">text</span>,</span><br><span class="line">price <span class="keyword">double</span>(<span class="number">5</span>,<span class="number">3</span>),</span><br><span class="line"><span class="comment">-- 英雄类型</span></span><br><span class="line">hero_type_id <span class="built_in">varchar</span>(<span class="number">100</span>),</span><br><span class="line"><span class="comment">-- 英雄页面小图</span></span><br><span class="line">img_small <span class="built_in">varchar</span>(<span class="number">300</span>),</span><br><span class="line">img_big <span class="built_in">varchar</span>(<span class="number">300</span>),</span><br><span class="line">img_scot <span class="built_in">varchar</span>(<span class="number">300</span>),</span><br><span class="line">img_stick <span class="built_in">varchar</span>(<span class="number">300</span>),</span><br><span class="line">text1 <span class="built_in">varchar</span>(<span class="number">255</span>),</span><br><span class="line">text2 <span class="built_in">varchar</span>(<span class="number">255</span>),</span><br><span class="line">primary <span class="keyword">key</span>(<span class="keyword">id</span>)</span><br><span class="line">)</span><br><span class="line"><span class="comment">-- 英雄类型表</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> lol_hero_type(</span><br><span class="line"><span class="keyword">id</span> <span class="built_in">int</span>(<span class="number">11</span>) auto_increment,</span><br><span class="line"><span class="keyword">type</span> <span class="built_in">varchar</span>(<span class="number">100</span>),</span><br><span class="line">primary <span class="keyword">key</span>(<span class="keyword">id</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 英雄位置表</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> lol_hero_position(</span><br><span class="line"><span class="keyword">id</span> <span class="built_in">int</span>(<span class="number">11</span>) auto_increment,</span><br><span class="line"><span class="keyword">position</span> <span class="built_in">varchar</span>(<span class="number">100</span>),</span><br><span class="line">primary <span class="keyword">key</span>(<span class="keyword">id</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 外键关联表（英雄和位置）</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> position_inner_hero(</span><br><span class="line"><span class="keyword">id</span> <span class="built_in">int</span>(<span class="number">11</span>) auto_increment,</span><br><span class="line">hero_id <span class="built_in">int</span>(<span class="number">11</span>),</span><br><span class="line">position_id <span class="built_in">int</span>(<span class="number">11</span>),</span><br><span class="line">primary <span class="keyword">key</span>(<span class="keyword">id</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h1 id="SpringBoot-pageHelper插件"><a href="#SpringBoot-pageHelper插件" class="headerlink" title="SpringBoot   pageHelper插件"></a>SpringBoot   pageHelper插件</h1><p>添加依赖</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;pagehelper-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.2.5&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p>用法：在需要分页的方法中启动分页，需要注意的是，分页的是在开启分页之后的第一个查询语句</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Transactional(readOnly = false,propagation = Propagation.REQUIRES_NEW,rollbackFor = Exception.class)</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> PageInfo <span class="title">getPagePlanVOList</span><span class="params">(Integer pageNum, Integer pageSize, Integer id)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 开启分页</span></span><br><span class="line">        PageHelper.startPage(pageNum,pageSize);</span><br><span class="line">        PlanPOExample example = <span class="keyword">new</span> PlanPOExample();</span><br><span class="line">        PlanPOExample.Criteria criteria = example.createCriteria();</span><br><span class="line">        criteria.andMemberIdEqualTo(id);</span><br><span class="line">        <span class="comment">// 执行查询</span></span><br><span class="line">        List&lt;PlanPO&gt; planPOList = planPOMapper.selectByExample(example);</span><br><span class="line">        <span class="comment">// 判断结果</span></span><br><span class="line">        <span class="keyword">if</span>(planPOList.size() == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UnKnowNetWorkException(<span class="string">&quot;没有查询到任何数据，快去添加计划吧！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 结果正确就返回</span></span><br><span class="line">        List&lt;PlanVO&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(PlanPO planPO : planPOList)&#123;</span><br><span class="line">            PlanVO planVO = <span class="keyword">new</span> PlanVO();</span><br><span class="line">            BeanUtils.copyProperties(planPO,planVO);</span><br><span class="line">            list.add(planVO);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 封装PageInfo对象</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> PageInfo(list);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>查询出来的list结果封装到PageInfo实例对象中</p>
<p>注意的是，在后台远程方法调用的时候，PageInfo的泛型并不是PageInfo&lt;List<xxx>&gt;</xxx></p>
<p>而是对应的JavaBean类型例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">PageInfo&lt;PlanVO&gt; <span class="title">getPagePlanVOList</span><span class="params">(Integer pageNum,Integer pageSize,Integer id)</span></span>;</span><br></pre></td></tr></table></figure>

<p>否则会报一个</p>
<p>pagehelper 返回前台的json转换异常com.fasterxml.jackson.databind.exc.Mismatch的异常</p>
<h1 id="使用了layui的日期插件"><a href="#使用了layui的日期插件" class="headerlink" title="使用了layui的日期插件"></a>使用了layui的日期插件</h1><p>点击输入框可以弹出日期选择框，如下图所示效果</p>
<p><img src="/2020/08/30/Java/LOL-show%E9%A1%B9%E7%9B%AE%E5%B7%A5%E7%A8%8B%E6%97%A5%E5%BF%97/QQ%E6%88%AA%E5%9B%BE20200804102439.png"></p>
<p>加入layui的css样式和js</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;layui/css/layui.css&quot;</span> <span class="attr">media</span>=<span class="string">&quot;all&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;layui/layui.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 添加日期插件</span></span><br><span class="line">layui.use(<span class="string">&#x27;laydate&#x27;</span>,<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 生成一个日期实例，这个实例变量名自己指定</span></span><br><span class="line">    <span class="keyword">var</span> laydate = layui.laydate;</span><br><span class="line">    <span class="comment">//执行一个laydate实例</span></span><br><span class="line">    laydate.render(&#123;</span><br><span class="line">        <span class="comment">// 指定在哪里生成日期控件</span></span><br><span class="line">        elem: <span class="string">&#x27;#dateText&#x27;</span>, <span class="comment">//指定元素</span></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h1 id="使用了谷歌Kaptcha-生成验证码插件"><a href="#使用了谷歌Kaptcha-生成验证码插件" class="headerlink" title="使用了谷歌Kaptcha 生成验证码插件"></a>使用了谷歌Kaptcha 生成验证码插件</h1><p>加入依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Google Kaptcha --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.penggle<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>kaptcha<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>相关的配置</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KaptchaConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DefaultKaptcha <span class="title">getDefaultKaptcha</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        com.google.code.kaptcha.impl.DefaultKaptcha defaultKaptcha = <span class="keyword">new</span> com.google.code.kaptcha.impl.DefaultKaptcha();</span><br><span class="line">        Properties properties = <span class="keyword">new</span> Properties();</span><br><span class="line">        <span class="comment">// 图片边框</span></span><br><span class="line">        properties.setProperty(<span class="string">&quot;kaptcha.border&quot;</span>, <span class="string">&quot;yes&quot;</span>);</span><br><span class="line">        <span class="comment">// 边框颜色</span></span><br><span class="line">        properties.setProperty(<span class="string">&quot;kaptcha.border.color&quot;</span>, <span class="string">&quot;105,179,90&quot;</span>);</span><br><span class="line">        <span class="comment">// 字体颜色</span></span><br><span class="line">        properties.setProperty(<span class="string">&quot;kaptcha.textproducer.font.color&quot;</span>, <span class="string">&quot;red&quot;</span>);</span><br><span class="line">        <span class="comment">// 图片宽</span></span><br><span class="line">        properties.setProperty(<span class="string">&quot;kaptcha.image.width&quot;</span>, <span class="string">&quot;110&quot;</span>);</span><br><span class="line">        <span class="comment">// 图片高</span></span><br><span class="line">        properties.setProperty(<span class="string">&quot;kaptcha.image.height&quot;</span>, <span class="string">&quot;40&quot;</span>);</span><br><span class="line">        <span class="comment">// 字体大小</span></span><br><span class="line">        properties.setProperty(<span class="string">&quot;kaptcha.textproducer.font.size&quot;</span>, <span class="string">&quot;30&quot;</span>);</span><br><span class="line">        <span class="comment">// session key</span></span><br><span class="line">        properties.setProperty(<span class="string">&quot;kaptcha.session.key&quot;</span>, <span class="string">&quot;code&quot;</span>);</span><br><span class="line">        <span class="comment">// 验证码长度</span></span><br><span class="line">        properties.setProperty(<span class="string">&quot;kaptcha.textproducer.char.length&quot;</span>, <span class="string">&quot;4&quot;</span>);</span><br><span class="line">        <span class="comment">// 字体</span></span><br><span class="line">        properties.setProperty(<span class="string">&quot;kaptcha.textproducer.font.names&quot;</span>, <span class="string">&quot;宋体,楷体,微软雅黑&quot;</span>);</span><br><span class="line"></span><br><span class="line">        properties.setProperty(<span class="string">&quot;kaptcha.noise.color&quot;</span>, <span class="string">&quot;35,37,38&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Config config = <span class="keyword">new</span> Config(properties);</span><br><span class="line">        defaultKaptcha.setConfig(config);</span><br><span class="line">        <span class="keyword">return</span> defaultKaptcha;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>controller代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/api/kaptcha&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestCode</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    DefaultKaptcha defaultKaptcha;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/defaultKaptcha&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">defaultKaptcha</span><span class="params">(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] captchaChallengeAsJpeg = <span class="keyword">null</span>;</span><br><span class="line">        ByteArrayOutputStream jpegOutputStream = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 生产验证码字符串并保存到session中</span></span><br><span class="line">            String createText = defaultKaptcha.createText();</span><br><span class="line">            System.out.println(createText);</span><br><span class="line">            httpServletRequest.getSession().setAttribute(<span class="string">&quot;verificationCode&quot;</span>, createText);</span><br><span class="line">            <span class="comment">// 使用生成的验证码字符串返回一个BufferedImage对象并转为byte写入到byte数组中</span></span><br><span class="line">            BufferedImage challenge = defaultKaptcha.createImage(createText);</span><br><span class="line">            ImageIO.write(challenge, <span class="string">&quot;jpg&quot;</span>, jpegOutputStream);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalArgumentException e) &#123;</span><br><span class="line">            httpServletResponse.sendError(HttpServletResponse.SC_NOT_FOUND);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 定义response输出类型为image/jpeg类型，使用response输出流输出图片的byte数组</span></span><br><span class="line">        captchaChallengeAsJpeg = jpegOutputStream.toByteArray();</span><br><span class="line">        httpServletResponse.setHeader(<span class="string">&quot;Cache-Control&quot;</span>, <span class="string">&quot;no-store&quot;</span>);</span><br><span class="line">        httpServletResponse.setHeader(<span class="string">&quot;Pragma&quot;</span>, <span class="string">&quot;no-cache&quot;</span>);</span><br><span class="line">        httpServletResponse.setDateHeader(<span class="string">&quot;Expires&quot;</span>, <span class="number">0</span>);</span><br><span class="line">        httpServletResponse.setContentType(<span class="string">&quot;image/jpeg&quot;</span>);</span><br><span class="line">        ServletOutputStream responseOutputStream = httpServletResponse.getOutputStream();</span><br><span class="line">        responseOutputStream.write(captchaChallengeAsJpeg);</span><br><span class="line">        responseOutputStream.flush();</span><br><span class="line">        responseOutputStream.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>前台显示</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">id</span>=<span class="string">&quot;verificationCodeImg&quot;</span> <span class="attr">src</span>=<span class="string">&quot;/api/kaptcha/defaultKaptcha&quot;</span> <span class="attr">style</span>=<span class="string">&quot;cursor: pointer;&quot;</span> <span class="attr">title</span>=<span class="string">&quot;看不清？换一张&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p>添加点击“看不清？换一张”的事件</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 刷新验证码</span></span><br><span class="line">            $(<span class="string">&quot;#verificationCodeImg&quot;</span>).bind(<span class="string">&quot;click&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                $(<span class="built_in">this</span>).hide().attr(<span class="string">&#x27;src&#x27;</span>, <span class="string">&#x27;http://localhost/api/kaptcha/defaultKaptcha?&#x27;</span>).fadeIn();</span><br><span class="line">            &#125;);</span><br></pre></td></tr></table></figure>

<p>效果图</p>
<p><img src="/2020/08/30/Java/LOL-show%E9%A1%B9%E7%9B%AE%E5%B7%A5%E7%A8%8B%E6%97%A5%E5%BF%97/QQ%E6%88%AA%E5%9B%BE20200804103206.png"></p>
<h1 id="改变文本输入框获取值"><a href="#改变文本输入框获取值" class="headerlink" title="改变文本输入框获取值"></a>改变文本输入框获取值</h1><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 为输入英雄名称的文本框绑定文本改变的事件</span></span><br><span class="line">            $(<span class="string">&quot;.inputSearch&quot;</span>).on(<span class="string">&quot;input&quot;</span>,<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="keyword">let</span> heroName = $(<span class="built_in">this</span>).val()</span><br><span class="line">            &#125;)</span><br></pre></td></tr></table></figure>

<h1 id="mybatis模糊查询的三种方式"><a href="#mybatis模糊查询的三种方式" class="headerlink" title="mybatis模糊查询的三种方式"></a>mybatis模糊查询的三种方式</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select id,name,age,score from star where name like &quot;%&quot; #&#123;name&#125; &quot;%&quot;</span><br><span class="line"></span><br><span class="line">&lt;!--concat拼接字符串  mysql独有的函数--&gt;</span><br><span class="line">select id,name,age,score from star where name like concat(&quot;%&quot;,#&#123;name&#125;,&quot;%&quot;)</span><br><span class="line"></span><br><span class="line">&lt;!-- 如果传入的参数是简单数据类型，$&#123;&#125;里面必须写value --&gt;</span><br><span class="line">select id,name,age,score from star where name like &quot;%$&#123;value&#125;%&quot;</span><br><span class="line"></span><br><span class="line">作者：叫我不矜持</span><br><span class="line">链接：https:&#x2F;&#x2F;www.jianshu.com&#x2F;p&#x2F;6d244e194859</span><br><span class="line">来源：简书</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>

<h1 id="thymeleaf循环的状态变量"><a href="#thymeleaf循环的状态变量" class="headerlink" title="thymeleaf循环的状态变量"></a>thymeleaf循环的状态变量</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">th:each属性用于迭代循环，语法：th:each&#x3D;&quot;obj,iterStat:$&#123;objList&#125;&quot;</span><br><span class="line">迭代对象可以是Java.util.List,java.util.Map,数组等;</span><br><span class="line">iterStat称作状态变量，属性有：</span><br><span class="line">    index:当前迭代对象的index（从0开始计算）</span><br><span class="line">    count: 当前迭代对象的index(从1开始计算)</span><br><span class="line">    size:被迭代对象的大小</span><br><span class="line">    current:当前迭代变量</span><br><span class="line">    even&#x2F;odd:布尔值，当前循环是否是偶数&#x2F;奇数（从0开始计算）</span><br><span class="line">    first:布尔值，当前循环是否是第一个</span><br><span class="line">    last:布尔值，当前循环是否是最后一个</span><br></pre></td></tr></table></figure>

<h1 id="mysql-根据拼音首字母查询"><a href="#mysql-根据拼音首字母查询" class="headerlink" title="mysql 根据拼音首字母查询"></a>mysql 根据拼音首字母查询</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT id,full_name ,</span><br><span class="line"></span><br><span class="line">ELT(INTERVAL(CONV(HEX(LEFT(CONVERT(full_name USING gbk),1)),16,10),</span><br><span class="line"></span><br><span class="line">0xB0A1,0xB0C5,0xB2C1,0xB4EE,0xB6EA,0xB7A2,0xB8C1,0xB9FE,0xBBF7,</span><br><span class="line"></span><br><span class="line">0xBFA6,0xC0AC,0xC2E8,0xC4C3,0xC5B6,0xC5BE,0xC6DA,0xC8BB,0xC8F6,</span><br><span class="line"></span><br><span class="line">0xCBFA,0xCDDA,0xCEF4,0xD1B9,0xD4D1),</span><br><span class="line"></span><br><span class="line">&#39;A&#39;,&#39;B&#39;,&#39;C&#39;,&#39;D&#39;,&#39;E&#39;,&#39;F&#39;,&#39;G&#39;,&#39;H&#39;,&#39;J&#39;,&#39;K&#39;,&#39;L&#39;,&#39;M&#39;,&#39;N&#39;,&#39;O&#39;,&#39;P&#39;,</span><br><span class="line"></span><br><span class="line">&#39;Q&#39;,&#39;R&#39;,&#39;S&#39;,&#39;T&#39;,&#39;W&#39;,&#39;X&#39;,&#39;Y&#39;,&#39;Z&#39;) AS PY</span><br><span class="line"></span><br><span class="line">FROM lol_hero WHERE ELT(INTERVAL(CONV(HEX(LEFT(CONVERT(full_name USING gbk),1)),16,10),</span><br><span class="line"></span><br><span class="line">0xB0A1,0xB0C5,0xB2C1,0xB4EE,0xB6EA,0xB7A2,0xB8C1,0xB9FE,0xBBF7,</span><br><span class="line"></span><br><span class="line">0xBFA6,0xC0AC,0xC2E8,0xC4C3,0xC5B6,0xC5BE,0xC6DA,0xC8BB,0xC8F6,</span><br><span class="line"></span><br><span class="line">0xCBFA,0xCDDA,0xCEF4,0xD1B9,0xD4D1),</span><br><span class="line"></span><br><span class="line">&#39;A&#39;,&#39;B&#39;,&#39;C&#39;,&#39;D&#39;,&#39;E&#39;,&#39;F&#39;,&#39;G&#39;,&#39;H&#39;,&#39;J&#39;,&#39;K&#39;,&#39;L&#39;,&#39;M&#39;,&#39;N&#39;,&#39;O&#39;,&#39;P&#39;,</span><br><span class="line"></span><br><span class="line">&#39;Q&#39;,&#39;R&#39;,&#39;S&#39;,&#39;T&#39;,&#39;W&#39;,&#39;X&#39;,&#39;Y&#39;,&#39;Z&#39;) &#x3D; &#39;A&#39;</span><br></pre></td></tr></table></figure>

<h1 id="部署项目"><a href="#部署项目" class="headerlink" title="部署项目"></a>部署项目</h1><h2 id="打包"><a href="#打包" class="headerlink" title="打包"></a>打包</h2><p>包含第三方jar包的工程的build</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">                第三方jar包目录</span><br><span class="line">                <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/resources/lib<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">targetPath</span>&gt;</span>BOOT-INF/lib/<span class="tag">&lt;/<span class="name">targetPath</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.jar<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/resources<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">targetPath</span>&gt;</span>BOOT-INF/classes/<span class="tag">&lt;/<span class="name">targetPath</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.1.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;maven-compiler-plugin.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">source</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">skip</span>&gt;</span>true<span class="tag">&lt;/<span class="name">skip</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">encoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">encoding</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">compilerArguments</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">extdirs</span>&gt;</span>$&#123;project.basedir&#125;/src/main/resources/lib<span class="tag">&lt;/<span class="name">extdirs</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">compilerArguments</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>其余的，如果依赖springboot父工程，加上</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.1.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如果不依赖任何工程，直接打包</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mvn clean install -Dmaven.test.skip=true // 忽略test</span><br></pre></td></tr></table></figure>

<h2 id="准备服务器环境"><a href="#准备服务器环境" class="headerlink" title="准备服务器环境"></a>准备服务器环境</h2><p>安装jdk</p>
<p>在/etc/profile文件的最后配置java环境</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">JAVA_HOME=/opt/sorftware/jdk1.8.0_251</span><br><span class="line">PATH=$PATH:$JAVA_HOME/bin</span><br><span class="line">export JAVA_HOME PATH</span><br></pre></td></tr></table></figure>

<p>安装mysql</p>
<p><a href="https://www.cnblogs.com/cannel/p/11104195.html">参考</a></p>
<p>缺少 libaio</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum install libaio</span><br></pre></td></tr></table></figure>

<p>修改密码需要设置密码的级别：注意！</p>
<p>授权远程连接</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GRANT ALL PRIVILEGES ON *.* TO &#39;root&#39;@&#39;%&#39; IDENTIFIED BY &#39;rootroot&#39; WITH GRANT OPTION;</span><br></pre></td></tr></table></figure>

<p>微服务远程调用报错找不到主机，因为我的redisServer以及mysqlServer在另一个服务器上，所以consumer想要调用这两个server的服务，必须找到我的另一个服务器，但是我发现服务器的名字没有使用ip地址，所以依照<code>参考</code>的调试最后成功了！</p>
<p>运行jar包</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nohup java -jar xxx.jar &gt;/dev/null 2&gt;&amp;1 &amp;</span><br></pre></td></tr></table></figure>



<p>报错：UnknownHostException</p>
<p><a href="https://blog.csdn.net/weixin_39032575/article/details/83011334?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param">参考</a></p>
]]></content>
      <categories>
        <category>项目</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>java随笔</title>
    <url>/2020/09/10/Java/java%E9%9A%8F%E7%AC%94/</url>
    <content><![CDATA[<p>  在学习的过程中，难免会碰到自己从未接触过的知识和技巧，有时候一边看过去会忘记，所以把它记录下来是最好的选择，而不是假装自己会了，又继续学习别的知识，这样的话，对后续的工作和学习都会带来一些不必要的麻烦。</p>
<p>  我自认为，在学习的时候，应该自己主动思考，如果这样的话，结果是怎么样，那样的话，结果是怎么样，我们在整个小学、初中、高中，甚至是大学，都被灌输了一种思想，就是，这样就是对的，那么当我们碰到问题的时候，往往就会一头雾水，不知如何下手，如果有主动思考的能力的话，这种问题是不是就会没有那么棘手呢？</p>
<a id="more"></a>

<p>2020.9.10</p>
<p>在阅读《疯狂java讲义》一书中HashMap的介绍，书中实例HashMap类实例的put方法，发现他有一个返回值，并且是Object类型的，这我就纳闷了，添加元素，一般不是返回true就是false啊？我在一篇博客的评论下发现了答案，原来是</p>
<blockquote>
<p>如果此前存在一个相同的key，那么put方法返回的是前面key的value值，这时候后来put的value就会覆盖前面put进去的值；如果当前put方法，put的是一个新的key，那么返回值就是null。</p>
</blockquote>
<p>2020.9.14</p>
<p>关于将线程不安全的HashSet、HashMap、ArrayList类转化成线程安全的类的介绍中</p>
<p>使用Collections.synchronizeXXX</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Person&gt; allList = Collections.synchronizedList(<span class="keyword">new</span> ArrayList());</span><br><span class="line"> Iterator&lt;Integer&gt; iterator = allList .iterator();</span><br><span class="line">	 <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">		 Integer integer = (Integer) iterator.next();</span><br><span class="line">		 System.out.println(integer);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>如上所示：因为迭代器不是线程安全的，所以还需要同步allList，使获得迭代器的过程也是同步的，这样在操作同步后的集合在遍历的时候就被锁住，不能在进行别的操作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Person&gt; allList = Collections.synchronizedList(<span class="keyword">new</span> ArrayList());</span><br><span class="line"><span class="keyword">synchronized</span>（allList ）&#123;</span><br><span class="line">	Iterator&lt;Integer&gt; iterator = allList .iterator();</span><br><span class="line">	<span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">		Integer integer = (Integer) iterator.next();</span><br><span class="line">		System.out.println(integer);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>











]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>peanutMallFollowCoderwhy工程日志</title>
    <url>/2020/09/11/Java/peanutMallFollowCoderwhy%E5%B7%A5%E7%A8%8B%E6%97%A5%E5%BF%97/</url>
    <content><![CDATA[<h1 id="项目工程概述"><a href="#项目工程概述" class="headerlink" title="项目工程概述"></a>项目工程概述</h1><p>项目github仓库地址：<a href="https://github.com/JustinPeanut/peanutMallFollowCoderwhy">peanutMallFollowCoderwhy</a></p>
<p><code>talk is cheap, show me your code</code></p>
<p>一下记录我跟随coderwhy老师开发mall商城应用中碰到的一些问题和需要注意的点。</p>
<a id="more"></a>

<h1 id="碰到的问题"><a href="#碰到的问题" class="headerlink" title="碰到的问题"></a>碰到的问题</h1><h2 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h2><p>在创建项目的时候，不能使用大写或者一些其他特殊字符</p>
<p><code>git remove add origin respostity url</code>:将远程仓库和本地仓库联系起来</p>
<p>划分目录结构：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">assets				<span class="comment">// 资源</span></span><br><span class="line"> --img</span><br><span class="line"> --css</span><br><span class="line">    --normalize.css	<span class="comment">// 对不同浏览器的标签样式统一(在github下载)</span></span><br><span class="line">    --base.css		<span class="comment">// 初始化css设置</span></span><br><span class="line">views				<span class="comment">// 视图</span></span><br><span class="line">componets			<span class="comment">// 公共组件</span></span><br><span class="line"> --common			<span class="comment">// 完全公共的组件，可以给别的项目使用</span></span><br><span class="line"> --content			<span class="comment">// 和当前组件业务相关的组件</span></span><br><span class="line">router				<span class="comment">// 路由相关</span></span><br><span class="line">store				<span class="comment">// vuex公共状态管理</span></span><br><span class="line">network				<span class="comment">// 网络相关封装</span></span><br><span class="line">common				<span class="comment">// 公共的一些常量，或者工具类</span></span><br></pre></td></tr></table></figure>

<p>在根目录下创建vue.config.js配置别名。</p>
<p>在根目录下创建代码规范文件<code>.editorConfig</code>。</p>
<h2 id="开发"><a href="#开发" class="headerlink" title="开发"></a>开发</h2><h3 id="tabBar"><a href="#tabBar" class="headerlink" title="tabBar"></a>tabBar</h3><p>如果你配置了别名，那么dom中引用url的时候，一定要加上~</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;~assets/img/tabbar/home.svg&quot;</span> <span class="attr">slot</span>=<span class="string">&quot;img-common-slot&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>要不然就获取不到相应的图片。</p>
<p>设置点击之后active的样式</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;tab-item&quot;</span> @click=<span class="string">&quot;itemClick&quot;</span>&gt;</span><br><span class="line">        &lt;slot v-<span class="keyword">if</span>=<span class="string">&quot;!isActive&quot;</span> name=<span class="string">&quot;img-common-slot&quot;</span>&gt;&lt;/slot&gt;</span><br><span class="line">        &lt;slot v-<span class="keyword">else</span> name=<span class="string">&quot;img-active-slot&quot;</span>&gt;&lt;/slot&gt;</span><br><span class="line">    &lt;div :style=<span class="string">&quot;isTextActive&quot;</span>&gt;</span><br><span class="line">        &lt;slot name=<span class="string">&quot;textSlot&quot;</span>&gt;&lt;/slot&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    name: <span class="string">&quot;TabBarItem&quot;</span>,</span><br><span class="line">    props: &#123;</span><br><span class="line">      path: &#123;</span><br><span class="line">        type: <span class="built_in">String</span></span><br><span class="line">        &#125;,</span><br><span class="line">      <span class="comment">// 父组件给子组件传值</span></span><br><span class="line">      textColor: &#123;</span><br><span class="line">        type: <span class="built_in">String</span>,</span><br><span class="line">        <span class="keyword">default</span>: <span class="string">&quot;red&quot;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">      itemClick()&#123;</span><br><span class="line">        <span class="built_in">this</span>.$router.replace(<span class="built_in">this</span>.path);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    computed: &#123;</span><br><span class="line">      isActive()&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.$route.path.indexOf(<span class="built_in">this</span>.path) != <span class="number">-1</span>;</span><br><span class="line">      &#125;,</span><br><span class="line">      isTextActive()&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.isActive ? &#123;<span class="attr">color</span>: <span class="built_in">this</span>.textColor&#125;: &#123;&#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line">  .tab-item&#123;</span><br><span class="line">    height: <span class="number">49</span>px;</span><br><span class="line">    text-align: center;</span><br><span class="line">    flex: <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  .tab-item img&#123;</span><br><span class="line">    width: <span class="number">24</span>px;</span><br><span class="line">    height: <span class="number">24</span>px;</span><br><span class="line">    vertical-align: middle;</span><br><span class="line">    margin: <span class="number">4</span>px <span class="number">0</span> <span class="number">2</span>px <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  .active&#123;</span><br><span class="line">    color: red</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="navBar"><a href="#navBar" class="headerlink" title="navBar"></a>navBar</h3><p>注意：插槽如果有多个，要使用具名插槽，在使用的时候也要指定替换哪一个插槽，效果图如下</p>
<p><img src="/2020/09/11/Java/peanutMallFollowCoderwhy%E5%B7%A5%E7%A8%8B%E6%97%A5%E5%BF%97/QQ%E6%88%AA%E5%9B%BE20200911105742.png"></p>
<h3 id="封装网络请求"><a href="#封装网络请求" class="headerlink" title="封装网络请求"></a>封装网络请求</h3><p>我们知道axios是第三方框架，如果有那一天这个第三方框架不更新的话，我们如果在项目中多处使用了axios，代码的重构就会带来很多不必要的麻烦。</p>
<p>①下载axios插件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install axios</span><br></pre></td></tr></table></figure>

<p>②使用的时候不需要Vue.use命令install</p>
<p>直接导入axios即可使用，详情课参照官方文档            <a href="http://www.axios-js.com/zh-cn/docs/">axios官方文档</a></p>
<p>github xowen</p>
<p>出现的问题：在传回axios实例之后，发现调用then方法失败，原因是：应当返回axiosInstance(config)配置过后的axiosInstance</p>
<p>错误代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Axios <span class="keyword">from</span> <span class="string">&quot;axios&quot;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">request</span>(<span class="params">config</span>)</span>&#123;</span><br><span class="line">  <span class="comment">// 创建axios实例，设置baseConfig</span></span><br><span class="line">  <span class="keyword">const</span> axiosInstance = Axios.create(&#123;</span><br><span class="line">    baseURL: <span class="string">&quot;http://123.207.32.32:8000&quot;</span>,</span><br><span class="line">    timeout: <span class="number">5000</span></span><br><span class="line">  &#125;);</span><br><span class="line">  axiosInstance(config);</span><br><span class="line">  <span class="keyword">return</span> axiosInstance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    原因是因为axios实例配置过后的实例返回的是一个promise，所以可以调用then方法</p>
<p>正确代码:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Axios <span class="keyword">from</span> <span class="string">&quot;axios&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">request</span>(<span class="params">config</span>)</span>&#123;</span><br><span class="line">  <span class="comment">// 创建axios实例，设置baseConfig</span></span><br><span class="line">  <span class="keyword">const</span> axiosInstance = Axios.create(&#123;</span><br><span class="line">    baseURL: <span class="string">&quot;http://123.207.32.32:8000&quot;</span>,</span><br><span class="line">    timeout: <span class="number">5000</span></span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="comment">// 拦截器</span></span><br><span class="line">  axiosInstance.interceptors.request.use(<span class="function"><span class="params">config</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(config);</span><br><span class="line">    <span class="keyword">return</span> config;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> axiosInstance(config);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="封装轮播图"><a href="#封装轮播图" class="headerlink" title="封装轮播图"></a>封装轮播图</h3><p>注意：在每次滚动之后，都要验证位置，如果位置超过了图片的长度</p>
<h3 id="开发FeatureView"><a href="#开发FeatureView" class="headerlink" title="开发FeatureView"></a>开发FeatureView</h3><p>点击FeatureView图片之后跳转的超链接</p>
<p><a href="https://act.mogujie.com/zzlx67">https://act.mogujie.com/zzlx67</a></p>
<h3 id="TabControl"><a href="#TabControl" class="headerlink" title="TabControl"></a>TabControl</h3><p><img src="/2020/09/11/Java/peanutMallFollowCoderwhy%E5%B7%A5%E7%A8%8B%E6%97%A5%E5%BF%97/QQ%E6%88%AA%E5%9B%BE20200921105012.png"></p>
<p>如果只是文字不一样的话，就没有必要用插槽</p>
<p>取而代之：</p>
<p><img src="/2020/09/11/Java/peanutMallFollowCoderwhy%E5%B7%A5%E7%A8%8B%E6%97%A5%E5%BF%97/QQ%E6%88%AA%E5%9B%BE20200921105558.png"></p>
<p>当需要设置点击active的样式，使用currentIndex标记当前所处于的标签，使用循环中的index和currentIndex判断是不是相等，如果相等，就是处于活跃的标签</p>
<p>其中定义的变量</p>
<p><code>--color-high-text</code>:文字高亮颜色</p>
<p><code>--color-tint</code>:下划线高亮</p>
<p>如果希望滚动的时候，停留在页面的顶端，可以设置css</p>
<p>在没有达到top：xxpx之前，position的属性默认是一个static，当达到xxpx时，浏览器会自动将posiotion的属性改成fixed</p>
<p>（如果需要适配ie浏览器，这个属性就不能随便用了）</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attribute">position</span>: sticky;</span><br><span class="line">    <span class="attribute">top</span>: xxpx; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="商品列表页"><a href="#商品列表页" class="headerlink" title="商品列表页"></a>商品列表页</h3><p><img src="/2020/09/11/Java/peanutMallFollowCoderwhy%E5%B7%A5%E7%A8%8B%E6%97%A5%E5%BF%97/QQ%E6%88%AA%E5%9B%BE20200921112812.png"></p>
<p>create函数中些主要逻辑，主要是实现的方法在methods中执行</p>
<p><img src="/2020/09/11/Java/peanutMallFollowCoderwhy%E5%B7%A5%E7%A8%8B%E6%97%A5%E5%BF%97/QQ%E6%88%AA%E5%9B%BE20200922150027.png"></p>
<p>push方法可以传入可变参数，如果希望把一个数组push到另一个数组中，可以使用数组1.push(…数组2)</p>
<p>关于样式调整：</p>
<p><code>flex-wrap：wrap</code>根据子元素的宽度适配每一行占多少个子元素。</p>
<p><code>justify-content:space-around</code>：子元素占据每一行并均等分，但是中间的宽度是左右宽度的2倍</p>
<p><img src="/2020/09/11/Java/peanutMallFollowCoderwhy%E5%B7%A5%E7%A8%8B%E6%97%A5%E5%BF%97/QQ%E6%88%AA%E5%9B%BE20200922154540.png"></p>
<h3 id="切换点击的类型对应现实的商品"><a href="#切换点击的类型对应现实的商品" class="headerlink" title="切换点击的类型对应现实的商品"></a>切换点击的类型对应现实的商品</h3><p>注意的问题是，子组件向父组件传递参数的方法：</p>
<p>子组件：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">setActive(index)&#123;</span><br><span class="line">        <span class="built_in">this</span>.currentIndex = index;</span><br><span class="line">        <span class="comment">// 传回父组件，监听当前index的点击，对应修改展示的商品信息</span></span><br><span class="line">        <span class="built_in">this</span>.$emit(<span class="string">&#x27;tabClick&#x27;</span>,index);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>父组件(其中，父组件用来接收子组件传递的方法的那个方法中不需要携带index形参)：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;tab-control <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;tab-control&quot;</span> :titles=<span class="string">&quot;[&#x27;流行&#x27;,&#x27;新款&#x27;,&#x27;精选&#x27;]&quot;</span> @tabClick=<span class="string">&quot;tabClick&quot;</span>/&gt;</span><br></pre></td></tr></table></figure>

<h3 id="better-scoll的安装和使用"><a href="#better-scoll的安装和使用" class="headerlink" title="better-scoll的安装和使用"></a>better-scoll的安装和使用</h3><p>使用原生的滚动（内容多余整个屏幕的时候），在移动端滚动的时候会非常的卡顿，以前为了适配移动端滚动的问题，使用了<code>iscoll</code>框架，但是现在他没有更新了，所以我们使用国内开发的一个<code>better-scoll</code></p>
<p>安装</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">npm install better-scroll --save</span><br></pre></td></tr></table></figure>

<p>如果想实现原生的局部js滚动，可以使用如下方式，但是前提是必须给父标签一个固定的高度才行。</p>
<p><img src="/2020/09/11/Java/peanutMallFollowCoderwhy%E5%B7%A5%E7%A8%8B%E6%97%A5%E5%BF%97/QQ%E6%88%AA%E5%9B%BE20200928104118.png"></p>
<p>第三方的框架， 要注意封装，万一他不更新，就凉凉了，下次如果项目中有很多地方使用到了这个框架，改起来很要命的</p>
<p>使用</p>
<p><img src="/2020/09/11/Java/peanutMallFollowCoderwhy%E5%B7%A5%E7%A8%8B%E6%97%A5%E5%BF%97/QQ%E6%88%AA%E5%9B%BE20200928104759.png"></p>
<p>上述使用是错误的，因为这个方法会在创建组建的时候被调用，这时候还没有挂载template，所以一直拿不到content。</p>
<p>在使用的时候，根据官方文档的说明，必须在管理的标签外面加一层<code>wrapper</code>,并且管理的内容必须是一个标签</p>
<p>如果向监听用户滚动到哪一个位置了：并对当前状态添加一些业务功能</p>
<p>但是默认情况下，Bscroll是不能实时监听滚动的位置的，如果想要实时监听滚动的化，必须给他传参数</p>
<p>参数：</p>
<p>①probeType：是否侦测。0，1都是不侦测；2表示在手指滚动的过程中侦测，手指离开后的惯性滚动过程不侦测；3表示只要是滚动都侦测。（配合<code>scroll</code>事件使用）</p>
<p>②click：默认值位false，在<code>wrapper</code>中管理的<code>content</code>如果有监听click事件，默认是不会生效的，如果将click属性改为true，才会传派事件。</p>
<p>③pullUpload：上拉加载更多(配合<code>pullingUp</code>使用)，但是当前页面只能调用一次上拉加载的回调函数，需要在最后调用一个<code>finishPullUp</code>方法，结束当前上拉加载，才能监听下一次上拉加载。</p>
<p><img src="/2020/09/11/Java/peanutMallFollowCoderwhy%E5%B7%A5%E7%A8%8B%E6%97%A5%E5%BF%97/QQ%E6%88%AA%E5%9B%BE20200928152425.png"></p>
<p>封装better-scroll：封装一个vue文件，这个vue文件对better-scroll有依赖，其他的vue文件只要引用这个vue文件就可以了。</p>
<p>使用document.query获取<code>wrapper</code>的方式不是特别好，如果在其他组件中也有class为<code>wrapper</code>的标签，那么获取的时候就会有一些问题（query获取的是同一个页面上的第一个查询到的元素），在vue开发的时候经常出现类似的这种问题，值得注意，推荐的方法：</p>
<blockquote>
<p>在vue中给标签绑定一个ref属性</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">ref</span>=<span class="string">&quot;aaa&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>之后再下面就可以通过this.$refs.aaa拿到上述标记的标签，但是在前面所讲的ref是在父组件中给子组件标记，然后拿到相应的子组件的方法。这里标记普通的标签也是可行的。</p>
</blockquote>
<p>在给组件中的元素添加样式的时候，如果style标签中没有加上scoped属性，那么这个style中设置的样式就是全局的，例如</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">scoped</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>为某个div设置高度</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    其中vh是 视口的高度100vh == 100 %</span><br><span class="line">    <span class="selector-tag">height</span>: 100<span class="selector-tag">vh</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2020/09/11/Java/peanutMallFollowCoderwhy%E5%B7%A5%E7%A8%8B%E6%97%A5%E5%BF%97/QQ%E6%88%AA%E5%9B%BE20200929173815.png"></p>
<p>可以动态计算高度，也可以使用定位</p>
<p><img src="/2020/09/11/Java/peanutMallFollowCoderwhy%E5%B7%A5%E7%A8%8B%E6%97%A5%E5%BF%97/QQ%E6%88%AA%E5%9B%BE20200929173937.png"></p>
<h4 id="出现的问题"><a href="#出现的问题" class="headerlink" title="出现的问题"></a>出现的问题</h4><p>然而在我加入better-scroll之后，页面上的元素都动不了了，就好像里面没有东西一样，这就很奇怪了，我封装的scroll应该没有问题（因为我在分类中测试了），问题应该处在home页的css上面，但是并不知道哪里的问题。</p>
<p>上百度看了，滚动不了的问题无非是<code>wrapper</code>的高度要比<code>content</code>的低，<code>content</code>下只能有一个子标签，这些问题我都注意了，但是还是不管用，无能为力。</p>
<p>但是反复测试，在pc端换设备测试的时候发现，换来换去怎么又好使了？这也太玄学了吧。看来better-scroll插件还不是很稳定。</p>
<p>想到可能是版本太高？所以就换了个低版本，1.15.2（和coderwhy一样的版本测试），果然，换了版本之后就好用了。</p>
<h3 id="backtop"><a href="#backtop" class="headerlink" title="backtop"></a>backtop</h3><p>如果想要监听组件的点击，需要添加修饰符<code>native</code></p>
<p>给子组件添加ref属性，可以直接访问子组件中的内容。</p>
<p><img src="/2020/09/11/Java/peanutMallFollowCoderwhy%E5%B7%A5%E7%A8%8B%E6%97%A5%E5%BF%97/QQ%E6%88%AA%E5%9B%BE20201006155249.png"></p>
<h3 id="上拉加载更多"><a href="#上拉加载更多" class="headerlink" title="上拉加载更多"></a>上拉加载更多</h3><p>做完一次上拉加载更多，加载数据之后，不要忘了调用scroll对象中的finishPullUp方法</p>
]]></content>
      <categories>
        <category>项目</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>ETH一---概述</title>
    <url>/2020/10/04/%E5%8C%BA%E5%9D%97%E9%93%BE/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%A6%82%E8%BF%B0/</url>
    <content><![CDATA[<h1 id="以太坊概述"><a href="#以太坊概述" class="headerlink" title="以太坊概述"></a>以太坊概述</h1><p>比特币和以太坊是区块链中的最主要的两种加密货币，比特币被称为区块链1.0，以太坊被称为2.0</p>
<p>以太坊对比特币运行过程中出现的问题做出了改进，比如说出块时间，比特币是十分钟，有人认为太长了，以太坊当中出块时间大幅度地降低到了十几秒，而且，为了这种出块时间，以太坊还设计了一套ghost的共识机制；另一个重大的改进是mining puzzle：比特币的mining puzzle是计算密集型的，比拼的是挖矿的计算能力，这种结果就造就了现在的挖矿设备专业化。以太坊对内存的要求是很高的，memory hard mining puzzle，这样就在一定程度上限制了ASIC芯片的使用，我们管它叫做ASIC resistance，将来以太坊还会有一些更高的改进，用proof of stake（权益证明，不挖矿，而是按照股份和权益，用类似于投票的方式来决定下一个区块该怎么产生）替换proof of work。</p>
<a id="more"></a>

<p>以太坊还增加了一个重要的功能，就是对智能合约（smart contract）的支持。智能合约？</p>
<p>我们知道Bitcoin：decentralized currency，根据比特币成功的案例，我们知道他是去中心化的，如果货币去中心化怎么办？还有什么可以去中心化？</p>
<blockquote>
<p>以太坊就提出了decentralized contract（去中心化的合约）什么是decentralized contract？</p>
<p>货币本来是由政府发行的，货币的价值建立在政府公信力的基础上，然后政府通过司法手段维护货币体系的正常运行，比特币的出现，将政府的这些职能取代了，通过密码学、共识机制来维护加密货币体系的正常运行。</p>
<p>去中心化的合约也是类似。现实中的合约应该也是通过司法手段、通过政府来维护，那么我们能不能通过技术手段，将司法手段取代了，这就是以太坊智能合约设计的一个目的，如果合同中的内容可以通过程序代码来实现出来的，那么我们把这个代码就可以放在区块链上，通过区块链的不可篡改性，来保证这个代码的正确运行，当然，不是所有的合约的内容都可以用编程语言来实现，也不是所有的合同条款能够量化的。</p>
</blockquote>
<p>这种去中心化的合同有什么好处呢？</p>
<blockquote>
<p>首先思考去中心化的货币有什么好处？有什么应用场景？</p>
<p>可以实现跨国转账，手续没有跨国转账那么麻烦；智能合约也有一些类似的应用场景，比如如果合同的签署方是来自世界各地的，没有一个统一的司法管辖权，这个时候如果用司法来管辖，就比较困难：比如说众筹，你都不知道每个人都来自哪，所以可以使用程序写好的规则来管辖，这时候就会比较方便。（其实，就算是所有的人都在同一个司法管辖之下的，你想真正用司法手段来维护，也是一个比较费时费力的过程）。</p>
</blockquote>
]]></content>
      <categories>
        <category>区块链</category>
      </categories>
      <tags>
        <tag>区块链</tag>
      </tags>
  </entry>
  <entry>
    <title>ETH三---状态树</title>
    <url>/2020/10/04/%E5%8C%BA%E5%9D%97%E9%93%BE/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E7%8A%B6%E6%80%81%E6%A0%91/</url>
    <content><![CDATA[<h1 id="ETH-状态树"><a href="#ETH-状态树" class="headerlink" title="ETH-状态树"></a>ETH-状态树</h1><p>以太坊的账户是基于账户的模式，系统中显示的维护每个账户有多少余额。</p>
<p>我们需要完成的是账户地址，到账户状态的映射（addr(160 bits == 表示成40个16进制的数)-&gt;state）,这里的状态指的是外部账户和合约账户的状态。</p>
<a id="more"></a>

<p>①这有点像key-value对，给出一个账户地址，要找出一个相应的状态。如果就用一个哈希表怎么样？每创建一个账户就存入哈希表（不考虑哈希碰撞，它的效率是常量级的）</p>
<blockquote>
<p>用这个表的话，如果要提供Merkle proof，怎么提供？</p>
<p>比如说，你要和一个人签合同，希望他能证明一下他有多少钱，一种方法是，把这个哈希表中的元素（内容）组织成一个Merkle tree，然后算出一个根哈希值，这个根哈希值得保存在block header里，公布出去，那么这个根哈希值只要是正确的，就能保证底下的树不会被篡改。那如果有新的交易怎么办，新的交易必然会导致哈希表的内容变化，然后我们发布下一个区块的时候，要把这些哈希表中的内容在组织成一棵Merkle tree吗？这个代价会不会太大了点，实际上发生变化的状态只是一小部分。难道，比特币在构建新区块的时候就不用构建一颗新的Merkle tree吗？那个为什么没有这个问题？因为比特币发布的区块中的Merkle tree是通过区块中的交易来构建的，每个区块中的交易都不一样。如果像以太坊中的所有账户都构成一个Merkle tree来比较，代价就太大了（这比交易构成Merkle tree要高出好几个数量级）。</p>
<p>除了提供Merkle proof 证明账户上有多少钱之外，这个Merkle tree还有另外的作用：维护各个全节点之间状态的一致性（这也就是为什么比特币把根哈希值写在块头里的一个原因，对于这个区块中包含那些交易，全节点要有一个共识）。</p>
</blockquote>
<p>所以如果就简单的全节点在本地维护一个哈希表，然后需要Merkle tree的时候构建Merkle tree，根哈希值放在块头，这个方法是不行的。</p>
<p>②我们不需要哈希表了，直接就把所有的账户放进去，你要改的时候直接在Merkle tree里改，因为你每次更新的都是一小部分账户，所以你每次修改的都是Merkle tree中的一小部分？</p>
<blockquote>
<p>这个方法的问题在于，没有提供一个高效的查找和更新的方法，还有一个问题在于，我们这个Merkle tree要排序吗？如果不排序会怎么样？</p>
<p>​    如果不规定这些账户在叶子节点的顺序，那么构建出来的Merkle tree不是唯一的。系统中有很多的全节点，每个    全节点按照自己的某个顺序，构建一颗Merkle tree，最后构建出来的Merkle tree是不一样的。比特币中不也是不    排序吗？为什么比特币中就没有这个问题？</p>
<p>​    比特币中每个结点收到的交易顺序也是不一样的，所以理论上说，这样构建的Merkle tree也是不一样的，但是比    特币中的Merkle tree最终是获得记账权的结点说了算。</p>
<p>​    如果以太坊也这么做的话，需要把账户的状态发布到区块里（也就是每个全节点决定怎么把账户组织成一个Merkle tree），但是你是发布的账户的状态，不是交易的状态，差了好几个数量级。</p>
<p>如果使用排序的Merkle tree呢？</p>
<p>如果你新增一个账户怎么办，这个账户地址生成的时候是随机的，可能是在中间，那么后面的这些账户的结构都得变。其实可以这样：你产生一个新账户，其他人其实是没有必要知道的，当你产生交互的时候或者别人往里面转账别人才需要知道，当产生交易需要把这个账户加入到数据结构中，问题在于，这个代价有多大？如果你用哈希表的话，代价是常量级的，如果直接使用账户的哈希，这个代价可能得重构这个数据结构。</p>
</blockquote>
<p>以太坊采用的做法：</p>
<p>首先介绍trie（中文叫做字典树）的数据结构。</p>
<p><img src="/2020/10/04/%E5%8C%BA%E5%9D%97%E9%93%BE/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E7%8A%B6%E6%80%81%E6%A0%91/QQ%E6%88%AA%E5%9B%BE20200928200145.png"></p>
<p>这个结构的特点：</p>
<blockquote>
<p>①在trie中，每个节点的分支数目，取决于这个key值里每个元素得取值范围，这个例子中，每个结点得分支个数最多是26个加上一个结束标志位，表示这个单词到这是不是就结束了。</p>
<p>②trie的查找效率，取决于这个key的长度。</p>
<p>③如果使用哈希表来存储这个key-value对，从理论上说，是有可能出现哈希碰撞（两个地址不一样，但是它的内容碰巧一样）的，但是trie是如果两个的地址不一样，最后肯定映射到树中的不同分支，所以trie不会出现碰撞</p>
<p>④我们前面讲的Merkle tree，如果你不排序，一个问题是，你的账户插入到Merkle tree中的顺序不一样 ，Merkle tree的结构也不一样，trie中只要给定一组输入，这个输入不变，最后插入这个trie当中是一样的。</p>
<p>⑤每次发布一个区块，系统中的绝大多数状态是不变的，只有个别受到影响的状态才会变，所以更新操作的局部性很重要，要想访问genesis，只要访问对应的分支即可，更新的局部性也是很好的</p>
</blockquote>
<p>但是trie也有缺点：只有一个分支的情况很浪费内存，如果能把一个分支的分支合并起来，就能够提高存储的开销，同时提高查找和更新的开销，这就引入了我们的Patricia tree（trie）[经过路径压缩的前缀树]，如果经过路径压缩，上例就变成了下图：</p>
<p><img src="/2020/10/04/%E5%8C%BA%E5%9D%97%E9%93%BE/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E7%8A%B6%E6%80%81%E6%A0%91/QQ%E6%88%AA%E5%9B%BE20200928202332.png"></p>
<p>对于Patricia tree来说，如果你需要添加结点，原来压缩的结点可能会需要扩展开来，路径压缩在什么情况下比较好？</p>
<blockquote>
<p>树中插入的这些键值的分布如果是比较稀疏的情况下。比如上图中的，每个单词都很长，但是总共没有多少个单词的时候。</p>
<p>例如：下图的三个单词插入一个普通的tria中，效率就变得特别低</p>
<p><img src="/2020/10/04/%E5%8C%BA%E5%9D%97%E9%93%BE/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E7%8A%B6%E6%80%81%E6%A0%91/QQ%E6%88%AA%E5%9B%BE20201003181750.png"></p>
<p>如果用Patricia tree，如下图</p>
<p><img src="/2020/10/04/%E5%8C%BA%E5%9D%97%E9%93%BE/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E7%8A%B6%E6%80%81%E6%A0%91/QQ%E6%88%AA%E5%9B%BE20201003181926.png"></p>
</blockquote>
<p>在以太坊中是怎么样的？</p>
<p>我们在前面讲过，地址表示成40个16进制的数，所以这个分叉数目，有时候管他叫做branching factor（17 == 16个[0 - f] 加上一个结束标志位），比特币和以太坊的地址是不通用的，两个地址的格式、长度都是不一样的，有一点是一样的，以太坊中的地址，也是公钥经过转化得来的（公钥取哈希，截一段，前面不要，只要后面的一部分）</p>
<p>那么我们这个应用场景（以太坊）中键值是否是稀疏的呢？</p>
<blockquote>
<p>键值是地址，160位，总共的地址空间有2^160，以太坊中全世界的账户数目加在一起也远远没有这么大，所以以太坊的账户是非常非常稀疏的。</p>
</blockquote>
<p>为什么不把账户地址缩短一点？这样访问效率还快，也没必要那么稀疏了</p>
<blockquote>
<p>更大地避免哈希碰撞，这是一个去中心化的系统防止账户冲突的唯一办法。</p>
</blockquote>
<h2 id="MPT"><a href="#MPT" class="headerlink" title="MPT"></a>MPT</h2><p>Merkle Patricia tree</p>
<p>和Patricia tree有什么区别？</p>
<blockquote>
<p>把普通指针换成了哈希指针，所有的账户组织成一个Patricia tree，用路劲压缩提高效率，然后把普通指针换成哈希指针，所以就能计算出一个根哈希值，存放在block header里。比特币有一个根哈希值（这个区块里所有交易组成的根哈希值），以太坊中有三个，这里讲的是状态树。</p>
</blockquote>
<p>这个根哈希值有什么用？</p>
<blockquote>
<p>①防止篡改，只要根哈希值不变，整棵树的任何部分都没有办法被篡改。</p>
<p>②Merkle Proof，这棵树能证明什么？能证明每个账户的余额：这个账户所在的分支，作为Merkle Proof，发给轻结点，轻结点就可以验证账户上有多少钱。</p>
<p>③能不能证明一个账户是不存在的？你想给一个账户转账之前，你想验证一下节点里，有没有这个账户信息，证明方法和sorted Merkle tree类似，如果存在是存在什么样的分支里，把这个分支作为Merkle tree发出去，可以证明它是不存在的。</p>
</blockquote>
<p>以太坊中用到的还不是原生的MPT，以太坊中使用的是Modified MPT：</p>
<p><img src="/2020/10/04/%E5%8C%BA%E5%9D%97%E9%93%BE/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E7%8A%B6%E6%80%81%E6%A0%91/QQ%E6%88%AA%E5%9B%BE20201003184519.png"></p>
<p>根节点取得的根哈希值KECCAK256是要写在块头里的，这里的指针都是哈希指针。</p>
<p>每次发布一个新的区块的时候，这个状态树中有一些结点的值会发生变化，这些改变不是在原地改的，而是新建一些分支，原来的状态其实是保留下来的：</p>
<p>我们可以看到，虽然每个区块都有一个状态树，但是这两棵树的大部分节点，是共享的，只有那些发生改变的节点，是需要新建一个分支的，这个例子中合约账户发生了变化（因为他有code，还有存储），合约账户的存储也是用MPT的形式保存下来的，这个存储其实也是一个key-value，维护的是从变量到这个变量取值的映射，所以以太坊中的结构是一个大的MPT，包含很多小的MPT（每个合约账户的存储都是一棵小的MPT） </p>
<p><img src="/2020/10/04/%E5%8C%BA%E5%9D%97%E9%93%BE/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E7%8A%B6%E6%80%81%E6%A0%91/QQ%E6%88%AA%E5%9B%BE20201003185717.png"></p>
<p>这个例子中，nonce、balance发生了变化，code不变，所以Codehash指向原来树中的节点，存储中大部分结点也是没有变化，只有一个节点发生了变化，整数变量从29变为了45，所以新建了一个分支。</p>
<p>所以，系统中的全节点维护的不是一棵MPT，而是每次出现一个区块，都要新建一个MPT，只不过这些状态树中大部分节点是共享的，只有少数发生变化的节点是需要新建分支的，那么，为什么要保留历史状态？（为什么不在原地直接改了）</p>
<blockquote>
<p>系统中可能会出现分叉，临时性的分叉实际上是很普遍的，以太坊把出块时间降到十几秒之后，临时性的分叉是常态。</p>
<p><img src="/2020/10/04/%E5%8C%BA%E5%9D%97%E9%93%BE/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E7%8A%B6%E6%80%81%E6%A0%91/QQ%E6%88%AA%E5%9B%BE20201003190631.png"></p>
<p>回滚的话，就需要维护这些历史记录，不是为了证明我以前有多少钱，而是因为当前这个交易有可能要undo，</p>
<p>比特币中简单的转账交易是很容易的，以太坊中为什么不行？</p>
<p>以太坊中有智能合约，以太坊如果不保存原来的状态，智能合约执行完成之后，你想要roll back，这是不可能的。</p>
</blockquote>
<p>以太坊中代码的数据结构：</p>
<p>block header：</p>
<p><img src="/2020/10/04/%E5%8C%BA%E5%9D%97%E9%93%BE/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E7%8A%B6%E6%80%81%E6%A0%91/QQ%E6%88%AA%E5%9B%BE20201003191125.png"></p>
<p>ParentHash：前一个区块块头的哈希值</p>
<p>uncleHash：叔父区块的哈希值（ghost协议中会提到）[uncle可能回避parent大很多辈分]</p>
<p>CoinBase：挖出这个区块的矿工的地址</p>
<p>Root：状态数的根哈希</p>
<p>TxHash：交易树的根哈希值</p>
<p>ReceiptHash：收据树的根哈希值</p>
<p>Bloom：和收据树相关，提供一种高效的查询，符合某种条件的交易的执行结果</p>
<p>Difficulty：挖矿的难度，会根据需要调整</p>
<p>GasLimit、GasUsed：和汽油费相关，有点类似比特币中的交易费</p>
<p>Time：这个区块大致的产生时间</p>
<p>MixDigest、Nonce：和挖矿过程相关，Nonce：类似于比特币中的随机数；MixDigest是从Nonce通过一些计算出来的哈希值。</p>
<p>区块的结构：</p>
<p><img src="/2020/10/04/%E5%8C%BA%E5%9D%97%E9%93%BE/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E7%8A%B6%E6%80%81%E6%A0%91/QQ%E6%88%AA%E5%9B%BE20201003191918.png"> </p>
<p>header：指向block header的指针</p>
<p>uncles：指向叔父区块block header的指针（数组类型）</p>
<p>transactions：交易列表</p>
<p>区块真正在网上发布的信息：</p>
<p><img src="/2020/10/04/%E5%8C%BA%E5%9D%97%E9%93%BE/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E7%8A%B6%E6%80%81%E6%A0%91/QQ%E6%88%AA%E5%9B%BE20201003192042.png"></p>
<p>状态树中保存的是key-value pair，key就是地址， 我们前面所讲的都是key（地址的管理方式），那么这个value（账户的状态）呢？</p>
<blockquote>
<p>实际上是要经过一个序列化的过程：RLP（Recursive Length Prefix），极简主义，和protocal buffer相比；它只支持一种类型：nested array of bytes，说白了就是字节数组，以太坊的其他所有类型（整数、哈希表），最后都得变成nested array of bytes，所以你要实现一个RLP，比较容易。</p>
</blockquote>
]]></content>
      <categories>
        <category>区块链</category>
      </categories>
      <tags>
        <tag>区块链</tag>
      </tags>
  </entry>
  <entry>
    <title>ETH二---账户</title>
    <url>/2020/10/04/%E5%8C%BA%E5%9D%97%E9%93%BE/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E8%B4%A6%E6%88%B7/</url>
    <content><![CDATA[<h1 id="以太坊的账户"><a href="#以太坊的账户" class="headerlink" title="以太坊的账户"></a>以太坊的账户</h1><p>比特币是基于交易的账本模式，这种模式下，并没有显式地记录每个账户有多少钱，这种模式的好处是，隐私保护得比较好，你有多少钱，可能连你自己都说不清楚，别人就更搞不明白了。</p>
<blockquote>
<p>别人转到你账上的钱，你一定要花出去，比如别人转给你10个，你花了3个比特币，你必须把剩余的7个比特币再转回给自己的另外一个账户，要不然这7个比特币全都会被当成tx fee给矿工了</p>
</blockquote>
<a id="more"></a>

<p>以太坊设计了一个基于账户的交易模型account-based ledger：系统上显式地记录账户上有多少个以太币</p>
<p><img src="/2020/10/04/%E5%8C%BA%E5%9D%97%E9%93%BE/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E8%B4%A6%E6%88%B7/QQ%E6%88%AA%E5%9B%BE20200925195000.png"></p>
<p>上述，也不需要把币转给自己，剩下的ETH放在自己的账户上就可以了，上面的指针也不需要了</p>
<p><img src="/2020/10/04/%E5%8C%BA%E5%9D%97%E9%93%BE/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E8%B4%A6%E6%88%B7/QQ%E6%88%AA%E5%9B%BE20200925195122.png"></p>
<p>这样做的一个好处是什么？</p>
<blockquote>
<p>以太坊的这种模式，对double spending attack有天然的防御作用：花钱就扣余额，你要花两次，我就扣两次。</p>
<p>但是，如果有人篡改余额怎么办？</p>
<p>你消费的时候不需要指出你的余额，而是从全节点中维护的一个状态树中的一个状态<code>balance</code>查找（后面会说明）,这个<code>balance</code>无法篡改</p>
<p>但是还有一种重放攻击（replay attack），A给B转账，B有恶意，将A给B转账的交易重放了一次，这样不就可以扣除A的两次余额吗？</p>
<p>防止这种攻击的做法其实有多个：可以增加一个nonce（记录A转账（消费）的次数），如果有人想重放这个交易，就会发现，这个交易已经被执行过了，就不会再执行一遍了。</p>
</blockquote>
<p>以太坊中有两类账户，一类叫做外部账户</p>
<p>①externally owned account，其中有两个属性balance 和nonce </p>
<p>②smart contract account，有balance nonce、code（代码）以及storage（相关的状态），合约账户不是通过公私钥对来管理的，不是你有这个合约账户的公私钥就有这个账户的控制权，一个合约可以调用另外一个合约（所以它同样需要一个nonce来记录一下合约调用的次数），但是智能合约账户不能主动发起一个交易（所有的交易只能由外部账户发起，外部账户发起了一个交易，如果调用了一个合约账户，这个合约账户可以发送一个message调用一个合约账户）</p>
<p>合约账户怎么被调用？你创建合约的时候，会返回一个地址，知道这个合约的地址就可以调用这个合约，状态（storage）会发生变化，代码不变。</p>
<p>为什么要创建这样一种新的模型？</p>
<blockquote>
<p>比特币基于交易的账户的好处：隐私的保护比较好一点，以太坊注重的是智能合约，要求合约参与者要有比较稳定的身份。</p>
</blockquote>
<p>现在有人提出的一些智能合约的衍生品：financial derivative，比如说你投钱投给一个合约账户，合约账户的地址变了，你找不到了就比较麻烦，以太坊在创建的时候，考虑到了已有的一些模型的利弊得失，最终没有采用比特币中基于交易的账户模型。</p>
]]></content>
      <categories>
        <category>区块链</category>
      </categories>
      <tags>
        <tag>区块链</tag>
      </tags>
  </entry>
  <entry>
    <title>BTC九---分叉</title>
    <url>/2020/09/09/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%88%86%E5%8F%89/</url>
    <content><![CDATA[<h1 id="分叉"><a href="#分叉" class="headerlink" title="分叉"></a>分叉</h1><p>fork:原来是一条链，现在是两条链形成了分叉。有两种情况：</p>
<p>①如果同时有两个结点发布了区块，这时候就会形成分叉：state fork，由于对比特币这个区块链当前的区块状态有意见分歧而导致的分叉，forking attack也属于state fork，只不过分叉攻击这个意见分歧是故意造成的，所以有时候我们管这个叫deliberate fork。</p>
<p>②比特币的协议发生了改变，要修改比特币的协议，需要软件升级，在一个去中心化的系统里，在升级软件的时候，没有办法保证所有的结点同时都升级软件，我们假设大部分结点升级了软件，少数结点因为种种原因没有升级，有可能还没有来的及升级，也可能是不同意这个协议的修改，这种分叉叫做protocol fork，因为对比特币的协议产生了分歧，因为使用不同的协议造成了分叉。</p>
<a id="more"></a>

<blockquote>
<p>可以根据对协议修改的内容的不同，分为硬分叉（hard fork）和软分叉（soft fork）</p>
</blockquote>
<p>什么是硬分叉？什么是软分叉？</p>
<h2 id="hard-fork"><a href="#hard-fork" class="headerlink" title="hard fork"></a>hard fork</h2><p>出现硬分叉的情况，如果对比特币协议增加新的特性，有一些new feature，这些没有升级软件的那些旧的节点，他是不认可这些新特性的，他认为这些new feature是不合法的。这个时候就属于我们对比特币协议的内容产生了意见分歧，就会导致分叉。一个例子就是：比特币中的区块大小限制（block size limit）。</p>
<blockquote>
<p>比特币规定每个区块是1M字节，有些人认为1M这个限制太小了，增加了比特币的延迟。</p>
<p>一个交易差不多可以认为是250个字节，所以1000000字节大概是4000个交易左右，平均十分钟一个区块，算下来大概是每秒钟七笔交易</p>
<p><img src="/2020/09/09/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%88%86%E5%8F%89/QQ%E6%88%AA%E5%9B%BE20200907211038.png"></p>
<p>我们用信用卡处理交易和这个完全不是一个数量级的，很多电商网站很多都不止这些，所以有的人认为这个区块太小了，限制了比特币的throw put（不知道老师是不是说的这个），同时也增加了延迟，因为你区块就只能装这么多区块，如果交易太多了的话，那可能有些交易，就得等到下一个区块才能被发布，平均要等十分钟</p>
</blockquote>
<p>我们假设有人发布了软件更新，把这个block size limit从1M增加到了4M（大多数结点更新了这个软件，少数节点没有更新【这里所说的节点数目不是按照账户的数目来算的，是按照算力的多少来算的】），这个时候系统运行起来会有什么结果？</p>
<p><img src="/2020/09/09/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%88%86%E5%8F%89/QQ%E6%88%AA%E5%9B%BE20200907212426.png"></p>
<p>备注：图中的解释有错误，应该是新产生的区块，旧结点不认可</p>
<p><img src="/2020/09/09/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%88%86%E5%8F%89/QQ%E6%88%AA%E5%9B%BE20200907212813.png"></p>
<p>备注：图中的“就”为“旧”</p>
<p>只要这些旧结点不更新软件，分叉就不会消失，这就是为什么管他叫硬分叉（hard fork）。</p>
<p>比特币社区中，有些人是比较保守的，像这种block size limit这种new feature，有些人真的是不会同意，而且，区块的大小不是越大越好（详情看比特币网络）。</p>
<p>如果存在了硬分叉，那么下面的那一条链的出块奖励还有吗？</p>
<blockquote>
<p>是有的（在各自的链上是承认的），会造成社区的分裂，如果一直存在下去，就会分家了，相当于变成了两种币，原来没有分裂的币，应该变成上下两条链都认可。</p>
<p><img src="/2020/09/09/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%88%86%E5%8F%89/QQ%E6%88%AA%E5%9B%BE20200907214138.png"></p>
<p>后来有了一个措施：在各自的链上加上一个chain ID</p>
</blockquote>
<h2 id="soft-fork"><a href="#soft-fork" class="headerlink" title="soft fork"></a>soft fork</h2><p>软分叉出现的情况？如果我们对比特币协议加一些限制。加这个限制之后，原来合法的交易或者是合法的区块，在新的协议中，有可能变得不是合法了，这就引起软分叉。</p>
<p>举例：</p>
<p>如果有人发布了软件更新，block size limit缩小了，由1M变成0.5M（实际上不会这样做，因为1M已经是比较小的了）</p>
<p><img src="/2020/09/09/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%88%86%E5%8F%89/QQ%E6%88%AA%E5%9B%BE20200909193415.png"></p>
<p>实际当中可能出现软分叉的情况</p>
<p>①给某些目前协议中没有规定的域增加一些新的含义，赋予他们一些新的规则：coinBase域，每个发布的区块里可以有一个铸币交易，coinBase可以有个特别的用途（作为extra nonce 拿出8bytes），其实coinBase不止8个字节，那其他字节干嘛用呢？有人就建议，把他作为UTXO集合的根哈希值，目前这个集合只是全节点自己在内存中维护这样一个集合，主要是为了快速查找能够交易是不是double spending，但是这个集合的内容并没有写到区块链，这个和我们说的Merkle proof不太一样。</p>
<p>如果你要证明某个账户上有多少钱，如果你是全节点的话，可以算一下，就是看一下A这个账户在这个UTXO里对应的输出上面一共收到多少个币，就是A账户上有多少钱。</p>
<p>有很多区块链钱包（手机上的app），他不可能在手机上维护一个全结点，他需要知道账户的余额，需要询问其他的全节点，那么全节点返回一个结果，你怎么知道他是不是对的？</p>
<blockquote>
<p>你现在是证不出来的，你自己如果没有维护一个UTXO集合，是没有办法用Merkle proof证出来的，所以有人就提议：</p>
<p>把UTXO集合当中的内容也组织成一条Merkle tree，这个Merkle tree有一个根哈希值，这个哈希值写在coinBase中，因为你block header没有办法再改了（block header动静太大了），coinBase中的内容在网上传递的时候，最终会传递到block header中，这样的话，你就可以用Merkle proof证出来</p>
</blockquote>
<p>有人发布软件更新，规定coinBase域要这样写，这样是硬分叉还是软分叉？软分叉，因为新节点发布的区块，旧结点认为是合法的，因为旧结点不管你coinBase什么内容，都认为是合法的，但是旧结点发布的区块，新节点可能是不认的。</p>
<p>比特币历史上，一个比较著名的软分叉的例子，是P2SH（Pay to Script Hash），这个在最初的比特币版本里是没有的，是后来通过软分叉加进去的：</p>
<p>你支付的时候，不是付给一个Public Key的哈希，而是付给一个赎回脚本的哈希，这是新节点要做的；而对于旧结点，他不理解P2SH的特性，他只会做第一阶段的验证，所以，旧结点认为合法的交易，新节点可能认为是非法的</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>soft fork：只要系统中有半数以上的结点更新了软件，就不会出现永久的分叉，可能会出现临时的分叉。</p>
<p>hard fork：必须是所有的节点都要更新软件，系统才不会出现永久性的分叉，如果有小部分节点不愿意更新，那么这个系统就会分成两条链。</p>
]]></content>
      <categories>
        <category>区块链</category>
      </categories>
      <tags>
        <tag>区块链</tag>
      </tags>
  </entry>
  <entry>
    <title>BTC十二---思考</title>
    <url>/2020/10/04/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%80%9D%E8%80%83/</url>
    <content><![CDATA[<h1 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h1><h2 id="哈希指针"><a href="#哈希指针" class="headerlink" title="哈希指针"></a>哈希指针</h2><p>比特币系统在设计的时候，很多地方都使用到了哈希指针，比如区块的块头，就包括了前一个区块的指针，指针保存的是本地内存的地址，那么只是在本地计算机上才有意义，发布到别的计算机上就没有意义了，那么哈希指针是怎么通过网络进行传输的呢？</p>
<a id="more"></a>

<blockquote>
<p>所谓的哈希指针，只是一种形象的说法，实际系统中使用的时候，只有哈希，没有指针。</p>
<p><img src="/2020/10/04/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%80%9D%E8%80%83/QQ%E6%88%AA%E5%9B%BE20200923185402.png"></p>
<p>那么怎么找到前一个区块的内容呢？</p>
<p>全节点一般是把这个区块存储在一个（key，value）的数据库（这里面的key就是前一个区块的哈希，value就是区块的内容）里面，常用的数据库是levelDB。</p>
<p>所谓的区块链的链表结构，实际上是在levelDB里用哈希值串起来的，只要你掌握最后一个区块的哈希值，就可以把最后一个区块中的内容取出来，然后通过这个区块中的上一个区块的哈希值，找到前一个区块的内容，这样一步一步往前找，就可以把所有的区块都找出来。所以实际中，只有哈希，没有指针，或者可以认为哈希值就是指针。哈希指针的性质，保证了区块链中的内容是不可篡改的。</p>
</blockquote>
<h2 id="区块恋"><a href="#区块恋" class="headerlink" title="区块恋"></a>区块恋</h2><p>据说17年七夕的时候，有的情侣，两个人合在一起买比特币，然后把私钥从中间截断，分成两部分，每人保存其中的一段，将来如果两个人继续好下去的话，那么两段私钥合在一起就能把钱取出来，如果两个人分手了，比特币就被永久地锁在了区块链上。</p>
<p>按照这种逻辑，如果推到n个人，如果有四个合伙人，就应该把私钥切成四份，每个人掌握其中的一份，需要用的时候，四个人的私钥合在一起才能用，这样有什么问题？</p>
<blockquote>
<p>①任何一个人把私钥丢了，这个钱就取不出来了。</p>
<p>②这种截断私钥的做法，会降低比特币账户的安全性：比特币系统中账户的安全性是和每个账户私钥的长度是相关的，256位的私钥，尽管你把世界上所有的电脑集中起来破解，也是不可能成功的，但是你从中截断，128位的长度，他的可能性就远远小于2^256次方个，破解的难度变得容易很多了，如果其中三个合伙人，瞒着第四个合伙人要把钱取出来，那么他只要尝试2^64可能性就可以了。</p>
</blockquote>
<p>说明，对于多个人的共享账户，不要采用截断私钥的做法，那怎么办？</p>
<blockquote>
<p>使用多重签名，多重签名中的每一个签名都是独立产生的，而不是把一个私钥拆成若干个私钥，而且多重签名还提供了一些别的灵活性：比如n个人中，任意给出m个签名就可以了。</p>
</blockquote>
<p>区块恋还有另一个问题，如果这两个人分手了，那么他们购买的比特币就会永久地保存在UTXO里，这对全节点是不友好的。</p>
<p>还有一些别的原因，钱变成’死钱’，早期有的人就是挖矿挖着玩，这种情况就造成了大量的私钥的丢失，造成了UTXO集合的膨胀。</p>
<h2 id="分布式共识"><a href="#分布式共识" class="headerlink" title="分布式共识"></a>分布式共识</h2><p>关于分布式共识，学术界有很多不可能的结论，从理论上证明，分布式系统当中取得共识是不可能的，既然从理论上证明是不可能的，实际当中，又怎么变成可能了？</p>
<p><img src="/2020/10/04/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%80%9D%E8%80%83/QQ%E6%88%AA%E5%9B%BE20200923191841.png"></p>
<blockquote>
<p>严格意义上来说，比特币并没有取得真正意义上的共识，因为取得的共识，随时都可能被推翻。</p>
<p>比如出现了分叉攻击，本来你以为已经达成了某一个共识，分叉攻击之后，系统会回滚到前一个状态，从理论上来说，甚至可能回滚到创世纪块，按照分布式系统理论的要求，共识一旦达成之后，就不应该再改了，所以从这个意义上看，比特币系统并没有绕过分布式系统那些不可能的结论，因为他根本没有达到根本意义上的共识</p>
</blockquote>
<p>理论和实际往往是有距离的，很多理论上的不可能结论，对于实体来说是并不适用的，这个不可能结论只是对某种固定的模型下是不可能的。</p>
<p>你怎么判断远程的一台服务器是不是死机了？（连不上，但是是不是真的死机了？）</p>
<blockquote>
<p>分布式系统的理论已经证明了，在异步（通讯传输的延迟是没有上限的：我发一个消息给你，你什么时候能收到，谁也不知道）的环境中，不能区分远程的服务器，到底是死机了，还是运行缓慢。</p>
<p>但是也并不是没有办法，打个电话给管理员，让他看看是否死机了就行了，所以这在理论上不可能的事请，又变成了可能。</p>
<p>如果实际上，每次都给管理员打电话，也比较复杂，所以有一种做法是给服务器加一根电话线（十几年前），如果你发现连不上，就不用internet那根线连接，就用电话线连接，一般来说不会同时出现拥堵，所以你发现用电话线，还是连不上，那就是服务器死机了。</p>
</blockquote>
<p>说明：理论上很多不可能的结论，只是在某些特定的模型下，现实中，把模型改一改，所谓的理论上的结论也就可能不成立了。</p>
<h2 id="比特币的稀缺性"><a href="#比特币的稀缺性" class="headerlink" title="比特币的稀缺性"></a>比特币的稀缺性</h2><p>挖矿的收益，要大于挖矿的开销，那就是有利可图的，所以，要吸引大家来挖矿，要么增加预期收益，要么降低开销。</p>
<p>比特币是如何做到这一点的呢？</p>
<blockquote>
<p>早期的挖矿难度比较低很容易就可以挖到，另一方面，早期的出块奖励也非常的高。</p>
</blockquote>
<p>有人认为比特的设计是十分巧妙的，比特币的总量是恒定的，越到后面越难挖，所以到了后面大家都会抢着去挖，有人认为这是比特币获得成功的一个重要原因，其实，这种总量固定的东西，是不适合作为货币的。有些新型的货币，甚至要自带一种通胀的功能，每年会自动把货币的发行量提高一个比例。</p>
<p>稀缺的东西，是不适合作为货币的，一个好的货币实际上是要有通货膨胀的功能的，如果这个东西的总量是定死的，他是不适合作为货币的（所以现在都不使用黄金作为货币：每年黄金产量增加的速度远远敢不上社会新创造财富的速度，如果我们使用黄金作为货币，这会导致黄金越来越值钱，如果祖上已经有黄金，就只需要坐等升值就行了，国内的房地产就是这种情况，一个健康向上的社会，是不应该出现这种情况的）。</p>
<h2 id="量子计算"><a href="#量子计算" class="headerlink" title="量子计算"></a>量子计算</h2><p>比特币这种加密货币，是建立在密码学的基础上的，将来量子计算发展起来之后，这些加密货币会不会变得不安全了？</p>
<blockquote>
<p>传说中的量子计算，可以破解现有的各种加密算法。但是，这种担心是没有必要的</p>
<p>①量子计算技术离使用还有很长一段距离，如果量子计算技术使用，首当其冲的是传统金融业，网上进行的很多金融活动，都会变得不安全，与其担心量子计算对比特币的冲击，还不如担心量子计算对传统金融的冲击。将来还会有量子加密算法</p>
<p>②比特币当中并没有把账户的公钥直接暴露出来，而是用公钥取哈希之后得到一个地址，非对称加密中，私钥是可以推出公钥的，所以只要保管好私钥，公钥即使丢了也没有关系。公钥显然不能推出私钥。假如量子计算发达了，能够从公钥当中推出私钥，那怎么办？</p>
<p>比特币在设计的时候，又加了一层保护，没有用公钥本身，而是用公钥的哈希，所以有人想偷你账户上的钱的话，</p>
<p>首先是要用地址推导出你的公钥，相当于将公钥的哈希值逆运算，推导出真实的公钥，而这一点，即使是用量子计算机，也是没有办法完成的</p>
</blockquote>
<p>加密是要保证数据的完整性的，为了解密之后得到的明文不丢失信息</p>
<p>而取哈希是可以丢失信息的，哈希算法是不可逆的过程。</p>
<p>比特币使用的哈希算法是SHA-256，不管多大的输入，最后取哈希都变成256位的，这肯定会造成信息的丢失，而且不可逆，如果不是这样的话，变成了超级的压缩算法，这是不可行的。</p>
<p>比特币中，如果只需要收钱的话，只提供一个公钥的哈希就可以了，将来你要取钱的时候，再提供公钥，和私钥产生的签名。假设有一个坏人，在网上监听到了你取钱的交易，知道了你的公钥，他要偷你的钱需要怎么做？</p>
<blockquote>
<p>他要通过你的公钥，实时的破解你的私钥，然后在产生一个把钱转到他的账户上去的交易，即时这个坏人拥有量子计算技术，也很难在几分钟内就把你的私钥破解了，而且他发布的这个交易还要抢在你这个交易的前面，一旦你把账上的钱都转走了，他这个交易就没用了。</p>
</blockquote>
<p>所以从安全性的角度来看，比特币的一个地址，一旦用过之后，就不要再用了。</p>
]]></content>
      <categories>
        <category>区块链</category>
      </categories>
      <tags>
        <tag>区块链</tag>
      </tags>
  </entry>
  <entry>
    <title>BTC四---实现</title>
    <url>/2020/08/30/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><h2 id="transaction-based-ledger"><a href="#transaction-based-ledger" class="headerlink" title="transaction-based ledger"></a>transaction-based ledger</h2><p>BTC(比特币):基于交易的账本模式（transaction-based ledger），每个区块记录交易信息，但是系统中没有统一的记录，比如需要知道某个账户有多少钱，这个还需要交易记录来推算</p>
<p>比特币的全节点要维护一个UTXO的数据结构</p>
<a id="more"></a>

<p>UTXO:Unspent Transaction Output,还没有被花出去的交易的输出，区块链中有很多交易，有些交易的输出可能被花掉了，有些还没有被花掉，没有被花掉的交易的输出的集合叫做UTXO</p>
<p>UTXO中的每个元素要给出产生这个输出的交易的hash值，以及他在这个交易里是第几个输出，就可以定位到这个UTXO中的输出，那么这个UTXO集合的作用是什么？为什么要维护这样一个数据结构</p>
<p>作用：防范double spending attack，所以全节点要在内存中维护UTXO数据结构，以便快速检测double spending attack，</p>
<p>随着交易的发布，每个交易要消耗UTXO中的输出，同时也会产生一些新的输出</p>
<p>每个交易所有输入的金额，要等于所有输出的金额：total inputs = total outputs</p>
<p>发布区块的那个结点为什么要把你的交易打包在区块里？这样做对她有什么好处吗？</p>
<p>如果只有出块奖励，那么自私的结点就只会打包他自己的交易，同时也节省带宽</p>
<p>所以比特币系统设定了第二个激励机制：交易费（transaction fee），你把我的交易打包在区块里，我给你点小费，所以就会出现total inputs &gt;= total outputs的情况，多的比特币充当了小费</p>
<p><img src="/2020/08/30/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%AE%9E%E7%8E%B0/QQ%E6%88%AA%E5%9B%BE20200817210059.png"></p>
<p>目前矿工去争取记账权，主要还是为了得到出块奖励，但是因为21个区块都会减少出块奖励</p>
<p>比特币系统中差不多10分钟会创建一个区块，计算下来差不多每四年就会减半（出块奖励）</p>
<h2 id="区块的例子"><a href="#区块的例子" class="headerlink" title="区块的例子"></a>区块的例子</h2><p>account-based ledger</p>
<p>以太坊就是这种模式，在这种模式总，系统显式的记录每个账户上有多少个币，比特币的隐私保护就比较好一些</p>
<p><img src="/2020/08/30/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%AE%9E%E7%8E%B0/image-20200817210819638.png"></p>
<p>Height:是区块的序号，Difficulty：挖矿的难度（每隔2016个区块要调整这个难度，保持出块时间在10分钟左右）</p>
<p><img src="/2020/08/30/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%AE%9E%E7%8E%B0/QQ%E6%88%AA%E5%9B%BE20200817211158.png"></p>
<p>注意：计算hash值都是计算block header的哈希值，不包含block body的哈希值</p>
<p>所谓的挖矿，就是不断地调整随机数nonce，使得整个block header的哈希值小于等于给定的目标阈值，这个目标阈值表示成16进制就是前面有一长串的0，所以凡是符合难度要求的区块，它的块头的哈希值，算出来都是要有一长串的0</p>
<p><img src="/2020/08/30/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%AE%9E%E7%8E%B0/QQ%E6%88%AA%E5%9B%BE20200817211615.png"></p>
<p><img src="/2020/08/30/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%AE%9E%E7%8E%B0/QQ%E6%88%AA%E5%9B%BE20200817211913.png"></p>
<p><img src="/2020/08/30/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%AE%9E%E7%8E%B0/QQ%E6%88%AA%E5%9B%BE20200817212243.png"></p>
<p>每个发布的区块里都包含一个特殊的铸币交易</p>
<p><img src="/2020/08/30/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%AE%9E%E7%8E%B0/QQ%E6%88%AA%E5%9B%BE20200817212744.png"></p>
<p>这个对Merkle tree的根哈希值有什么影响吗</p>
<p><img src="/2020/08/30/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%AE%9E%E7%8E%B0/QQ%E6%88%AA%E5%9B%BE20200817213102.png"></p>
<p>coinbase中的前八个字节当作extra nonce来用nonce从2^32-&gt;2^96</p>
<p>所以真正挖矿的时候是有两层循环的，外层循环调整coinbase域的extra nonce ，算出block header中的根哈希值之后，内层循环在调整header里的nonce</p>
<p><img src="/2020/08/30/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%AE%9E%E7%8E%B0/QQ%E6%88%AA%E5%9B%BE20200817213639.png"></p>
<p><img src="/2020/08/30/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%AE%9E%E7%8E%B0/QQ%E6%88%AA%E5%9B%BE20200817213948.png"></p>
<h2 id="概率分析"><a href="#概率分析" class="headerlink" title="概率分析"></a>概率分析</h2><p>每次尝试nonce可以看作是Bernoulli trial：a random experiment with binary outcome</p>
<p>挖矿，每次尝试nonce，成功的概率是微乎其微的，大概率是不行的，如果我们做很多的Bernoulli trial，每个实验都是随机的，这些Bernoulli trial就构成了Bernoulli process：a sequence of independent Bernoulli trials，Bernoulli trial的一个性质是无记忆性：memory less，你做大量的实验，前面的结果和后面的结果是没有关系的</p>
<p>实验很多，每次成功的概率很小，多重伯努利可以用Poisson process来近似，我们关心的是，系统中产生下一个区块的时间，这个在概率中可以推导出来出块时间是服从指数分布的exponential distribution</p>
<p>整个系统平均的出块时间是十分钟，这个时间是比特币协议设计出来的</p>
<p>具体到每个矿工，他能够挖到下一个区块的时间，取决于这个矿工的算力占系统算力的百分比，比如说，你的算力占到系统算力的1%，平均下来，系统里每产生一百个区块，其中有一个区块就是你挖矿挖到的，平均你要等1000分钟才能产生一个区块</p>
<p><img src="/2020/08/30/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%AE%9E%E7%8E%B0/QQ%E6%88%AA%E5%9B%BE20200817215856.png"></p>
<p>这个性质有时候也叫：process free，过去的process是不算数的</p>
<p>假设一下，如果有某个puzzle不满足process free，会出现什么情况：算力强的矿工具有不成比例的优势，因为算力强的矿工过去做的工作肯定是多的，比如有两个矿工，一个矿工的算力是另一个的十倍，那么他挖到矿的概率也是另一个的十倍，这样就满足process free，如果不满足，就会大于十倍！其实process free 恰恰是挖矿公平性的保证。</p>
<h2 id="比特币的总量"><a href="#比特币的总量" class="headerlink" title="比特币的总量"></a>比特币的总量</h2><p>挖矿获得的出矿奖励，是比特币长生的唯一途径，然而这个值每四年就会减半，比特币的总量呈现几何趋势</p>
<p>genmetric series</p>
<p><img src="/2020/08/30/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%AE%9E%E7%8E%B0/QQ%E6%88%AA%E5%9B%BE20200819203300.png"></p>
<p>挖矿对维护比特币系统的安全是至关重要的：Bitcoin is secured by mining，只要大部分算力在诚实的结点手里，系统的安全就可以得到保证。出矿奖励随着出块会减半，那么人们的动力是否会减少呢？从过去的几年来看，恰恰是相反的，比特币的价格是飙升的，如果趋于0之后，是不是就没有动力挖矿了呢？还有第二种激励机制：交易费</p>
<p>比特币的安全性的分析，①假设大部分算力是掌握在诚实的矿工手里，我们能得到什么样的安全保证，能不能保证写入区块里的交易都是合法的？如果落在了10%的不诚实的结点手里，这个节点能不能偷币？能不能把别人账上的钱转给自己？不能，因为他无法伪造别人的签名（需要知道别人的私钥）。如果把这个交易硬写道区块链里呢？</p>
<p><img src="/2020/08/30/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%AE%9E%E7%8E%B0/QQ%E6%88%AA%E5%9B%BE20200819204852.png"></p>
<p>②恶意的结点能不能double spending？</p>
<p>如果M-&gt;A存在某种不可逆的效果，那么M-&gt;M’就可以从中获得不当的利益，比如网上购物，M购买了一些商品，然后网站接受比特币支付，M把帐转给这个网站，网站监听到这个交易写入到区块链里了，以为， 支付成功了，所以把商品给了M，M拿到商品之后，又发起了一个交易M-&gt;M’把钱转给自己，然后按照下面这个区块扩展最长合法链，这样上面那个交易就作废了。</p>
<p><img src="/2020/08/30/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%AE%9E%E7%8E%B0/QQ%E6%88%AA%E5%9B%BE20200819205358.png"></p>
<p>如何防范double spending？类似上面这种攻击</p>
<p><img src="/2020/08/30/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%AE%9E%E7%8E%B0/QQ%E6%88%AA%E5%9B%BE20200819210210.png"></p>
<p><img src="/2020/08/30/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%AE%9E%E7%8E%B0/QQ%E6%88%AA%E5%9B%BE20200819210314.png"></p>
<p>区块链是不可篡改的账本：irrevocable ledger，那是不是说凡是写入区块链的内容，永远改不了呢？根据上面的分析可知，这种不可篡改性，只是一种概率上的保证</p>
<p>其实，还有一种zero confirmation，0个确认，这个意思是说，这个转账交易发布出去了，但是还没有被写入区块链里，商家就确认了这个交易，这种在现实生活中还是比较普遍的，</p>
<p>原因：</p>
<p>①比特币协议缺省的设置是：结点接收最先听到的那个交易，两个交易有冲突，最先听到哪个，接收哪个，所以发布一个M-&gt;A,最先听到这个，在zero confirmation的这个位置，诚实的结点有比较大的几率是不会接收M-&gt;M’这个交易的 </p>
<p>②很多购物网站，从你支付成功，到他把货品发给你，是有一定的时间间隔的，如果发现M-&gt;M’这个转账交易没有在最长合法链里，电商就可以选择取消发货。</p>
<p>假设某个有恶意的结点获得了记账权，他还能干什么坏事？</p>
<p> 能不能不把某些合法的交易写道区块链里？这是可以的，但是会少交易费，比特币规定某个区块的大小是有限制的，最多不能超过1M字节，某个节点交易太多，这些交易就只能等到下个区块在发布</p>
<p>selfish mining：在商家等待6个区块的时候，M-&gt;M’先不发布，在私下偷偷的挖矿，但是不发布，等挖矿创建的区块比6个区块多的时候，一下子全部发布，M-&gt;M’这条链就成了最长合法链；正常的情况是，挖到区块，立马发布，要不然就被别人抢了，所以selfish mining有一个前提，恶意的结点的算力要超过诚实的结点的算力，但是是不可能的</p>
<p>selfish mining还有什么目的，上述是分叉攻击的目的，假设我们能不是为了回滚以前的交易，就是为了正常的挖矿，赚取出块奖励，selfish mining有没有什么好处？减少竞争：别人挖了一个，我已经挖了两个，然后直接抛出去两个,让别人做一些无用功。</p>
]]></content>
      <categories>
        <category>区块链</category>
      </categories>
      <tags>
        <tag>区块链</tag>
      </tags>
  </entry>
  <entry>
    <title>BTC十---回顾问答</title>
    <url>/2020/09/14/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%9B%9E%E9%A1%BE%E9%97%AE%E7%AD%94/</url>
    <content><![CDATA[<h1 id="BTC问答回顾"><a href="#BTC问答回顾" class="headerlink" title="BTC问答回顾"></a>BTC问答回顾</h1><p>1.转账交易的时候，如果接收者不在线（你转账给A，但是A那时候没有连接到比特币网络上）怎么办？</p>
<blockquote>
<p> 这个时候不需要接收者在线，转账交易只不过要在区块链上记录一下。</p>
</blockquote>
<p>2.假设某个全节点收到了一个转账交易，有没有可能转账交易中接收者的收款地址是这个结点以前从来没有听说过的？</p>
<blockquote>
<p>可能，比特币系统在创建账户的时候是不需要通知其他人的，在本地产生一个公私钥对就可以了，只有在以后产生的收款地址收到钱的时候，其他结点才知道这个账户的存在。</p>
</blockquote>
<a id="more"></a>

<p>3.如果你账户的私钥丢失了该怎么办？</p>
<blockquote>
<p>其实是没有办法的，这个账户上的钱就变成了死钱，永远取不出来，去中心化的系统大家没有办法给你重置密码。</p>
</blockquote>
<p>有些加密货币的交易所，一般来说，这些交易所都是中心化的机构，那么在交易所办一个账户的时候一般来说是要提供身份证明的，这种情况下，你把你的交易货币保存在交易所里，那么私钥实际上是由交易所来保管的 ，你登陆这个交易所是按照登陆银行差不多的程序（有一个账户名，一个密码），登陆的时候，一般来说还需要二次验证（google 身份验证器），如果私钥丢失是可以在交易所查到的；</p>
<p>有些在线钱包也提供私钥保管的功能，但并不说这些机构为我们自己保管私钥更加安全，目前这些机构仍处于缺乏监管的状态，历史上出现过交易所被黑客攻击的情况，其中最著名的例子就是Mt.Gox的例子，Mt.Gox曾经是世界上最大的交易所，交易量占到了全球的交易量的70%。后来被攻击了，CEO被判刑。</p>
<p>相比来说，冷钱包或者硬钱包更加安全。</p>
<p>4.如果你的私钥泄漏了怎么办？（你发现你的账户上出现了一些可疑的交易）</p>
<blockquote>
<p>这个时候你应该把你账户上的钱，转到另一个安全账户上。（这个也和现实中银行的体验不太一样）</p>
<p>比特币账户创建之后，公私钥对都是没有办法修改的</p>
</blockquote>
<p>5.如果转账的账户地址填错了怎么办？</p>
<blockquote>
<p>没有办法取消以前发布的交易，比特币中转账的交易一旦发布在区块链上就没有办法取消了，它没有提供这种机制取消一个已经发布的交易，如果你知道是谁的地址，可以跟他联系一下</p>
<p>也可能转给不存在的地址（有些地址其实不是公钥的哈希得到的：digital commitment：你想证明某个时间你知道了某个知识，可能只是一个文件取了哈希）</p>
</blockquote>
<p>在Proof of Burn中提到的OP_RETURN后面可以写所有的去哈希的内容，上面的内容没有人管，这是推荐采用的方法，但是有的人不这么干：有人用内容取哈希之后得到的哈希值生成一个看上去像比特币地址的东西，这时候转账给这个假的地址，这样转账的钱就变成了死钱，这种做法，就是牺牲很少一点的比特币，换取往这个区块链里写入这个哈希值的一个机会。后者的做法是不提倡的，因为这样转账交易的输出会永久的保留在UTXO里，对全节点不友好</p>
<p>6.Proof of Burn的机制是怎么执行的，不是说OP_RETURN会无条件地返回错误吗？那这个交易是怎么通过验证的？</p>
<blockquote>
<p>验证时候：是把当前这个交易的输入脚本和这个交易（币的来源）的输出脚本拼接，这个过程是不可以发生错误的，关键在于，OP_RETURN是写在当前交易的输出脚本里的，所以验证当前交易的合法性的时候不会执行当前语句（因为他是输出脚本），有人想花这个钱的时候，才会执行这个输出脚本，因为OP_RETURN永远都返回错误，所以永远都不可能花出去。</p>
</blockquote>
<p>7.会不会有的矿工偷答案？（其他矿工发布了一个nonce，这个矿工没有找到这个nonce，他收到这个区块之后，查一下这个nonce是符合要求的，然后就把他当成自己的nonce发布出去）你怎么知道哪个nonce是属于哪个矿工的？</p>
<blockquote>
<p>发布的区块里，会发布一个coinBase tx，里面会填一个收款地址，谁挖到了矿，就填谁，如果你要抄答案，那么你要把收款人的地址换成自己的地址，而这个地址发生变化的话，coinBase tx的内容就会发生变化，这样会导致这个Merkle tree的根哈希值发生变化，而这个nonce在块头里，根哈希值也在块头，block header的哈希值发生变化之后，原来找到的nonce就作废了。所以你不可能偷答案，因为每个矿工挖到的nonce是和自己的收款地址绑定在一起的。</p>
</blockquote>
<p>8.交易费可以看作是发布区块的时候给矿工的一点小费，那么你怎么知道这个交易费该给那个矿工？事先你怎么知道哪个矿工会挖到矿？</p>
<blockquote>
<p>事先不需要知道哪个矿工得到这个交易费，只要total inputs &gt; total ouputs，这个差值就是交易费，给谁不需要事先知道，哪个矿工挖到矿了，就可以把这些差额收集起来，作为自己的交易费。</p>
</blockquote>
]]></content>
      <categories>
        <category>区块链</category>
      </categories>
      <tags>
        <tag>区块链</tag>
      </tags>
  </entry>
  <entry>
    <title>BTC十一---匿名性</title>
    <url>/2020/09/17/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%8C%BF%E5%90%8D%E6%80%A7/</url>
    <content><![CDATA[<h1 id="匿名性"><a href="#匿名性" class="headerlink" title="匿名性"></a>匿名性</h1><h2 id="匿名性介绍"><a href="#匿名性介绍" class="headerlink" title="匿名性介绍"></a>匿名性介绍</h2><p>BitCoin and anonymity</p>
<p>一般来说，大家说的匿名是和隐私保护联系（privacy）在一起的，比特币不要求是真名，是需要公钥产生的地址即可，因此有一定的匿名性，但不是说完全没有名字，他用的是“化名”，因此有人称它为“preudonymity”，就好像很多作家有笔名一样，比特币系统中的“匿名”其实不是真的匿名。</p>
<a id="more"></a>

<p>这种匿名性能给我们带来什么样的保护呢？和现金相比，和美元，法币相比？它的匿名性没有现金好，现金是完全匿名的。比特币的匿名性和银行存款相比，因为银行账户是实名制。（其实以前国内的银行不要求实名制，可以使用化名，如果这样的话，和比特币相比，哪个匿名性更好？从某种程度上来说，这时候的匿名性就比比特币要好，比特币的账户是公开的，而银行里普通老百姓想要知道别人的账户，这个是没有办法的。）</p>
<p>比特币系统中，什么情况下有可能破坏匿名性？有些人建议在你每次收款的时候，都创建一个新的账户，但是某些情况下，这些账户是可以被关联在一起的？（这个时候就破坏了比特币的匿名性）</p>
<blockquote>
<p>比如网上购物，一个交易可以有多个输入和输出。</p>
<p><img src="/2020/09/17/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%8C%BF%E5%90%8D%E6%80%A7/QQ%E6%88%AA%E5%9B%BE20200916195151.png"></p>
<p>这个Inputs有多个，这两个地址可能是同一个人（因为可能一个账户的钱，不够买这件商品，所以同时使用另一个账户来消费）；而Outputs其中一个一般是一个找零钱的输出。 像上图中的交易，一般都是由比特币钱包软件生成的，很多钱包软件交易的时候会生成一个新的找零钱的地址，有没有可能把输入地址和输出地址也关联起来呢？（有没有可能我们把这个找零钱的地址也找到？）</p>
<p>比特币钱包并没有规定找零钱的地址在Outputs中出现的位置，但其实有些情况下，你可以把它分析出来，我们想要对敌人造成干扰，就可以生成一些不必要的转账地址，但是一般没有人会这么干。</p>
<p><img src="/2020/09/17/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%8C%BF%E5%90%8D%E6%80%A7/QQ%E6%88%AA%E5%9B%BE20200916200401.png"></p>
</blockquote>
<p>这就说明，我们可以生成很多的地址账户，但是这些地址账户是可以被关联起来的。第二点是，这个地址账户跟你在社会现实世界中的真实身份也产生关联，那么什么时候会知道比特币的地址账户对应现实中的某个人呢？</p>
<blockquote>
<p>①任何比特币系统中的地址和现实世界发生联系的时候都有可能泄漏身份。在资金转入和转出区块链的时候都有可能泄漏，我们刚开始都没有比特币，这时候需要去交易所买，在交易所登记；也有场外交易的情况（就是两个人之间私下交易，以前国外有些做场外交易的公共场所）。</p>
<p>②很多国家有反洗钱法，那么怎么防范使用比特币洗钱的违法行为呢？</p>
<p>盯住这个资金的转入转出链其实是一个常用手段，如果你有很大的资金像转入到比特币，或者你有很大一部分比特币，你想转成法币，这个你想不引起司法部门的注意，实际上是很难的，这也是比特币隐私有可能被破坏的一个很重要的时机。</p>
<p>③用比特币做支付的时候，比如国外有的商家，是接受比特币支付的，咖啡店，餐馆之类（当然，这是一个bad idea，1.延迟大，等六个确认需要等待1个小时；2.交易费也很贵）。这个其实不仅仅是接受你支付的商家会知道，</p>
<p>其他人其实也会知道：以前曾经有一家信用卡公司，为了支持学术界的科研，把他收集到的一些信用卡的记录公开，公开的时候做一些隐私保护（信用卡号码取哈希，年龄，性别 等都抹掉了），有人就做了科研（其实不是为了研究信用卡的消费行为，而是怎么通过这些公开的数据推测出这个人实际上是谁）—&gt;通过过滤在某个时间某个人在哪里消费，就可以精准地定位到某个人</p>
</blockquote>
<p>这就说明，信用卡记录不能公开，去了哈希值之后依然是不应该公开的，但是比特币系统本来就是公开的，这时候你去咖啡店，你把你的账户的地址告诉了营业员，你周围有其他认识你的人都会意识到这时候你在比特币网络上做了一笔消费，然后就可以在区块链中查出来。所以比特币的匿名性并不像我们想象中的那么好</p>
<p>实际上那些用比特币的人，匿名性保存的有多好？中本聪！（因为他根本没有花钱）</p>
<p>中本聪为什么要发明比特币，当时他在发明比特币的时候还是花了很大的功夫的，有人说是为了赚钱，但是到现在，他账户上的比特币都没有花出去过（一旦花出去，就要和现实中的银行，交易所发生联系，这样会暴露他的身份，这是他不愿做的事情），所以他不是为了钱，可能是为了某种事业或者信念。</p>
<blockquote>
<p>以前有个叫silk road的网站：通过比特币卖各种违禁品，最后运行了两三年就被政府查封了，这个人通过这个网站赚了很多钱，但是他只是在纸面上很多钱，十几万个比特币一个都没花，因为一花就暴露身份了。所以，比特币的匿名性没有我们想象的那么好。</p>
</blockquote>
<p>所以，过去的经验表明，凡是用比特币从事违法活动的，最后都能被抓起来，中本聪能这么好的保持匿名性，实际上是一个个例，而且他没有干坏事</p>
<p>hide your indetiny from whom？</p>
<blockquote>
<p>如果你只是像让你的亲戚朋友不知道你的账户上有多少钱，这个是很容易办到的，如果是像silk road这样的想逃避fbi，是很难的。</p>
</blockquote>
<h2 id="如何提高匿名性"><a href="#如何提高匿名性" class="headerlink" title="如何提高匿名性"></a>如何提高匿名性</h2><p>假设你是一个比特币用户，你能用什么方法来提高你的匿名性？</p>
<blockquote>
<p>我们知道，比特币是运行在应用层的应用程序，它的底层是P2P的network，所以提高匿名性，是从两个方面入手。</p>
<p>network layer：如果很多交易都是从一个ip地址发出来的，那么从物理世界中，通过ip地址就可以知道是谁。这个我们已经有解决方案了，比较普遍的一种方法就是使用多路径转发的方法（TOR的原理），sender不是直接发给reciever，而是中间经过很多跳，中间的结点只是知道它的上一跳是谁，而不知道最早发出这个消息的是谁，中间的结点可能是坏的，但是只要中间有一个结点是诚实的，就可以将发件人的身份隐藏起来。</p>
<p>application layer：破坏匿名性的原因之一是，同一个人的不同的比特币账户之间会被关联起来。其中一个做法是</p>
<p>coin mixing：把你的身份和周围的人的身份混在一起，让别人分不清谁是谁。如何做到coin mixing？有些网站专门提供coin mixing的服务，收取一定的服务费，所有想使用coin mixing的用户，把币发给这些网站，内部进行一些重组，再取回来，取回来的币就不是原来的币了，实际上是一个复杂的过程。还有一个问题是，现在这个区块里世界里，没有什么信誉度非常高的coin mixing的服务，很多提供这个服务的网站，他自己也是匿名的，卷款跑路我们一点办法也没有。</p>
<p>我们不一定要刻意的coin mixing，我们使用的一些软件，有些自己就带有coin mixing的一些性质，比如在线钱包，存进去的币，他可能会把其他人的币混合起来，但是在线钱包并不一定要履行coin mixing的功能</p>
<p>还有一些交易所，他天然的有coin mixing的性质，我把一些比特币存进交易所，一段时间，我觉得它的价格会下跌，于是我把他换成美元，我有可能买入以太币，又可能换成莱特币，折腾几次之后，我又可能把他买回来，这时候我账户上的比特币，就不一定是我存进去的比特币了。（coin mixing的性质）。当然这个的前提是，这个交易所不是泄漏相关的记录（相关的提币存币的记录）</p>
</blockquote>
<p>为什么比特币的匿名性很差，其中一个本质原因是他是公开的，而且他是不可篡改的，好像不可篡改性对比特币有好处，其实堆隐私保护是灾难性的，因为一旦你在一个交易里把你的身份暴露了，这个交易永久地写在区块链里，你想抹都抹不掉了。这也是为什么我们说账户之间的关联性也是我们需要小心的，如果账户是单独出去的，如果你暴露了一个账户，这个影响还是比较有限的，如果是关联的，一个账户暴露了，后面的就都完了。</p>
<h2 id="零知识证明"><a href="#零知识证明" class="headerlink" title="零知识证明"></a>零知识证明</h2><p><img src="/2020/09/17/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%8C%BF%E5%90%8D%E6%80%A7/QQ%E6%88%AA%E5%9B%BE20200921195428.png"></p>
<p>比如，我要证明某个比特币账户是我的，我要证明这一点，我要怎么证明？</p>
<blockquote>
<p>实际上是要证明我有这个比特币账户的私钥，但是我不能把这个私钥告诉你，这时候就可以签名，你是知道这个账户的公钥的，你可以验证这个签名的合法性</p>
</blockquote>
<p>这个例子作为零知识证明，实际上是有争议的，我虽然没有泄露我的私钥，但是我泄露了我私钥的签名，这个和零知识证明中的无需透露该陈述是正确的外的任何信息是有冲突的。但是这里透露的额外信息要看你实际的应用场景。</p>
<p><img src="/2020/09/17/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%8C%BF%E5%90%8D%E6%80%A7/QQ%E6%88%AA%E5%9B%BE20200921195956.png"></p>
<p>零知识证明的数学基础是同态隐藏。</p>
<p>①不会出现哈希碰撞，如果x、y不相等，那么加密值也不相等，反过来说，如果两个加密函数值是相等的，那么原来的函数值也是相等的。</p>
<p>②说明加密函数不可逆，密码学的哈希函数的性质和这个是类似的，hiding propetry，知道哈希值没有办法知道它的输入值。</p>
<p>③对这些加密后的函数进行函数运算，等价于，对进行运算的函数，然后在进行加密。</p>
<p><img src="/2020/09/17/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%8C%BF%E5%90%8D%E6%80%A7/QQ%E6%88%AA%E5%9B%BE20200921200714.png"></p>
<p><img src="/2020/09/17/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%8C%BF%E5%90%8D%E6%80%A7/QQ%E6%88%AA%E5%9B%BE20200921200915.png"></p>
<p>说明：</p>
<p><code>E(X+Y) = E(7)</code>,说明没有碰撞</p>
<p>这个版本实际上有些缺陷，Bob可以用蛮力的方式，猜出原始的x、y是多少，Bob虽然通过E(x)不能知道x是多少，但是他可以通过遍历x的取值，Alice需要在发送E(x)和E(y)之前，对x、y进行随机化处理（使得x、y加起来还是不变的）。</p>
<p>在比特币的共识协议中，央行发行货币，有个属于他自己的签名，在前面所讲的，这样会产生double spending，所以可以在每张货币上加上一个id，记录现在这张货币在谁手里。这样的话，央行不是什么都知道了？</p>
<p>那么，有没有什么办法，让央行做中心化的记账，但是又不让他知道呢？</p>
<blockquote>
<p>这个虚拟货币的编号不能是央行产生的，这个编号得是我自己产生的，我在本地产生一个编号，但是不告诉央行，这样的话，央行怎么知道这个编号是不是正确的呢？这就引入了盲签。</p>
<p>用户A提供编号，银行是要签名的，但是他看不到内容,Token就是银行对序号的签名。</p>
<p><img src="/2020/09/17/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%8C%BF%E5%90%8D%E6%80%A7/QQ%E6%88%AA%E5%9B%BE20200921202409.png"></p>
</blockquote>
<h2 id="零币和零钞"><a href="#零币和零钞" class="headerlink" title="零币和零钞"></a>零币和零钞</h2><p><img src="/2020/09/17/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%8C%BF%E5%90%8D%E6%80%A7/QQ%E6%88%AA%E5%9B%BE20200921202540.png"></p>
<p>基础币可以是比特币，你用的时候，你要证明，本来是有一个基础币的，你把这个基础币搞得是不能花了，然后换取一个零币，零币在花的时候，只需要用零知识证明你花掉的币是系统中存在的某一个合法的币就行了，但是不用透露你花的是系统中的哪一个币。</p>
<p>这样就把关联性破坏掉了。</p>
<p>这些零币和零钞都不是主流的加密货币：这些币为了匿名性，在性能上是有一定的损失的，而且在数学原理上，对初始化，有比较严格的要求（初始的时候用的随机源要能够销毁掉，如果没有销毁掉，会有一定的安全漏洞），更重要的是，需要强匿名性的用户本来也不是很多，大多数用户觉得比特币的这种匿名性，其实也够用了。</p>
<p>虽然零币和零钞在数学原理上，存在很强的匿名性，但是也并不是100%匿名安全的，与实体世界发生交互的时候也会有问题。</p>
]]></content>
      <categories>
        <category>区块链</category>
      </categories>
      <tags>
        <tag>区块链</tag>
      </tags>
  </entry>
  <entry>
    <title>BTC七---挖矿</title>
    <url>/2020/08/30/%E5%8C%BA%E5%9D%97%E9%93%BE/%E6%8C%96%E7%9F%BF/</url>
    <content><![CDATA[<h1 id="挖矿"><a href="#挖矿" class="headerlink" title="挖矿"></a>挖矿</h1><h2 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h2><p><img src="/2020/08/30/%E5%8C%BA%E5%9D%97%E9%93%BE/%E6%8C%96%E7%9F%BF/QQ%E6%88%AA%E5%9B%BE20200828210256.png"></p>
<a id="more"></a>

<p><img src="/2020/08/30/%E5%8C%BA%E5%9D%97%E9%93%BE/%E6%8C%96%E7%9F%BF/QQ%E6%88%AA%E5%9B%BE20200828210616.png"></p>
<p>比特币网络中大部分节点是轻结点，如果只需要转账，不需要挖矿的话，没必要运行一个全节点。</p>
<p>在挖矿过程中，如果你监听到别人发布了一个区块，这个区块是合法的，也是在延伸最长合法连，这个时候你应该停止已有的挖矿，然后重新在本地组装一个侯选区块，重新挖矿，因为你要沿着这个新发布的区块向下挖的话，那么你本地所组装的这个区块中，包含的交易就会发生变化，有些交易可能已经包含到已经被发布的这个区块里了，block header的内容也会发生变化，Merkle tree的根哈希值，以及指向前一个区块的指针，这样做是不是有些可惜？</p>
<p>其实是不可惜的，因为前面我们提到一个挖矿的性质：无记忆性memory less（process free），所以你是坚持挖原来的区块，还是改成挖一个新组装的区块，成功的机率是一样的。</p>
<p>即时挖到了合法的区块，发布到区块链上，也不是说就是胜利了，有可能你发布的这个区块，最终没有成为最长合法链，</p>
<p>可能存在一些risk condition，别人同时发布了一个合法的区块，或者是存在一些你不知道的double spending，使得你这个区块中某些交易最后是有冲突的。</p>
<p>比特币是怎么保证安全性的？两方面</p>
<p>一方面：密码学上的保证：别人没有你的私钥，就不能伪造你的签名，这个的前提是，系统中拥有大多数算力的矿工是好的，是遵守协议的；</p>
<p>另一方面：共识机制。</p>
<h2 id="挖矿相关"><a href="#挖矿相关" class="headerlink" title="挖矿相关"></a>挖矿相关</h2><p>挖矿的设备：越来越趋向于专业化，最早的时候大家都是用普通的cpu去挖矿。</p>
<p>如果现在，你专门买一台计算机用来挖矿，其实是不划算的，因为计算机中的大部分内存都是闲置的，挖矿只用到其中很小一部分内存，cpu中的大部分部件也是闲置的，因为挖矿的操作只用到了通用cpu中的很少的一部分指令，硬盘和其他很多资源也用不到。</p>
<p>第二代：GPU–&gt;比cpu挖矿的效率高得多，GPU用于大规模的并行计算（像深度学习就用到了GPU，其中有很多矩阵的乘法），但是GPU用来挖矿，其实还是有点浪费的，里面有很多部件仍然处于闲置状态，比如用于浮点数计算的部件（比特币的挖矿只用到了整数计算）</p>
<blockquote>
<p>最近几年，GPU价格上涨的很快，有些人把它归于深度学习的火热，其实有很多GPU是用来挖矿的，不过有个好消息，现在比特币挖矿难度的提升，用GPU挖矿已经划不来了，所以都不竞争去买GPU用于挖矿了。</p>
</blockquote>
<p>现在用什么挖矿？用ASIC（Application Specific Integrated Circuit）芯片，它上面没有多余的电路逻辑，整个芯片就是为了比特币挖矿计算哈希值的操作而设计的，性价比最高，而且，为某一种加密货币设计的ASIC芯片，只能用来挖这一种加密货币，除非这两个加密货币使用同一个mining puzzle，有些加密货币新发行的时候，为了解决能源启动问题，他故意用一个已有的加密货币的mining puzzle，可以吸引更多的人来挖矿，这样的mining puzzle叫做merge mining。</p>
<p>ASIC芯片的研发周期是很长的，比特币的ASIC的芯片需要使用一年的时间，已经算是很快了，创造了ASIC芯片史上的奇迹，在这么长的时间里面，如果比特币的价格发生了很大的变化的话，前期投入的研发费用有可能就打水漂了。</p>
<p>即时在比特币发展的黄金时期，比特币价格上涨，挖矿是有利可图的，但是竞争也是越来越激烈的，定制的ASIC芯片可能用不了几个月就过时了，相当于一个军备竞赛。</p>
<blockquote>
<p>有研究表明，大部分的ASIC矿机，利润是在他上市的前两个月获得的，这个时候的算力在同类产品中最强，所以购买ASIC矿机的时机很重要，现在一般都是提前预定，如果不能及时发货，对矿工就有损利益，有些不良厂商，生产出了矿机，不立即发售，而是自己先用他挖矿</p>
</blockquote>
<p>有些新的加密货币设计的是Alternative mining puzzle 设计的初衷是：ASIC resistance（能够抗ASIC芯片化，目的是为了让通用的计算机也能参与挖矿）</p>
<p>挖矿的另一个趋势是：大量矿池的出现，单个矿工，即使用了ASIC芯片，挖矿从平均收益上看，是有利可图的，但是收入是十分不稳定的：比特币的平均出块时间是10分钟，但是这是总的矿工的平均，从单个矿工来看，可能他要挖一两年才出一个区块，就有点买彩票的意味了；单矿工还要面临一个困难：他除了挖矿之外，还要承担全节点的责任。</p>
<hr>
<p>矿池：就是把矿工组织起来，作为一个整体，矿池的架构是：一个全节点，会驱动很多的矿机</p>
<p><code>miner</code>只负责计算哈希值，<code>pool manager</code>承担全节点的其他职责，<code>pool manager</code>负责监听网上的交易，把这些交易组织打包成一个候选区块，同时看有没有其他的节点抢先发布区块。</p>
<p>矿池还能解决矿工收入不稳定的问题，有了收入，一起分配。分配的问题：如果矿机和矿池是分布式的（不在同一个机构），矿工和矿主不在同一个地方，矿工要加入一个矿池，就是按照这个矿池规定的通信协议，跟矿主练习，矿主把要计算的哈希值的任务分配给他，矿工计算完之后，把结果返回，有出矿奖励大家一起分配，如何分配？</p>
<blockquote>
<p>平均分配？明显的问题是吃“大锅饭”，干好干坏一个样；因此要按照每个矿工的贡献大小进行分配：这个地方同时需要工作量证明，如何证明？</p>
<p>矿工的收入不稳定是因为挖矿太难了，如果降低难度，收入就能稳定，怎么降低难度？原来的要求，找到nonce，匹配target，和block header算哈希前面至少70个零，现在降低难度，前面只要有60个零就行，这样挖到的叫做一个</p>
<p><code>share</code>：<code>almost valid block</code>,矿工挖到这样一个share之后，把他提交给矿主。</p>
<p>矿主拿到share有什么用？这个除了证明矿工的工作量之外，没有其他的用处，不可能发不出去，因为这个区块不是合法的，所以矿主就记录每个矿工提交了多少个share，将来等到某个矿工真的挖到了某个区块之后，再把这个出块奖励，按照每个矿工提交的share的数目分配。</p>
</blockquote>
<p>每个矿工挖到矿的概率取决于他尝试的nonce的数目，尝试的nonce越多，share就越多，所以可以把share作为工作量的衡量。</p>
<p>有没有可能矿工挖到了区块之后，不把他提交给矿主，自己独享？</p>
<blockquote>
<p>每个矿工的任务是由矿主来决定的，矿主负责组装好区块，然后让矿工尝试nonce，而且，光是调整nonce是不够的，还要调整coinBase parameter，所以矿主可能就是把不同的coinbase parameter对应的nonce的范围交给不同的矿工去尝试，那么这个区块里面包含了什么？</p>
<p>coinbase transaction里面有个收款人的地址，这个地址填的是矿主的地主，如果矿工不提交给矿主，他是收不到钱的。</p>
</blockquote>
<p>他不可能偷出块奖励，但是她有没有可能捣乱？（平时挖到一个share，作为工作量证明，但是等他真正挖到一个合法的区块的之后，他把它扔掉）</p>
<blockquote>
<p>但是这样做对他来说并没有什么经济上的好处，矿池之间是存在竞争关系的，有可能为了打击竞争对手，故意派一些矿工到对手的矿池里挖矿，“卧底”！</p>
</blockquote>
<p><img src="/2020/08/30/%E5%8C%BA%E5%9D%97%E9%93%BE/%E6%8C%96%E7%9F%BF/QQ%E6%88%AA%E5%9B%BE20200831215109.png"></p>
<p>​                                                                                    矿池在各个国家的分配比例</p>
<p><img src="/2020/08/30/%E5%8C%BA%E5%9D%97%E9%93%BE/%E6%8C%96%E7%9F%BF/QQ%E6%88%AA%E5%9B%BE20200831215228.png"></p>
<p>​                                                            2014年 GHash.IO矿池总算力占到了全球的51%以上</p>
<p>已经可以发动51攻击了！（当时引起了恐慌）</p>
<p>GHash主动降低总算力，以免动摇大家对比特币的信心</p>
<p><img src="/2020/08/30/%E5%8C%BA%E5%9D%97%E9%93%BE/%E6%8C%96%E7%9F%BF/QQ%E6%88%AA%E5%9B%BE20200831215554.png"></p>
<p>​                                                                                            2018年算力分布</p>
<p>假设一个机构有了一半以上的算力，他不一定要把算力都集中在一个矿池里，它可以把算力分不到不同的矿池里，平时是隐藏的，真正需要发动攻击的时候就结合起来。</p>
<p>矿工转换矿池是很容易的，所以这就是矿池带来的一个危害，如果没有矿池要发动51攻击的话，攻击者要投入大量的硬件成本来购买到足够的矿机，能够达到系统中半数以上的算力。</p>
<p>一般来说，pool manager也要收取一部分的出块奖励作为管理费，有的有恶意的矿池在发动攻击前，故意把矿池的管理费降得特别低，甚至是赔本，吸引到足够多的矿工之后，就可以发动攻击了。</p>
<hr>
<p>假设有矿池达到了51%的算力，他具体能发动什么攻击呢？</p>
<blockquote>
<p>分叉攻击</p>
<p>Boycott：封锁禁域。所有有关某个节点的交易，他都不包含进去，而且这个攻击也不需要等待6个确认，仗着自己的算力强，公开抵制有关某个结点的交易。</p>
</blockquote>
<p>攻击者的矿池中事不明真相的矿工群众，因为每个矿工只是计算哈希值，他并不知道网上有什么样的交易，发布了什么区块，并不知道double spending的存在。</p>
<p>另外，不要把51%的阈值，当成一个门槛，这个其实都是概率，而且，每个矿池所占的算力比重，本身也是一种估计而已，而且实时变化</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>大型矿池的出现，有一定的好处：给矿工减轻了负担，收入分配也更加稳定。</p>
<p>也有一定的危害：发动51攻击更容易了 <code>on demand mining</code></p>
]]></content>
      <categories>
        <category>区块链</category>
      </categories>
      <tags>
        <tag>区块链</tag>
      </tags>
  </entry>
  <entry>
    <title>BTC六---挖矿难度</title>
    <url>/2020/08/30/%E5%8C%BA%E5%9D%97%E9%93%BE/%E6%8C%96%E7%9F%BF%E9%9A%BE%E5%BA%A6/</url>
    <content><![CDATA[<h1 id="挖矿难度"><a href="#挖矿难度" class="headerlink" title="挖矿难度"></a>挖矿难度</h1><h2 id="为什么要调整挖矿难度"><a href="#为什么要调整挖矿难度" class="headerlink" title="为什么要调整挖矿难度"></a>为什么要调整挖矿难度</h2><p>调整挖矿难度，就是调整目标空间在整个输出空间中所占的比例</p>
<p>比特币的哈希算法是SHA-256，256位的哈希值，所以输出空间位2^256个可能取值，调整目标空间占输出空间的比例，通俗的说，就是这个哈希值前面要多少个零，合法的哈希，算出来，前面至少要有70个零，但是严格的话还是按照定义来计算哈希值。</p>
<a id="more"></a>

<p>另外一种概念：挖矿难度，挖矿难度和目标阈值成反比</p>
<p><img src="/2020/08/30/%E5%8C%BA%E5%9D%97%E9%93%BE/%E6%8C%96%E7%9F%BF%E9%9A%BE%E5%BA%A6/QQ%E6%88%AA%E5%9B%BE20200826214434.png"></p>
<p>挖矿难度最小就是1，所以这时候target很大，那我们为什么要调整挖矿难度呢？如果不调，会有什么问题：系统中的总算力越来愈强，挖矿难度不变的话，出块时间就会越来越短，一开始没什么人，按照设计是十分钟出一个区块，后来一分钟就可以出一个区块，再到后来，用的设备越来越先进，不到一秒。</p>
<p>这么快不好吗？我每出现一个交易就可以及时的写入区块里，减少了系统的响应时间，这不是好事吗？其实不是件好事，这样会有什么问题吗？</p>
<p>如果两个结点同时发布了一个区块，那么这个时候可能会出现分叉，分叉就成了常态，可能不仅仅是二分叉，分叉如果过多，对于系统达成共识，是没有好处的，也危害到系统的安全性，比特币系统是假设，大部分算力都掌握在诚实的结点手里，系统当中的总算力越强，安全性就越好（发动51% attack的算力要求就更大）</p>
<p><img src="/2020/08/30/%E5%8C%BA%E5%9D%97%E9%93%BE/%E6%8C%96%E7%9F%BF%E9%9A%BE%E5%BA%A6/QQ%E6%88%AA%E5%9B%BE20200826220208.png"></p>
<p>这个时候，可能10%的算力就可以发动攻击了，所以出块时间，不是越短越好。比特币系统中设计的10分钟的出块原则是不是最优的呢？这个不一定，这个只是说，出块时间要有一个常熟的波动范围，不能无限的减少下去，这个对于支付系统来说，其实还是比较长了。</p>
<p>以太坊就将出块时间降低到了15秒，这样以太坊就要设计一个新的共识协议：ghost，这个之后会提到，以太坊同样也会调整挖矿难度，是出块时间保持稳定；所以，出块时间没有规定多长，但是不管多长，都要保持稳定，而不能无限地减少下去 </p>
<h2 id="如何调整挖矿难度"><a href="#如何调整挖矿难度" class="headerlink" title="如何调整挖矿难度"></a>如何调整挖矿难度</h2><p>比特币中规定了，每隔2016个区块要重新调整目标阈值，大概是每两个星期调整一下</p>
<p><img src="/2020/08/30/%E5%8C%BA%E5%9D%97%E9%93%BE/%E6%8C%96%E7%9F%BF%E9%9A%BE%E5%BA%A6/QQ%E6%88%AA%E5%9B%BE20200828203802.png"></p>
<p>调整的公式：</p>
<p><img src="/2020/08/30/%E5%8C%BA%E5%9D%97%E9%93%BE/%E6%8C%96%E7%9F%BF%E9%9A%BE%E5%BA%A6/QQ%E6%88%AA%E5%9B%BE20200828204035.png"></p>
<p>实际的代码中，上调和下调实际上都是有4倍的限制的，最多增大，下调4倍</p>
<p>那么如何让所有的矿工，都调整目标阈值呢？怎么能让大家都听话？如果恶意的区块不调整target，那么诚实的结点不会认可：检查的内容包括nBits（target的编码版本）域</p>
<p><code>比特币系统中总算力的变化情况</code></p>
<p><img src="/2020/08/30/%E5%8C%BA%E5%9D%97%E9%93%BE/%E6%8C%96%E7%9F%BF%E9%9A%BE%E5%BA%A6/QQ%E6%88%AA%E5%9B%BE20200828205244.png"></p>
<p><code>算力难度的增长情况</code></p>
<p><img src="/2020/08/30/%E5%8C%BA%E5%9D%97%E9%93%BE/%E6%8C%96%E7%9F%BF%E9%9A%BE%E5%BA%A6/QQ%E6%88%AA%E5%9B%BE20200828205539.png"></p>
<p>符合难度调整的设计目标</p>
<p><code>难度调整曲线</code></p>
<p><img src="/2020/08/30/%E5%8C%BA%E5%9D%97%E9%93%BE/%E6%8C%96%E7%9F%BF%E9%9A%BE%E5%BA%A6/QQ%E6%88%AA%E5%9B%BE20200828205648.png"></p>
<p>说明挖矿的人越来越多，设备越来越先进</p>
<p><code>每天的出块时间</code></p>
<p><img src="/2020/08/30/%E5%8C%BA%E5%9D%97%E9%93%BE/%E6%8C%96%E7%9F%BF%E9%9A%BE%E5%BA%A6/QQ%E6%88%AA%E5%9B%BE20200828205804.png"></p>
<p><code>最近半年的出块事件</code></p>
<p><img src="/2020/08/30/%E5%8C%BA%E5%9D%97%E9%93%BE/%E6%8C%96%E7%9F%BF%E9%9A%BE%E5%BA%A6/QQ%E6%88%AA%E5%9B%BE20200828205845.png"></p>
<p><img src="/2020/08/30/%E5%8C%BA%E5%9D%97%E9%93%BE/%E6%8C%96%E7%9F%BF%E9%9A%BE%E5%BA%A6/QQ%E6%88%AA%E5%9B%BE20200828210138.png"></p>
]]></content>
      <categories>
        <category>区块链</category>
      </categories>
      <tags>
        <tag>区块链</tag>
      </tags>
  </entry>
  <entry>
    <title>BTC二---比特币中的数据结构</title>
    <url>/2020/08/29/%E5%8C%BA%E5%9D%97%E9%93%BE/%E6%AF%94%E7%89%B9%E5%B8%81%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<h1 id="比特币中的数据结构"><a href="#比特币中的数据结构" class="headerlink" title="比特币中的数据结构"></a>比特币中的数据结构</h1><h2 id="1-区块链"><a href="#1-区块链" class="headerlink" title="1.区块链"></a>1.区块链</h2><p>这里要用到一个重要的概念叫做哈希指针。</p>
<p>hash pointers，哈希指针，除了要保存这个结构体的地址之外，还要保存这个结构的的哈希值（不仅可以知道这个结构体在内存中的位置，还可以知道这个结构体的内容有没有被篡改）</p>
<p>区块链相比较于普通的链表有何区别？</p>
<a id="more"></a>

<p>①用哈希指针替代了普通的指针</p>
<p><img src="/2020/08/29/%E5%8C%BA%E5%9D%97%E9%93%BE/%E6%AF%94%E7%89%B9%E5%B8%81%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/QQ%E6%88%AA%E5%9B%BE20200802193317.png"></p>
<p>区块链示例</p>
<p><img src="/2020/08/29/%E5%8C%BA%E5%9D%97%E9%93%BE/%E6%AF%94%E7%89%B9%E5%B8%81%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/QQ%E6%88%AA%E5%9B%BE20200802193910.png"></p>
<p><img src="/2020/08/29/%E5%8C%BA%E5%9D%97%E9%93%BE/%E6%AF%94%E7%89%B9%E5%B8%81%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/QQ%E6%88%AA%E5%9B%BE20200802194121.png"></p>
<p>这样做的好处是</p>
<p>tamper-evident log：篡改-证明 日志，当有人篡改了区块链中某一个区块的某个内容，则它的下一个区块的哈希值就对不上了，以此类推，直到最后一个保存在系统中的哈希值也对不上了，这样我们只需要记住保存在系统中的那最后一个哈希值，就可以检测出对任意区块的修改。这也是区块链和普通链表的一个区别。（多米诺骨牌效应）</p>
<p>有了这个性质，系统中就不需要保存整条区块链的内容，比如它可以只保存最近的几千个区块，如果要用到以前的区块怎么办？</p>
<blockquote>
<p>可以问系统中的其他节点，去要这个区块，有些节点可能是有恶意的（去中心化系统），那么如何知道别人给你的区块是不是正确的呢？就用到哈希指针的这个性质！别人给你的最后的那个区块，算一下哈希值，如果和系统中保存的与之对应的后一个区块的哈希值对比之后相同，则正确</p>
</blockquote>
<h2 id="2-Merkle-tree-默克尔树"><a href="#2-Merkle-tree-默克尔树" class="headerlink" title="2.Merkle tree(默克尔树)"></a>2.Merkle tree(默克尔树)</h2><p>和binary tree（二叉树）的区别是，用哈希指针代替了普通的指针</p>
<p><img src="/2020/08/29/%E5%8C%BA%E5%9D%97%E9%93%BE/%E6%AF%94%E7%89%B9%E5%B8%81%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/QQ%E6%88%AA%E5%9B%BE20200802200344.png"></p>
<p>和链式结构一样，“牵一发而动全身”。</p>
<p>各个区块由哈希指针连接在一起的，每个区块所包含的交易，是组织成一个Merkle tree的形式，最底层的数据块实际上是某个交易。</p>
<p>每个区块都是由block header和block body组成，block header 保存这个Merkle tree 的根哈希值，不保存这个区块的交易信息，而block body保存交易信息</p>
<p><img src="/2020/08/29/%E5%8C%BA%E5%9D%97%E9%93%BE/%E6%AF%94%E7%89%B9%E5%B8%81%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/QQ%E6%88%AA%E5%9B%BE20200802200930.png"></p>
<p>Merkle tree的作用？</p>
<p>①提供Merkle proof</p>
<p>比特币中的结点分为两类，一类时全节点，还有一类是轻结点</p>
<p>全节点：保存整个区块的内容，block header和block body都有</p>
<p>轻结点：比如手机上的比特币钱包的应用就属于轻结点，只有一个block header</p>
<p>这样就带来一个问题，如果你想向一个轻结点证明某个交易是写入到了区块链中的 ，该怎么证明？</p>
<p>​    比如我想买你的东西，我就需要向你转钱，我对你说，我对你转钱的交易，已经写到了区块链中了，支付已经完成了，</p>
<p>那么你怎么知道，这个交易已经被写入区块链里了呢？这里就需要用到Merkle proof</p>
<p>一个轻结点，向某个全节点发出请求，请求一个能够证明黄色结点这个交易，被包含在这棵Merkle tree里面的Merkle proof</p>
<p><img src="/2020/08/29/%E5%8C%BA%E5%9D%97%E9%93%BE/%E6%AF%94%E7%89%B9%E5%B8%81%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/QQ%E6%88%AA%E5%9B%BE20200802202232.png"></p>
<p>最后算出的根哈希值，和block header中存储的root hash比较，就可以证明出tx是否在区块链中</p>
<p>这种证明也叫做：</p>
<p>proof of membership</p>
<p>或</p>
<p>proof of inclusion</p>
<p>如果最底下有n个交易：时间复杂度为O(log(n))</p>
<p>那么可不可以证明，区块链中没有某个交易？也就是proof of non-membership</p>
<p>有一种比较笨的方法，就是把这一整颗Merkle tree都传给轻结点，如果hash值都正确，如果某个交易不在叶结点中，则证明了proof of non-membership，时间复杂度为O(n)，有没有比较高效的方法证明不存在？</p>
<p>如果我们对叶结点的排列顺序不了解，那么是没有办法证明交易不在里面的</p>
<p>如果我们对叶结点的排列顺序做一些要求：对每个交易取哈希值，按照这个哈希值从小到大排序，这个时候是有一个好的证明方法的：但是代价是需要排序</p>
<p><img src="/2020/08/29/%E5%8C%BA%E5%9D%97%E9%93%BE/%E6%AF%94%E7%89%B9%E5%B8%81%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/QQ%E6%88%AA%E5%9B%BE20200802204313.png"></p>
<p>sorted Merkle tree：排好序的Merkle tree</p>
<p>比特币中没有这种排好序的Merkle tree，因为比特币中根本不需要作这种不存在证明，没有硬性需求，所以比特币中的Merkle tree 不要求排序</p>
<h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3.总结"></a>3.总结</h2><p>比特币中的两种数据结构：区块链和Merkle tree</p>
<p>除了这两种数据结构，哈希指针还用在什么地方？</p>
<p>只要这个数据结构是无环的，都可以用哈希指针来代替普通指针，有环会带来一定的问题</p>
<p><img src="/2020/08/29/%E5%8C%BA%E5%9D%97%E9%93%BE/%E6%AF%94%E7%89%B9%E5%B8%81%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/QQ%E6%88%AA%E5%9B%BE20200802204834.png"></p>
<p>会出现循环依赖的问题，定不下来任何一个区块，找不到创世纪块</p>
]]></content>
      <categories>
        <category>区块链</category>
      </categories>
      <tags>
        <tag>区块链</tag>
      </tags>
  </entry>
  <entry>
    <title>BTC五---网络</title>
    <url>/2020/08/30/%E5%8C%BA%E5%9D%97%E9%93%BE/%E7%BD%91%E7%BB%9C/</url>
    <content><![CDATA[<h1 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h1><p>新发布的区块，新发布的交易，再区块链中是怎么传播的？</p>
<a id="more"></a>

<p>比特币网络的工作原理</p>
<p>The BitCoin Network，比特币工作在应用层，它的底层是一个P2P Overlay Network，所有结点都是对等的，他不想有些所谓的P2P网络有所谓的超结点(Super node | master node),你要加入比特币网络，你要至少知道一个种子结点（seed node），你和这个种子节点联系，他会告诉你他所知道的网络中的其他节点，节点之间是通过tcp通信的，这样有利于穿破防火墙，你离开的时候也不需要执行其他操作（比如通知其他结点，退出应用程序即可），别的节点没有听到你的消息，过了一段时间就会把你删掉。</p>
<p>比特币网络的设计原则是简单（simple，robust，but not efficient），每个结点维护一个邻居节点的集合，消息传播在网络中采取flooding（泛洪）的方式，结点第一次听到某个消息的时候，把他传播给所有的邻居结点，同时记录一下，这个消息我已经记录过了，下次再收到这个消息的时候，就不用转发给邻居节点了</p>
<p>邻居结点的选取是随机的，没有考虑底层的拓扑结构，和地区没有关系，这样的好处是增强鲁棒性，没有考虑实际的拓扑结构，但是牺牲的是效率，向身边的人转账和向美国的人转账速度其实是差不多的。</p>
<p>比特币系统中每个节点要维护一个等待上链的交易的集合。第二次听到同样的交易就不会传播给邻居结点，避免交易在网络中无限制的传播下去，转发的前提是这个交易得是合法的，这里有一个risk condition：有可能你有两个有冲突的交易，差不多同时被广播到网络上</p>
<p><img src="/2020/08/30/%E5%8C%BA%E5%9D%97%E9%93%BE/%E7%BD%91%E7%BB%9C/QQ%E6%88%AA%E5%9B%BE20200826201624.png"></p>
<p>新发布的区块在网络中的传播方式和新发布的交易在网络中传播是相似的，每个结点除了要检查区块的内容之外，还要检查一下是否在最长合法链上，越是大的区块，在网络中传播的速度就越慢，比特币协议对区块大小有一个限制，1M字节的限制，1M大小的区块在区块链中的传播时间就已经达到了50秒（传播完）</p>
<p>我们讲的比特币网络，它的传播是属于best effort，一个交易发布到网络上，不一定所有的节点都能收到，而且不同的节点收到这个交易的顺序也不一定是一样的，网络传播存在延迟，有的节点也不一定按照比特币协议的要求转发，比如有的该转发的它不转发，导致某些合法的交易收不到，有些节点也有可能转发一些不该转发的消息，比如有些不合法的交易，他也会转发，这是去中心化系统中所面临的问题</p>
]]></content>
      <categories>
        <category>区块链</category>
      </categories>
      <tags>
        <tag>区块链</tag>
      </tags>
  </entry>
  <entry>
    <title>BTC三---协议</title>
    <url>/2020/08/30/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%8D%8F%E8%AE%AE/</url>
    <content><![CDATA[<h1 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h1><h2 id="1-需要解决的问题"><a href="#1-需要解决的问题" class="headerlink" title="1.需要解决的问题"></a>1.需要解决的问题</h2><p>举个例子，央行可以发行数字货币，每张数字货币上都有央行的私钥的签名</p>
<a id="more"></a>

<p><img src="/2020/08/30/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%8D%8F%E8%AE%AE/QQ%E6%88%AA%E5%9B%BE20200810202143.png"></p>
<p>央行的公钥我们大家都知道，所以我收到一个数字货币，我可以验证一下是不是真的，买东西的时候，我把数字货币发给你，同理你也可以验证确实是央行发行的，这就完成了支付的一个过程。</p>
<p>这里用到了密码学中的非对称加密体系，但是没有用到区块链，这样会带来什么问题？</p>
<p>这个数字货币是个文件，我们不能篡改，但是可以复制，可以复制很多份，这和人民币不一样，我把人民币给你了，我就没有人民币了。这就是数字货币和纸质货币的区别</p>
<p>double spending attack（双花攻击），数字货币面临的一个主要挑战，就是防范double spending attack</p>
<p>改进的方案：</p>
<p><img src="/2020/08/30/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%8D%8F%E8%AE%AE/QQ%E6%88%AA%E5%9B%BE20200810203047.png"></p>
<p>央行发行的货币，再每个数字货币上添加一个编号，并且在数据库中保存这个编号对应的货币目前在谁手上，收款方不仅验证数字货币的真实性，还需要验证付款方是否合法，央行的 数据库进而修改017对应的数字货币的所有者。</p>
<p>这样做是没有问题的，但是这是一个中心化的方案，数字货币的发行是由央行统一控制的，而且每次交易也是由央行控制的。</p>
<p>那么有没有去中心化的方案呢？将央行这个职能，改成由广大用户共同承担，这就是比特币，这个数字货币系统要解决的问题。</p>
<p>去中心化的货币要解决两个问题：数字货币的发行（没有央行了，都是普通群众，那怎么决定数字货币的发行：什么时候发行，该发行多少）、怎么验证交易的有效性（如何防止double spending attack）</p>
<p>①谁来发行货币？在比特币系统中，是由挖矿来决定的，这个在后面详细讲</p>
<p>②如何防止double spending attack：也是维护一个数据结构，检测数字货币有没有花过，被谁花过，只不过这个数据结构不是由央行来维护，而是由所有的用户来维护，这个数据结构就是区块链</p>
<p>比如用户A，拥有了发行货币的能力</p>
<p><img src="/2020/08/30/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%8D%8F%E8%AE%AE/QQ%E6%88%AA%E5%9B%BE20200810204843.png"></p>
<p><strong>比特币中的交易都包含输入和输出两部分，输入部分说明币的来源，输出部分要给出收款人公钥的哈希</strong></p>
<p>这里有两个哈希指针，一个哈希指针是用来连接各个区块，把他们串起来构成一个链表，还有一个指针是用来说明币的来源的（用于证明这个数字货币不是凭空捏造的，同时防范double spending attack）</p>
<p><img src="/2020/08/30/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%8D%8F%E8%AE%AE/QQ%E6%88%AA%E5%9B%BE20200810205441.png"></p>
<p>A要给B转钱，需要知道B的地址，这个地址是由B的公钥取哈希，经过一些转换推算得到的，那A要怎么知道B的地址呢？</p>
<p>比特币系统没有提供一种功能去查询某个指定人的所对应的比特币地址，这个需要其他的渠道来获得</p>
<p>A要给B转钱，B要知道A的什么信息？币的来源？（B不需要知道，这个其实是A要知道的）</p>
<p>答案是B要知道A的公钥。B要知道A的身份，好知道这笔钱是哪来的。但是不仅仅是B需要知道A的公钥，所有结点都需要知道A的公钥—-&gt;为了验证A的签名，那问题又来了，怎么知道A的公钥？</p>
<p>输入当中不仅要说明币的来源，还需要说明A的公钥是什么</p>
<p><img src="/2020/08/30/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%8D%8F%E8%AE%AE/QQ%E6%88%AA%E5%9B%BE20200810211410.png"></p>
<p><img src="/2020/08/30/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%8D%8F%E8%AE%AE/QQ%E6%88%AA%E5%9B%BE20200810211619.png"></p>
<p>在比特币系统中，这些验证的过程，是通过执行脚本来实现的—–&gt;BitCoin Script</p>
<p>将后面交易的输入的执行脚本和前面交易的输出的执行脚本拼接，如果能顺利执行，那么这个验证就是通过的</p>
<p>每个区块由block header 和 block body组成</p>
<p>block header：保存每个区块的一些宏观的信息，包括</p>
<p>①：用的是比特币哪个版本的协议</p>
<p>②hash of previous block header：区块中指向前一个区块的指针</p>
<p><strong>注意：</strong>前一个区块的哈希只算的是区块的块头</p>
<p>③Merkle root hash：整棵Merkle tree的根哈希值</p>
<p>④target：挖矿的难度目标阈值</p>
<p><img src="/2020/08/30/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%8D%8F%E8%AE%AE/QQ%E6%88%AA%E5%9B%BE20200810213647.png"></p>
<p>block header存的就是target的一个编码：nBits</p>
<p>⑤nonce：随机数nonce    </p>
<p>block body：</p>
<p>①transaction list：交易列表</p>
<p>貌似所有的结点都需要验证区块链中的每一个交易</p>
<p>实际上区块链分为全节点full node 和轻结点light node 两种结点</p>
<p>full node ：保存所有的信息，验证每一个交易，也叫做fully validating node</p>
<p>light node：并不参数验证，只是利用区块链的一些信息做一些查询之类的工作</p>
<p>交易如何写入区块链，按照什么顺序？账本的内容要取得分布式的共识（distributed consensus）</p>
<p>分布式的共识？举个例子，就是简单的哈希表distributed hash table，就是，一台机器在hash表中插入了一条数据（key-value pair），在别的机器也能查询到。</p>
<h2 id="2-分布式系统中的结论和协议"><a href="#2-分布式系统中的结论和协议" class="headerlink" title="2.分布式系统中的结论和协议"></a>2.分布式系统中的结论和协议</h2><p>分布式系统有很多的不可能结论impossibility result，最著名的一个叫做FLP impossibility result:</p>
<p>在一个异步的系统里（asynchronous system），网络传输时延没有上限，即时只有一个成员是有问题的（faulty），也不可能取得共识</p>
<p>还有一个结论CAP Theorem：</p>
<p>C：consistency（一致性）   A：Availability（可用性）   P：Partition tolerance（分区容错性）</p>
<p>任何一个分布式系统CAP三个性质最多只能满足两个，不可能三个性质都满足。</p>
<p>分布式共识的一个重要协议：Paxos，这个协议能够保证Consistency，如果这个协议达成了共识，那么这个共识一定是一致的，不会说一个成员认为的共识和另外一个成员认为的共识不一样。但是，某些情况下，Paxos协议有可能一直没有办法达成共识，这种可能性在实际系统中是比较小的，但是是客观存在的</p>
<h2 id="3-比特币系统中的分布式共识协议"><a href="#3-比特币系统中的分布式共识协议" class="headerlink" title="3.比特币系统中的分布式共识协议"></a>3.比特币系统中的分布式共识协议</h2><p>需要解决的问题是，某些节点可能是有恶意的，我们假设系统中大多数节点是好的，如何去设计共识协议？</p>
<p>一种想法，既然大多数结点是好的，那直接投票行不行，比如说：某一个结点提出一个候选区块，他根据收到的交易信息，选一下那些交易是合法的，然后把这些交易按照某个顺序打包到一个区块里，候选区块发布给所有的结点，每个结点收到这个区块之后，检查这里面的交易是不是都是合法的，如果都是合法的，那么这个结点就投赞成票，如果有个交易是非法的，就投反对票，最后算出得票，如果超过半数，就将这个候选区块正式接受，写道区块链中</p>
<p>会带来什么问题？</p>
<p>①某个结点提出候选区块，万一这个节点是有恶意的呢，就不停的产生一些非法的交易让系统一直投票，会阻塞系统的发展</p>
<p>②并不能强迫每个节点都投票（行政不作为）</p>
<p>③效率的问题，网络的延迟状况不是很清楚</p>
<p>最大的问题：所有基于投票的方案，首先要确定谁有投票权（需要有membership）。如果这个系统的membership是有严格定义的，不是谁都可以加入的，比如hyperledger，只有某些符合条件的大公司才能加入，这种情况下，基于投票的方案是可行的。</p>
<p>但是比特币系统不是这样的，比特币系统中创建一个账户是很容易的，在本地产生一个公私钥对其他人其实都不知道，只有在你和外部交易的时候别人会知道，这种情况下，有恶意的结点，用一台超级计算机，不停的创建账户，当账户超过总数的一半时，就会对投票产生控制权，这种攻击叫做女巫攻击（sybil attack）。</p>
<p>所以简单的随机投票是不行的</p>
<p>比特币中采用了一个巧妙地机制来解决这个问题，也是投票，但不是按照账户的数目投票，而是用计算力来投票，每个结点都可以在本地组装出一个候选区块，把他认为合法的交易放在这个区块里，就开始尝试各种nonce值，看那个结点可以满足不等式的要求，求出的hash落在指定的范围之内，如果某个节点找到了符合要求的nonce，我们就说他获得了记账权（向比特币这个去中心化的账本里写入下一个区块的权力），只有这样的结点，才有权力发布下一个区块，其他节点要先验证这个区块的合法性，block header 中的nBits（挖矿的难度要求）是否正确，然后验证nonce，总的来说，就是先查询block header中的各种值，然后验证block body中的交易是否合法（是否有合法的签名、是否被花过）</p>
<p>有没有可能这个区块的所有内容都符合要求，但是我们仍然不愿意接受他？</p>
<p><img src="/2020/08/30/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%8D%8F%E8%AE%AE/QQ%E6%88%AA%E5%9B%BE20200812212804.png"></p>
<p>分叉攻击，通过像区块链中间插入一个区块，来回滚某个已经发生的交易，但是区块链在正常情况下也会出现分叉，</p>
<p>如果同时有两个结点获得了记账权，就有可能发生，可能会出现两个等长的分叉</p>
<p><img src="/2020/08/30/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%8D%8F%E8%AE%AE/QQ%E6%88%AA%E5%9B%BE20200812213645.png"></p>
<p>比特币系统中，缺省情况下，每个结点是接受他最早收到的那个，不同的结点在网络中的位置不同，接受的结点可能也不同，什么叫做接受？在接受一个区块之后会向后扩展区块</p>
<p><img src="/2020/08/30/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%8D%8F%E8%AE%AE/QQ%E6%88%AA%E5%9B%BE20200812214435.png"></p>
<p><img src="/2020/08/30/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%8D%8F%E8%AE%AE/QQ%E6%88%AA%E5%9B%BE20200812214518.png"></p>
<p>那么为什么要争夺记账权？</p>
<p>记账的结点可以拥有某些权力，决定那些交易被写到区块链里，但是设计的时候不应该让这个权力称为争夺记账权的主要动力，因为我们希望所有的合法的交易都应该被写进区块链里</p>
<p>比特币系统规定，获得记账权的哪个结点，在发布的区块里可以有一个特殊的交易，就是铸币交易，可以发布一定数量的比特币。coinbase transaction（交易）</p>
<p>比特币系统要解决两个问题，一个是谁来决定发行货币，另一个是验证交易的合法性，回过头来说明第一个问题：</p>
<p>coninbase transaction （交易）是比特币系统中发行货币的唯一方法，其他所有的交易都是把已有的比特币从一个账户转移到另一个账户，coinbase transaction不用指明币的来源，那能铸多少个币呢</p>
<p>比特币刚上线时，每一个新增的区块可以铸50 BTC，但是每21万个区块之后，这个奖励就要减半，现在的情况就是12.5 BTC</p>
<p><strong>注意：orphan block中的奖励的比特币就无效了</strong></p>
<h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4.总结"></a>4.总结</h2><p>最后，那么比特币要取得的共识是什么？去中心化账本中的内容要取得共识，只有获得记账权的结点才能往里面写东西，</p>
<p>我们通过算例来获得记账权，每秒钟能够试多少个nonce的数目（hash rate），hash rate越高，得到出块奖励的概率越大</p>
]]></content>
      <categories>
        <category>区块链</category>
      </categories>
      <tags>
        <tag>区块链</tag>
      </tags>
  </entry>
  <entry>
    <title>BTC八---比特币脚本</title>
    <url>/2020/09/02/%E5%8C%BA%E5%9D%97%E9%93%BE/%E6%AF%94%E7%89%B9%E5%B8%81%E8%84%9A%E6%9C%AC/</url>
    <content><![CDATA[<h1 id="比特币脚本"><a href="#比特币脚本" class="headerlink" title="比特币脚本"></a>比特币脚本</h1><p>比特币脚本，十分简单，不像c++，java，有堆栈的概念，比特币脚本是基于栈的脚本语言</p>
<p>下面来看一个具体的交易：</p>
<a id="more"></a>

<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p><img src="/2020/09/02/%E5%8C%BA%E5%9D%97%E9%93%BE/%E6%AF%94%E7%89%B9%E5%B8%81%E8%84%9A%E6%9C%AC/QQ%E6%88%AA%E5%9B%BE20200902204839.png"></p>
<p><img src="/2020/09/02/%E5%8C%BA%E5%9D%97%E9%93%BE/%E6%AF%94%E7%89%B9%E5%B8%81%E8%84%9A%E6%9C%AC/QQ%E6%88%AA%E5%9B%BE20200902205012.png"></p>
<p>size:交易的大小</p>
<p>locktime：用来设定交易的生效时间，0表示立即生效，绝大多数情况下，这个locktime都是0</p>
<p>vin：输入部分</p>
<p>vout：输出部分</p>
<p>time：交易产生的时间</p>
<p>blocktime：区块产生的时间</p>
<p><img src="/2020/09/02/%E5%8C%BA%E5%9D%97%E9%93%BE/%E6%AF%94%E7%89%B9%E5%B8%81%E8%84%9A%E6%9C%AC/QQ%E6%88%AA%E5%9B%BE20200902205303.png"></p>
<p>交易的输入是一个数组，一个交易可以有多个输入，每个输入都要说明输入花的币都是来自之前那个交易的输出</p>
<p>txid：输出这个币的交易的哈希值，</p>
<p>vout：表示是当前交易里的第几个输出，相当于id</p>
<p>scriptSig：输入脚本，因为最简单的输入脚本就是给一个sianature就行了，证明你有权利花这个钱</p>
<p><img src="/2020/09/02/%E5%8C%BA%E5%9D%97%E9%93%BE/%E6%AF%94%E7%89%B9%E5%B8%81%E8%84%9A%E6%9C%AC/QQ%E6%88%AA%E5%9B%BE20200902205729.png"></p>
<p>同样是一个数组，</p>
<p>value：表示输出的金额(BTC)，有时候也用Satoshi表示（1Satoshi=0.00000001 BTC）</p>
<p>n：表示这个当前交易的第几个输出，相当于id</p>
<p>scriptPubKey：输出脚本，因为输出脚本最简单的形式就是给出一个public key，所以叫做scriptPubKey</p>
<p>asm：输出脚本的内容，里面包含一系列的操作</p>
<p>reqSigs：表示这个输出需要多少个签名才能兑现</p>
<p>type：输出类型</p>
<p>address：输出地址</p>
<h2 id="脚本执行"><a href="#脚本执行" class="headerlink" title="脚本执行"></a>脚本执行</h2><p><img src="/2020/09/02/%E5%8C%BA%E5%9D%97%E9%93%BE/%E6%AF%94%E7%89%B9%E5%B8%81%E8%84%9A%E6%9C%AC/QQ%E6%88%AA%E5%9B%BE20200902210638.png"></p>
<p>如果一个交易有多个输入，那么每个输入脚本都要和对应的输出脚本匹配之后再进行验证，如果全都验证通过，这个交易才是合法的</p>
<h4 id="比特币脚本的几种形式"><a href="#比特币脚本的几种形式" class="headerlink" title="比特币脚本的几种形式"></a>比特币脚本的几种形式</h4><p>一、ee</p>
<p><img src="/2020/09/02/%E5%8C%BA%E5%9D%97%E9%93%BE/%E6%AF%94%E7%89%B9%E5%B8%81%E8%84%9A%E6%9C%AC/QQ%E6%88%AA%E5%9B%BE20200902211305.png"> 这个签名是用私钥，对整个交易的签名，注意：input script实在我要花这个钱的时候的输出，所以签名是收款人的私钥的签名。（而不是付款人的私钥的签名）</p>
<p>①把输入脚本的签名压入栈</p>
<p><img src="/2020/09/02/%E5%8C%BA%E5%9D%97%E9%93%BE/%E6%AF%94%E7%89%B9%E5%B8%81%E8%84%9A%E6%9C%AC/QQ%E6%88%AA%E5%9B%BE20200902211520.png"></p>
<p>②把输出脚本的收款人的公钥压入栈</p>
<p><img src="/2020/09/02/%E5%8C%BA%E5%9D%97%E9%93%BE/%E6%AF%94%E7%89%B9%E5%B8%81%E8%84%9A%E6%9C%AC/QQ%E6%88%AA%E5%9B%BE20200902211603.png"></p>
<p>③执行CHECKSIG，用PubKey（那么这个）检查Sig是否正确，如果为true，则合法</p>
<p><img src="/2020/09/02/%E5%8C%BA%E5%9D%97%E9%93%BE/%E6%AF%94%E7%89%B9%E5%B8%81%E8%84%9A%E6%9C%AC/QQ%E6%88%AA%E5%9B%BE20200902211801.png"></p>
<p>二、</p>
<p><img src="/2020/09/02/%E5%8C%BA%E5%9D%97%E9%93%BE/%E6%AF%94%E7%89%B9%E5%B8%81%E8%84%9A%E6%9C%AC/QQ%E6%88%AA%E5%9B%BE20200902212706.png"></p>
<p><img src="/2020/09/02/%E5%8C%BA%E5%9D%97%E9%93%BE/%E6%AF%94%E7%89%B9%E5%B8%81%E8%84%9A%E6%9C%AC/QQ%E6%88%AA%E5%9B%BE20200902213056.png"></p>
<p><img src="/2020/09/02/%E5%8C%BA%E5%9D%97%E9%93%BE/%E6%AF%94%E7%89%B9%E5%B8%81%E8%84%9A%E6%9C%AC/QQ%E6%88%AA%E5%9B%BE20200902213129.png"></p>
<p><img src="/2020/09/02/%E5%8C%BA%E5%9D%97%E9%93%BE/%E6%AF%94%E7%89%B9%E5%B8%81%E8%84%9A%E6%9C%AC/QQ%E6%88%AA%E5%9B%BE20200902213225.png"></p>
<p><img src="/2020/09/02/%E5%8C%BA%E5%9D%97%E9%93%BE/%E6%AF%94%E7%89%B9%E5%B8%81%E8%84%9A%E6%9C%AC/QQ%E6%88%AA%E5%9B%BE20200902213253.png"></p>
<p><img src="/2020/09/02/%E5%8C%BA%E5%9D%97%E9%93%BE/%E6%AF%94%E7%89%B9%E5%B8%81%E8%84%9A%E6%9C%AC/QQ%E6%88%AA%E5%9B%BE20200902213338.png"></p>
<p>下面这个hash是你要花这个钱的时候，在输入脚本里给出的公钥</p>
<p><img src="/2020/09/02/%E5%8C%BA%E5%9D%97%E9%93%BE/%E6%AF%94%E7%89%B9%E5%B8%81%E8%84%9A%E6%9C%AC/QQ%E6%88%AA%E5%9B%BE20200902214127.png"></p>
<p><img src="/2020/09/02/%E5%8C%BA%E5%9D%97%E9%93%BE/%E6%AF%94%E7%89%B9%E5%B8%81%E8%84%9A%E6%9C%AC/QQ%E6%88%AA%E5%9B%BE20200902214623.png"></p>
<p>P2PK是最常用的脚本形式！</p>
<p>三、</p>
<p><img src="/2020/09/02/%E5%8C%BA%E5%9D%97%E9%93%BE/%E6%AF%94%E7%89%B9%E5%B8%81%E8%84%9A%E6%9C%AC/QQ%E6%88%AA%E5%9B%BE20200902214832.png"></p>
<p>输出脚本给出的不是收款人的公钥的哈希，而是收款人给出的一个脚本的哈希，redeemScript（赎回脚本），将来花这个钱的时候，输入脚本需要给出redeemScript的具体内容，同时还要给出让这个赎回脚本能够顺利运行所需要的签名</p>
<p><img src="/2020/09/02/%E5%8C%BA%E5%9D%97%E9%93%BE/%E6%AF%94%E7%89%B9%E5%B8%81%E8%84%9A%E6%9C%AC/QQ%E6%88%AA%E5%9B%BE20200902215249.png"></p>
<p>验证分为两步：</p>
<p>①验证输入脚本里给出的redeemScript（赎回脚本）是不是跟输出脚本里给出的哈希值匹配，如果不匹配的话，那么说明给出的赎回脚本是不对的，就类似于P2PKH给出的公钥不对一样，那么验证就失败了；</p>
<p>如果赎回脚本是正确的，那么第二步还要把赎回脚本的内容当作操作指令来执行一遍，看看最后能不能顺利执行，如果两部验证都通过了，那么这个交易才是合法的。</p>
<p><img src="/2020/09/02/%E5%8C%BA%E5%9D%97%E9%93%BE/%E6%AF%94%E7%89%B9%E5%B8%81%E8%84%9A%E6%9C%AC/QQ%E6%88%AA%E5%9B%BE20200902215724.png"></p>
<p>这里的输入脚本就是给出签名，再给出序列化的赎回脚本</p>
<p>赎回脚本的内容就是给出公钥之后，用CHECKSIG检查签名</p>
<p>下面这个输出脚本是用来验证输入脚本给出的赎回脚本是否正确</p>
<p>验证过程：</p>
<p>①②</p>
<p><img src="/2020/09/02/%E5%8C%BA%E5%9D%97%E9%93%BE/%E6%AF%94%E7%89%B9%E5%B8%81%E8%84%9A%E6%9C%AC/QQ%E6%88%AA%E5%9B%BE20200902220031.png"></p>
<p>③</p>
<p><img src="/2020/09/02/%E5%8C%BA%E5%9D%97%E9%93%BE/%E6%AF%94%E7%89%B9%E5%B8%81%E8%84%9A%E6%9C%AC/QQ%E6%88%AA%E5%9B%BE20200902220119.png"></p>
<p>④</p>
<p><img src="/2020/09/02/%E5%8C%BA%E5%9D%97%E9%93%BE/%E6%AF%94%E7%89%B9%E5%B8%81%E8%84%9A%E6%9C%AC/QQ%E6%88%AA%E5%9B%BE20200902220214.png"></p>
<p>⑤</p>
<p><img src="/2020/09/02/%E5%8C%BA%E5%9D%97%E9%93%BE/%E6%AF%94%E7%89%B9%E5%B8%81%E8%84%9A%E6%9C%AC/QQ%E6%88%AA%E5%9B%BE20200902220310.png"></p>
<p>至此，第一个阶段的验证就到这里结束了，现在进入第二阶段的验证。</p>
<p>第二个阶段首先要把输入脚本里提供的序列化的赎回脚本进行反序列化（序列化才能去哈希，我是这样理解的，如果有什么不对的地方，欢迎再下方评论给我留言！），反序列化的操作是每个结点自己要完成的，然后执行这个被反序列化之后的赎回脚本（反序列化之后就可以执行了，相当于解压）</p>
<p><img src="/2020/09/02/%E5%8C%BA%E5%9D%97%E9%93%BE/%E6%AF%94%E7%89%B9%E5%B8%81%E8%84%9A%E6%9C%AC/QQ%E6%88%AA%E5%9B%BE20200902220405.png"></p>
<p>将PubKey压入栈，之后CHECKSIG</p>
<p><img src="/2020/09/02/%E5%8C%BA%E5%9D%97%E9%93%BE/%E6%AF%94%E7%89%B9%E5%B8%81%E8%84%9A%E6%9C%AC/QQ%E6%88%AA%E5%9B%BE20200902220727.png"></p>
<p>那么这种P2SH的方式有什么好处呢？为什么要搞这么复杂？为什么要把这一部分功能嵌入到赎回脚本里面？</p>
<blockquote>
<p>确实，对这个简单的例子来讲，确实有点复杂了，P2SH在最初版本的比特币中是没有的，后来通过软分叉的形式加进去的，它的一个常见的应用场景就是对<strong>多重签名</strong>的支持。一个输出，可能需要多个签名，才能把钱取出来。</p>
<p>比如某个公司的账户，可能要求五个合伙人中，任意三个人的签名，才能把账上的钱取走，为私钥的泄露提供了一些安全的保护。同时也为私钥的丢失，提供了冗余。</p>
</blockquote>
<p>输出脚本给出的M，对应需要多少人的私钥才能匹配，CHECKMULTISIG操作对应匹配操作</p>
<p>输入脚本中第一行的×：比特币中CHECKMULTISIG的实现有一个bug（执行的时候会从堆栈上多弹出一个元素），这个bug现在已经没有办法改了，去中心化的系统，升级软件带来的代价是很大的，要改的话需要硬分叉，所以解决方案是，往栈上多压入一个没用的元素。</p>
<p>另外输入脚本的M个签名的顺序要对应N个公钥的顺序</p>
<p><img src="/2020/09/02/%E5%8C%BA%E5%9D%97%E9%93%BE/%E6%AF%94%E7%89%B9%E5%B8%81%E8%84%9A%E6%9C%AC/QQ%E6%88%AA%E5%9B%BE20200904192209.png"></p>
<p><img src="/2020/09/02/%E5%8C%BA%E5%9D%97%E9%93%BE/%E6%AF%94%E7%89%B9%E5%B8%81%E8%84%9A%E6%9C%AC/QQ%E6%88%AA%E5%9B%BE20200904192224.png"></p>
<p>一次压入栈，看看栈中是否有两个对应的签名，如果有的话，验证通过</p>
<p><img src="/2020/09/02/%E5%8C%BA%E5%9D%97%E9%93%BE/%E6%AF%94%E7%89%B9%E5%B8%81%E8%84%9A%E6%9C%AC/QQ%E6%88%AA%E5%9B%BE20200904192304.png"></p>
<p>注意，这个过程并没有使用P2SH(早期的多重签名只是使用CHECKMULTISTG的方式来实现)</p>
<p>如果是在网上购物的话，用户再转账的时候就需要传给电商公司对应的N个公钥和M的值，这个N个公钥的值和M会在电商网站上公布出来，用户可以相应地填入（每个电商网站可能都不太一样），这样就给用户交易带来了一些不方便的地方（因为这些复杂性都暴露给用户了）。</p>
<p>那么怎么办呢？</p>
<blockquote>
<p>就需要用到P2SH，它的本质是把复杂度从输出脚本转移到了输入脚本</p>
</blockquote>
<p><img src="/2020/09/02/%E5%8C%BA%E5%9D%97%E9%93%BE/%E6%AF%94%E7%89%B9%E5%B8%81%E8%84%9A%E6%9C%AC/QQ%E6%88%AA%E5%9B%BE20200904193001.png"></p>
<p>复杂度被转移到了redeemScript（赎回脚本由输入脚本提供），输出脚本只需要给出赎回脚本的哈希就可以了，用户只需要知道赎回脚本的哈希值</p>
<p>执行阶段一、</p>
<p><img src="/2020/09/02/%E5%8C%BA%E5%9D%97%E9%93%BE/%E6%AF%94%E7%89%B9%E5%B8%81%E8%84%9A%E6%9C%AC/QQ%E6%88%AA%E5%9B%BE20200904193524.png"></p>
<p><img src="/2020/09/02/%E5%8C%BA%E5%9D%97%E9%93%BE/%E6%AF%94%E7%89%B9%E5%B8%81%E8%84%9A%E6%9C%AC/QQ%E6%88%AA%E5%9B%BE20200904193544.png"></p>
<p><img src="/2020/09/02/%E5%8C%BA%E5%9D%97%E9%93%BE/%E6%AF%94%E7%89%B9%E5%B8%81%E8%84%9A%E6%9C%AC/QQ%E6%88%AA%E5%9B%BE20200904193708.png"></p>
<p><img src="/2020/09/02/%E5%8C%BA%E5%9D%97%E9%93%BE/%E6%AF%94%E7%89%B9%E5%B8%81%E8%84%9A%E6%9C%AC/QQ%E6%88%AA%E5%9B%BE20200904193739.png"></p>
<p><img src="/2020/09/02/%E5%8C%BA%E5%9D%97%E9%93%BE/%E6%AF%94%E7%89%B9%E5%B8%81%E8%84%9A%E6%9C%AC/QQ%E6%88%AA%E5%9B%BE20200904193844.png"></p>
<p>执行阶段二、</p>
<p>把赎回脚本展开后执行</p>
<p><img src="/2020/09/02/%E5%8C%BA%E5%9D%97%E9%93%BE/%E6%AF%94%E7%89%B9%E5%B8%81%E8%84%9A%E6%9C%AC/QQ%E6%88%AA%E5%9B%BE20200904193944.png"></p>
<p><img src="/2020/09/02/%E5%8C%BA%E5%9D%97%E9%93%BE/%E6%AF%94%E7%89%B9%E5%B8%81%E8%84%9A%E6%9C%AC/QQ%E6%88%AA%E5%9B%BE20200904194013.png"></p>
<p>第二阶段的验证和前面直接使用CHECKMULTISIG的情况是类似的</p>
<p><img src="/2020/09/02/%E5%8C%BA%E5%9D%97%E9%93%BE/%E6%AF%94%E7%89%B9%E5%B8%81%E8%84%9A%E6%9C%AC/QQ%E6%88%AA%E5%9B%BE20200904194115.png"></p>
<h4 id="Proof-of-Burn"><a href="#Proof-of-Burn" class="headerlink" title="Proof of Burn"></a>Proof of Burn</h4><p><img src="/2020/09/02/%E5%8C%BA%E5%9D%97%E9%93%BE/%E6%AF%94%E7%89%B9%E5%B8%81%E8%84%9A%E6%9C%AC/QQ%E6%88%AA%E5%9B%BE20200904194329.png"></p>
<p>比较特殊，输出脚本的开头是RETURN操作，后面可以跟任意的内容，RETURN这个操作的内容是无条件的返回错误，所以包含这个操作的脚本永远不可能通过验证，执行到RETURN这个语句就结束了，后面的内容根本没有机会执行</p>
<p>为什么要设置这样的输出脚本？</p>
<blockquote>
<p>这里的钱不是会永远花不出去？这个脚本是证明销毁比特币的一种方法，为什么要销毁？</p>
<p>这个一般是两种应用场景：</p>
<p>①一些小的币种，要求销毁一定数量的比特币才能够得到这个币种，有时候我们管这种小币种叫做AltCoin（Alternative Coin），有的小币种，可能要求你销毁一个比特币，可以得到1000个这样的小币，也就是说，你需要用Proof of Burn这种方法证明你付出了一定的代价，才能够得到这种小币种。</p>
<p>②往区块链里写入一些内容，我们说区块链是个不可篡改的账本，那么有人就利用这种特性，往里面添加一些需要永久保存的内容，你要证明在某个时间知道某些事情，比如说涉及到知识产权保护的，把某项知识产权的内容去哈希之后，把哈希值放在RETURN语句的后面，这个语句后面的内容反正是永远不会被执行的，写什么都没关系，不会占用太大的空间，也不会泄露知识产权的内容，将来如果出现了知识产权的纠纷，那么你再把这个记录的知识产权公布出去，证明你在某个时间点已经知道了某个知识了。</p>
</blockquote>
<p>注意：Proof of Burn这种方法所有节点都可以使用，而CoinBase 里的 coinbase transaction域只有获得记账权的节点才能使用，任何用户都可以销毁一点比特币，换取向这个区块链里写入内容的机会。甚至有点交易都没有销毁比特币，只是消耗了交易费。</p>
<p>有一点需要注意，图片中的交易为了简单起见，都没有写OP前缀，比如OP_CHECKSIG</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>比特币系统中使用的脚本语言是非常简单的（比特币的脚本语言不支持循环），甚至连专门的名字都没有。虽然在某些方法功能有限，但是在另外一些方面功能却很强大，就是和密码学相关的功能是很强大的，比如CHECKMULITSIG用一条语句就可以完成。</p>
]]></content>
      <categories>
        <category>区块链</category>
      </categories>
      <tags>
        <tag>区块链</tag>
      </tags>
  </entry>
  <entry>
    <title>BTC一---密码学基础</title>
    <url>/2020/08/29/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%AF%86%E7%A0%81%E5%AD%A6%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h1 id="密码学基础"><a href="#密码学基础" class="headerlink" title="密码学基础"></a>密码学基础</h1><h1 id="1-哈希"><a href="#1-哈希" class="headerlink" title="1.哈希"></a>1.哈希</h1><p>​    比特币属于加密货币，但是区块链上所有的交易都是公开的，包括账户的地址，转账的金额。</p>
<p>比特币用到了密码学的两个内容：哈希和签名</p>
<p>哈希在比特币中：<code>cryptographic hash function</code></p>
<p>它在密码学中要求的两个性质：</p>
<p>​    ①<code>collision</code>（哈希碰撞） 和<code> resistance</code>：没有什么高效的方法人为的制造哈希碰撞，</p>
<p>​        解释为对于一个x，没有什么高效的办法，找到另一个y，使<code>H(x) = H(y)</code>。</p>
<p>​        用法：对于一个m，哈希值为H(m),没有办法篡改内容，而又不被检测出来，因为找不到另外一个m’，使得<code>H(m) = H(m&#39;)</code>。</p>
<p>​        在理论上，这个性质是证明不出来的，只能依靠实际的经验 例如：md5，我们以前没有办法找到制造哈希碰撞的办法，然而现在却可以。</p>
<a id="more"></a>

<p><img src="/2020/08/29/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%AF%86%E7%A0%81%E5%AD%A6%E5%8E%9F%E7%90%86/QQ%E6%88%AA%E5%9B%BE20200730213309.png"></p>
<p>  如果我们有一个256位的哈希值，他的输出空间就为2^256，但是输入空间是无限的，根据鸽笼原理（抽屉原理），必然会导致哈希碰撞。</p>
<p>②<code>hiding</code>:哈希函数的计算过程是单向的，不可逆的,x可以计算得到H(x),但是H(x)计算不出x，也就是说，H(x)哈希值没有泄漏x的信息。</p>
<p>这个性质的前提是，x的输入范围要足够的大，使得蛮力，遍历破解的方法是不可行的，输入的分布还要比较均匀，各种取值的概率差不多。</p>
<p><img src="/2020/08/29/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%AF%86%E7%A0%81%E5%AD%A6%E5%8E%9F%E7%90%86/QQ%E6%88%AA%E5%9B%BE20200730215143.png"></p>
<p><img src="/2020/08/29/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%AF%86%E7%A0%81%E5%AD%A6%E5%8E%9F%E7%90%86/QQ%E6%88%AA%E5%9B%BE20200730215658.png"></p>
<p>将预测结果作为x,算出一个哈希值,将这个哈希值可以公布出去，因为有<code>hiding</code>的性质，只知道这个哈希值，是不能知道预测结果是什么的，在第二天收盘之后，再将预测值公布出去，因为存在<code>collision  resistance</code>的性质，这个预测结果是不可能的被篡改的，这就是一个<code>sealed envelope</code>的功能。</p>
<p>x—-&gt;H(x)</p>
<p><img src="/2020/08/29/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%AF%86%E7%A0%81%E5%AD%A6%E5%8E%9F%E7%90%86/QQ%E6%88%AA%E5%9B%BE20200730220318.png"></p>
<p>在实际操作中，不是直接对x取哈希值，而是再x后面加上一个<code>nonce</code>（随机数），保证x的随机性，和分布均匀</p>
<p>哈希函数除了在密码学中要求的这两个性质之外。</p>
<p>在比特币中还要求<code>puzzle friendly</code></p>
<p>哈希值的计算结果是不能被预测的，如果想要得到某个范围之间的哈希值，只能一个一个输入结果去试</p>
<p>那这个性质为什么叫<code>puzzle friendly</code>呢</p>
<blockquote>
<p>在比特币中的挖矿：实际上就是找一个nonce（随机数），这个nonce和区块的块头里的其他信息，合在一起，作为输入，取出一个哈希，这个哈希值要小于等于某个指定的目标阈值</p>
<p><img src="/2020/08/29/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%AF%86%E7%A0%81%E5%AD%A6%E5%8E%9F%E7%90%86/QQ%E6%88%AA%E5%9B%BE20200730221330.png"></p>
<p>比特币即区块链，区块链是一个一个区块组成的链表，每个区块有一个块头，块头中有很多的域，其中有一个域是我们可以设置的nonce，挖矿的过程就是不停地去试不同的随机数，使得整个块头取哈希值之后落在指定的范围之内（&lt;=target space）。</p>
<p>puzzle friendly 就是说挖矿的过程，没有捷径，只能靠不停地去试大量的nonce，才能找到符合要求的解，所以这个过程才可以被称为“<strong>工作量证明</strong>（proof of work）”，你找到了nonce，一定是你做了大量的工作，因为没有别的捷径。</p>
<p>虽然挖矿的过程需要大量的工作量，但是只要找到了符合要求的nonce，将这个nonce发布出去，其他人要验证这个nonce是很容易的，只要算一次哈希值就行了。这个就叫做“difficult to solve ，but easy to verify”。</p>
</blockquote>
<p>比特币中用到的哈希函数叫做SHA-256。</p>
<p>SHA:<code>secure Hash Algorithm</code> </p>
<p>我们上面所说的三个性质，他都是满足的</p>
<h1 id="2-签名"><a href="#2-签名" class="headerlink" title="2.签名"></a>2.签名</h1><p>  比特币账户中的账户管理，在日常生活中，可以去中心化的管理机构，比如银行办理手续，</p>
<p>但是在比特币中是去中心化的，那么怎么办理账户呢：每个用户自己决定开户 ，不需要任何人批准，</p>
<p>开户的过程很简单，就是创建一个公钥和私钥的对。</p>
<p><img src="/2020/08/29/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%AF%86%E7%A0%81%E5%AD%A6%E5%8E%9F%E7%90%86/QQ%E6%88%AA%E5%9B%BE20200730222824.png"></p>
<p>公私钥是来源于非对称加密体系：<code>asymmetric encryption algorithm</code>。</p>
<p>  最早的加密体系是对称的:<code>symmetric encryption algorithm</code>   —-&gt;两个人之间要进行通讯，但这个过程可能是被窃听的，所以我们两个人之间商量一个密钥，用来加密，发送信息，再用这个密钥来解密，因为这个加密和解密的密钥用的是同一个，所以被称为对称加密体系，这个前提是，有某种安全的渠道，可以把这个密钥分发给通讯的双方（这也是对称加密的一个弱点，密钥的分发不是很方便）</p>
<p><img src="/2020/08/29/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%AF%86%E7%A0%81%E5%AD%A6%E5%8E%9F%E7%90%86/QQ%E6%88%AA%E5%9B%BE20200730223101.png"></p>
<p>非对称加密：加密用公钥：<code>public key</code> ，解密用私钥:<code> private key</code>,我要把信息传给你，用你的公钥对信息加密，你收到信息，再用你的私钥解密，得到信息，需要注意的是，加密解密用的公钥私钥，都是接收方的，好处是什么？</p>
<blockquote>
<p>大家都可以知道我的公钥，都可以给我发消息，但是私钥是保存在本地的，不用传给对方，这就解决了对称加密过程，密钥分发带来的不方便的问题</p>
<p>所以比特币创建账户，就是在本地创建一个公钥私钥对，这个公钥就相当于银行账户，私钥相当于银行账户密码，知道私钥就可以把账户上的钱转走。</p>
</blockquote>
<p>  比特币虽然叫加密货币，但是其实他是不加密的，信息都是公开的，那我们要这个公钥私钥干嘛？</p>
<blockquote>
<p>实际上就是用来作签名，在我转比特币给另一个账户的时候，别人怎么知道是不是我转的，还是别人冒名顶替转的？</p>
<p>这个时候就需要我用私钥再这个信息上做一个签名，别人再用我的公钥验证我的私钥生成的签名</p>
<p>万一两个人创建的比特币账户的公私钥对相同怎么办？如果是256位的哈希，产生相同的公私钥对的概率是微乎其微的，</p>
<p>这个概率比地球爆炸的概率还要小！</p>
</blockquote>
<p>在生成比特币账户的公私钥的时候，假设前提是我们有一个好的随机源，如果随机源不好，那么这个时候还是有可能两个人的公私钥是相同的，其实不仅是生成账户的时候，在签名的时候也需要有好的随机源！</p>
<h1 id="3-总结"><a href="#3-总结" class="headerlink" title="3.总结"></a>3.总结</h1><p>  密码学中，两个功能，一个是哈希，一个是签名，这两个功能是可以结合起来使用的；</p>
<p>比特币系统中，一般是先对一个message取一个哈希，然后再对这个哈希值签名。</p>
]]></content>
      <categories>
        <category>区块链</category>
      </categories>
      <tags>
        <tag>区块链</tag>
      </tags>
  </entry>
</search>
