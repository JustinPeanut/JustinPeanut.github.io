<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>LOL-show项目工程日志</title>
    <url>/2020/08/30/Java/LOL-show%E9%A1%B9%E7%9B%AE%E5%B7%A5%E7%A8%8B%E6%97%A5%E5%BF%97/</url>
    <content><![CDATA[<h1 id="初衷"><a href="#初衷" class="headerlink" title="初衷"></a>初衷</h1><p>  在我学习完了ssm框架，以及跟着B站视频练习了一个<code>尚筹网</code>的项目之后，准备在暑假巩固所学的框架搭建过程，以及业务逻辑、数据库建表、前端页面的知识，本人喜欢打游戏，所以便有了LOL-show这个项目。</p>
<p>如果你想要学习该项目，那么你可以访问我的github！</p>
<a id="more"></a>

<h1 id="工程结构"><a href="#工程结构" class="headerlink" title="工程结构"></a>工程结构</h1><p><img src="/2020/08/30/Java/LOL-show%E9%A1%B9%E7%9B%AE%E5%B7%A5%E7%A8%8B%E6%97%A5%E5%BF%97/LOL-show-%E5%B7%A5%E7%A8%8B%E5%9B%BE.png"></p>
<p>端口号规定：</p>
<p>eureka:1000</p>
<p>zuul:80</p>
<p>mysql:2000</p>
<p>redis:3000</p>
<p>hero:4000</p>
<p>member:5000</p>
<p>market:6000</p>
<p>order:7000</p>
<p>pay:8000</p>
<h1 id="数据库建表语句"><a href="#数据库建表语句" class="headerlink" title="数据库建表语句"></a>数据库建表语句</h1><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> lol_area(</span><br><span class="line"><span class="keyword">id</span> <span class="built_in">int</span>(<span class="number">11</span>) auto_increment,</span><br><span class="line">area_name <span class="built_in">varchar</span>(<span class="number">100</span>) <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">primary <span class="keyword">key</span>(<span class="keyword">id</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> lol_area(area_name)</span><br><span class="line"> <span class="keyword">values</span></span><br><span class="line"> (<span class="string">&quot;比尔吉沃特&quot;</span>),</span><br><span class="line"> (<span class="string">&quot;德玛西亚&quot;</span>),</span><br><span class="line"> (<span class="string">&quot;弗雷尔卓德&quot;</span>),</span><br><span class="line"> (<span class="string">&quot;无畏先锋&quot;</span>),</span><br><span class="line"> (<span class="string">&quot;恕瑞玛&quot;</span>),</span><br><span class="line"> (<span class="string">&quot;扭曲丛林&quot;</span>),</span><br><span class="line"> (<span class="string">&quot;巨龙之巢&quot;</span>),</span><br><span class="line"> (<span class="string">&quot;艾欧尼亚&quot;</span>),</span><br><span class="line"> (<span class="string">&quot;祖安&quot;</span>),</span><br><span class="line"> (<span class="string">&quot;诺克萨斯&quot;</span>),</span><br><span class="line"> (<span class="string">&quot;班德尔城&quot;</span>),</span><br><span class="line"> (<span class="string">&quot;皮尔特沃夫&quot;</span>),</span><br><span class="line"> (<span class="string">&quot;皮尔特沃夫&quot;</span>),</span><br><span class="line"> (<span class="string">&quot;战争学院&quot;</span>),</span><br><span class="line"> (<span class="string">&quot;巨神峰&quot;</span>),</span><br><span class="line"> (<span class="string">&quot;雷瑟守备&quot;</span>),</span><br><span class="line"> (<span class="string">&quot;钢铁烈阳&quot;</span>),</span><br><span class="line"> (<span class="string">&quot;裁决之地&quot;</span>),</span><br><span class="line"> (<span class="string">&quot;黑色玫瑰&quot;</span>),</span><br><span class="line"> (<span class="string">&quot;暗影岛&quot;</span>),</span><br><span class="line"> (<span class="string">&quot;均衡教派&quot;</span>),</span><br><span class="line"> (<span class="string">&quot;水晶之痕&quot;</span>),</span><br><span class="line"> (<span class="string">&quot;影流&quot;</span>),</span><br><span class="line"> (<span class="string">&quot;守望之海&quot;</span>),</span><br><span class="line"> (<span class="string">&quot;征服之海&quot;</span>),</span><br><span class="line"> (<span class="string">&quot;卡拉曼达&quot;</span>),</span><br><span class="line"> (<span class="string">&quot;皮城警备&quot;</span>);</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">create</span> <span class="keyword">table</span> lol_member(</span><br><span class="line"> <span class="keyword">id</span> <span class="built_in">int</span>(<span class="number">11</span>) auto_increment,</span><br><span class="line"> user_name <span class="built_in">varchar</span>(<span class="number">100</span>),</span><br><span class="line"> role_name <span class="built_in">varchar</span>(<span class="number">100</span>),</span><br><span class="line"> age <span class="built_in">int</span>(<span class="number">11</span>),</span><br><span class="line"> <span class="keyword">password</span> <span class="built_in">varchar</span>(<span class="number">255</span>),</span><br><span class="line"> phone_num <span class="built_in">varchar</span>(<span class="number">100</span>),</span><br><span class="line"> area_id <span class="built_in">int</span>(<span class="number">100</span>),</span><br><span class="line"> primary <span class="keyword">key</span>(<span class="keyword">id</span>)</span><br><span class="line"> );</span><br><span class="line"> </span><br><span class="line"> <span class="comment">-- 用户计划表</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> lol_plan(</span><br><span class="line"><span class="keyword">id</span> <span class="built_in">int</span>(<span class="number">11</span>) auto_increment,</span><br><span class="line">plan_date <span class="built_in">varchar</span>(<span class="number">100</span>),</span><br><span class="line">plan_event <span class="built_in">varchar</span>(<span class="number">300</span>),</span><br><span class="line">last_time <span class="built_in">Integer</span>(<span class="number">11</span>),</span><br><span class="line">member_id <span class="built_in">Integer</span>(<span class="number">11</span>),</span><br><span class="line">primary <span class="keyword">key</span>(<span class="keyword">id</span>)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 英雄表</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> lol_hero(</span><br><span class="line"><span class="keyword">id</span> <span class="built_in">int</span>(<span class="number">11</span>) auto_increment,</span><br><span class="line">full_name <span class="built_in">varchar</span>(<span class="number">100</span>),</span><br><span class="line">nick_name <span class="built_in">varchar</span>(<span class="number">100</span>),</span><br><span class="line">back_story <span class="built_in">text</span>,</span><br><span class="line">price <span class="keyword">double</span>(<span class="number">5</span>,<span class="number">3</span>),</span><br><span class="line"><span class="comment">-- 英雄类型</span></span><br><span class="line">hero_type_id <span class="built_in">varchar</span>(<span class="number">100</span>),</span><br><span class="line"><span class="comment">-- 英雄页面小图</span></span><br><span class="line">img_small <span class="built_in">varchar</span>(<span class="number">300</span>),</span><br><span class="line">img_big <span class="built_in">varchar</span>(<span class="number">300</span>),</span><br><span class="line">img_scot <span class="built_in">varchar</span>(<span class="number">300</span>),</span><br><span class="line">img_stick <span class="built_in">varchar</span>(<span class="number">300</span>),</span><br><span class="line">text1 <span class="built_in">varchar</span>(<span class="number">255</span>),</span><br><span class="line">text2 <span class="built_in">varchar</span>(<span class="number">255</span>),</span><br><span class="line">primary <span class="keyword">key</span>(<span class="keyword">id</span>)</span><br><span class="line">)</span><br><span class="line"><span class="comment">-- 英雄类型表</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> lol_hero_type(</span><br><span class="line"><span class="keyword">id</span> <span class="built_in">int</span>(<span class="number">11</span>) auto_increment,</span><br><span class="line"><span class="keyword">type</span> <span class="built_in">varchar</span>(<span class="number">100</span>),</span><br><span class="line">primary <span class="keyword">key</span>(<span class="keyword">id</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 英雄位置表</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> lol_hero_position(</span><br><span class="line"><span class="keyword">id</span> <span class="built_in">int</span>(<span class="number">11</span>) auto_increment,</span><br><span class="line"><span class="keyword">position</span> <span class="built_in">varchar</span>(<span class="number">100</span>),</span><br><span class="line">primary <span class="keyword">key</span>(<span class="keyword">id</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 外键关联表（英雄和位置）</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> position_inner_hero(</span><br><span class="line"><span class="keyword">id</span> <span class="built_in">int</span>(<span class="number">11</span>) auto_increment,</span><br><span class="line">hero_id <span class="built_in">int</span>(<span class="number">11</span>),</span><br><span class="line">position_id <span class="built_in">int</span>(<span class="number">11</span>),</span><br><span class="line">primary <span class="keyword">key</span>(<span class="keyword">id</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h1 id="SpringBoot-pageHelper插件"><a href="#SpringBoot-pageHelper插件" class="headerlink" title="SpringBoot   pageHelper插件"></a>SpringBoot   pageHelper插件</h1><p>添加依赖</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;pagehelper-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.2.5&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p>用法：在需要分页的方法中启动分页，需要注意的是，分页的是在开启分页之后的第一个查询语句</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Transactional(readOnly = false,propagation = Propagation.REQUIRES_NEW,rollbackFor = Exception.class)</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> PageInfo <span class="title">getPagePlanVOList</span><span class="params">(Integer pageNum, Integer pageSize, Integer id)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 开启分页</span></span><br><span class="line">        PageHelper.startPage(pageNum,pageSize);</span><br><span class="line">        PlanPOExample example = <span class="keyword">new</span> PlanPOExample();</span><br><span class="line">        PlanPOExample.Criteria criteria = example.createCriteria();</span><br><span class="line">        criteria.andMemberIdEqualTo(id);</span><br><span class="line">        <span class="comment">// 执行查询</span></span><br><span class="line">        List&lt;PlanPO&gt; planPOList = planPOMapper.selectByExample(example);</span><br><span class="line">        <span class="comment">// 判断结果</span></span><br><span class="line">        <span class="keyword">if</span>(planPOList.size() == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UnKnowNetWorkException(<span class="string">&quot;没有查询到任何数据，快去添加计划吧！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 结果正确就返回</span></span><br><span class="line">        List&lt;PlanVO&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(PlanPO planPO : planPOList)&#123;</span><br><span class="line">            PlanVO planVO = <span class="keyword">new</span> PlanVO();</span><br><span class="line">            BeanUtils.copyProperties(planPO,planVO);</span><br><span class="line">            list.add(planVO);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 封装PageInfo对象</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> PageInfo(list);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>查询出来的list结果封装到PageInfo实例对象中</p>
<p>注意的是，在后台远程方法调用的时候，PageInfo的泛型并不是PageInfo&lt;List<xxx>&gt;</xxx></p>
<p>而是对应的JavaBean类型例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">PageInfo&lt;PlanVO&gt; <span class="title">getPagePlanVOList</span><span class="params">(Integer pageNum,Integer pageSize,Integer id)</span></span>;</span><br></pre></td></tr></table></figure>

<p>否则会报一个</p>
<p>pagehelper 返回前台的json转换异常com.fasterxml.jackson.databind.exc.Mismatch的异常</p>
<h1 id="使用了layui的日期插件"><a href="#使用了layui的日期插件" class="headerlink" title="使用了layui的日期插件"></a>使用了layui的日期插件</h1><p>点击输入框可以弹出日期选择框，如下图所示效果</p>
<p><img src="/2020/08/30/Java/LOL-show%E9%A1%B9%E7%9B%AE%E5%B7%A5%E7%A8%8B%E6%97%A5%E5%BF%97/QQ%E6%88%AA%E5%9B%BE20200804102439.png"></p>
<p>加入layui的css样式和js</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;layui/css/layui.css&quot;</span> <span class="attr">media</span>=<span class="string">&quot;all&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;layui/layui.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 添加日期插件</span></span><br><span class="line">layui.use(<span class="string">&#x27;laydate&#x27;</span>,<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 生成一个日期实例，这个实例变量名自己指定</span></span><br><span class="line">    <span class="keyword">var</span> laydate = layui.laydate;</span><br><span class="line">    <span class="comment">//执行一个laydate实例</span></span><br><span class="line">    laydate.render(&#123;</span><br><span class="line">        <span class="comment">// 指定在哪里生成日期控件</span></span><br><span class="line">        elem: <span class="string">&#x27;#dateText&#x27;</span>, <span class="comment">//指定元素</span></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h1 id="使用了谷歌Kaptcha-生成验证码插件"><a href="#使用了谷歌Kaptcha-生成验证码插件" class="headerlink" title="使用了谷歌Kaptcha 生成验证码插件"></a>使用了谷歌Kaptcha 生成验证码插件</h1><p>加入依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Google Kaptcha --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.penggle<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>kaptcha<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>相关的配置</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KaptchaConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DefaultKaptcha <span class="title">getDefaultKaptcha</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        com.google.code.kaptcha.impl.DefaultKaptcha defaultKaptcha = <span class="keyword">new</span> com.google.code.kaptcha.impl.DefaultKaptcha();</span><br><span class="line">        Properties properties = <span class="keyword">new</span> Properties();</span><br><span class="line">        <span class="comment">// 图片边框</span></span><br><span class="line">        properties.setProperty(<span class="string">&quot;kaptcha.border&quot;</span>, <span class="string">&quot;yes&quot;</span>);</span><br><span class="line">        <span class="comment">// 边框颜色</span></span><br><span class="line">        properties.setProperty(<span class="string">&quot;kaptcha.border.color&quot;</span>, <span class="string">&quot;105,179,90&quot;</span>);</span><br><span class="line">        <span class="comment">// 字体颜色</span></span><br><span class="line">        properties.setProperty(<span class="string">&quot;kaptcha.textproducer.font.color&quot;</span>, <span class="string">&quot;red&quot;</span>);</span><br><span class="line">        <span class="comment">// 图片宽</span></span><br><span class="line">        properties.setProperty(<span class="string">&quot;kaptcha.image.width&quot;</span>, <span class="string">&quot;110&quot;</span>);</span><br><span class="line">        <span class="comment">// 图片高</span></span><br><span class="line">        properties.setProperty(<span class="string">&quot;kaptcha.image.height&quot;</span>, <span class="string">&quot;40&quot;</span>);</span><br><span class="line">        <span class="comment">// 字体大小</span></span><br><span class="line">        properties.setProperty(<span class="string">&quot;kaptcha.textproducer.font.size&quot;</span>, <span class="string">&quot;30&quot;</span>);</span><br><span class="line">        <span class="comment">// session key</span></span><br><span class="line">        properties.setProperty(<span class="string">&quot;kaptcha.session.key&quot;</span>, <span class="string">&quot;code&quot;</span>);</span><br><span class="line">        <span class="comment">// 验证码长度</span></span><br><span class="line">        properties.setProperty(<span class="string">&quot;kaptcha.textproducer.char.length&quot;</span>, <span class="string">&quot;4&quot;</span>);</span><br><span class="line">        <span class="comment">// 字体</span></span><br><span class="line">        properties.setProperty(<span class="string">&quot;kaptcha.textproducer.font.names&quot;</span>, <span class="string">&quot;宋体,楷体,微软雅黑&quot;</span>);</span><br><span class="line"></span><br><span class="line">        properties.setProperty(<span class="string">&quot;kaptcha.noise.color&quot;</span>, <span class="string">&quot;35,37,38&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Config config = <span class="keyword">new</span> Config(properties);</span><br><span class="line">        defaultKaptcha.setConfig(config);</span><br><span class="line">        <span class="keyword">return</span> defaultKaptcha;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>controller代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/api/kaptcha&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestCode</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    DefaultKaptcha defaultKaptcha;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/defaultKaptcha&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">defaultKaptcha</span><span class="params">(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] captchaChallengeAsJpeg = <span class="keyword">null</span>;</span><br><span class="line">        ByteArrayOutputStream jpegOutputStream = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 生产验证码字符串并保存到session中</span></span><br><span class="line">            String createText = defaultKaptcha.createText();</span><br><span class="line">            System.out.println(createText);</span><br><span class="line">            httpServletRequest.getSession().setAttribute(<span class="string">&quot;verificationCode&quot;</span>, createText);</span><br><span class="line">            <span class="comment">// 使用生成的验证码字符串返回一个BufferedImage对象并转为byte写入到byte数组中</span></span><br><span class="line">            BufferedImage challenge = defaultKaptcha.createImage(createText);</span><br><span class="line">            ImageIO.write(challenge, <span class="string">&quot;jpg&quot;</span>, jpegOutputStream);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalArgumentException e) &#123;</span><br><span class="line">            httpServletResponse.sendError(HttpServletResponse.SC_NOT_FOUND);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 定义response输出类型为image/jpeg类型，使用response输出流输出图片的byte数组</span></span><br><span class="line">        captchaChallengeAsJpeg = jpegOutputStream.toByteArray();</span><br><span class="line">        httpServletResponse.setHeader(<span class="string">&quot;Cache-Control&quot;</span>, <span class="string">&quot;no-store&quot;</span>);</span><br><span class="line">        httpServletResponse.setHeader(<span class="string">&quot;Pragma&quot;</span>, <span class="string">&quot;no-cache&quot;</span>);</span><br><span class="line">        httpServletResponse.setDateHeader(<span class="string">&quot;Expires&quot;</span>, <span class="number">0</span>);</span><br><span class="line">        httpServletResponse.setContentType(<span class="string">&quot;image/jpeg&quot;</span>);</span><br><span class="line">        ServletOutputStream responseOutputStream = httpServletResponse.getOutputStream();</span><br><span class="line">        responseOutputStream.write(captchaChallengeAsJpeg);</span><br><span class="line">        responseOutputStream.flush();</span><br><span class="line">        responseOutputStream.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>前台显示</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">id</span>=<span class="string">&quot;verificationCodeImg&quot;</span> <span class="attr">src</span>=<span class="string">&quot;/api/kaptcha/defaultKaptcha&quot;</span> <span class="attr">style</span>=<span class="string">&quot;cursor: pointer;&quot;</span> <span class="attr">title</span>=<span class="string">&quot;看不清？换一张&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p>添加点击“看不清？换一张”的事件</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 刷新验证码</span></span><br><span class="line">            $(<span class="string">&quot;#verificationCodeImg&quot;</span>).bind(<span class="string">&quot;click&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                $(<span class="built_in">this</span>).hide().attr(<span class="string">&#x27;src&#x27;</span>, <span class="string">&#x27;http://localhost/api/kaptcha/defaultKaptcha?&#x27;</span>).fadeIn();</span><br><span class="line">            &#125;);</span><br></pre></td></tr></table></figure>

<p>效果图</p>
<p><img src="/2020/08/30/Java/LOL-show%E9%A1%B9%E7%9B%AE%E5%B7%A5%E7%A8%8B%E6%97%A5%E5%BF%97/QQ%E6%88%AA%E5%9B%BE20200804103206.png"></p>
<h1 id="改变文本输入框获取值"><a href="#改变文本输入框获取值" class="headerlink" title="改变文本输入框获取值"></a>改变文本输入框获取值</h1><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 为输入英雄名称的文本框绑定文本改变的事件</span></span><br><span class="line">            $(<span class="string">&quot;.inputSearch&quot;</span>).on(<span class="string">&quot;input&quot;</span>,<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="keyword">let</span> heroName = $(<span class="built_in">this</span>).val()</span><br><span class="line">            &#125;)</span><br></pre></td></tr></table></figure>

<h1 id="mybatis模糊查询的三种方式"><a href="#mybatis模糊查询的三种方式" class="headerlink" title="mybatis模糊查询的三种方式"></a>mybatis模糊查询的三种方式</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select id,name,age,score from star where name like &quot;%&quot; #&#123;name&#125; &quot;%&quot;</span><br><span class="line"></span><br><span class="line">&lt;!--concat拼接字符串  mysql独有的函数--&gt;</span><br><span class="line">select id,name,age,score from star where name like concat(&quot;%&quot;,#&#123;name&#125;,&quot;%&quot;)</span><br><span class="line"></span><br><span class="line">&lt;!-- 如果传入的参数是简单数据类型，$&#123;&#125;里面必须写value --&gt;</span><br><span class="line">select id,name,age,score from star where name like &quot;%$&#123;value&#125;%&quot;</span><br><span class="line"></span><br><span class="line">作者：叫我不矜持</span><br><span class="line">链接：https:&#x2F;&#x2F;www.jianshu.com&#x2F;p&#x2F;6d244e194859</span><br><span class="line">来源：简书</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>

<h1 id="thymeleaf循环的状态变量"><a href="#thymeleaf循环的状态变量" class="headerlink" title="thymeleaf循环的状态变量"></a>thymeleaf循环的状态变量</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">th:each属性用于迭代循环，语法：th:each&#x3D;&quot;obj,iterStat:$&#123;objList&#125;&quot;</span><br><span class="line">迭代对象可以是Java.util.List,java.util.Map,数组等;</span><br><span class="line">iterStat称作状态变量，属性有：</span><br><span class="line">    index:当前迭代对象的index（从0开始计算）</span><br><span class="line">    count: 当前迭代对象的index(从1开始计算)</span><br><span class="line">    size:被迭代对象的大小</span><br><span class="line">    current:当前迭代变量</span><br><span class="line">    even&#x2F;odd:布尔值，当前循环是否是偶数&#x2F;奇数（从0开始计算）</span><br><span class="line">    first:布尔值，当前循环是否是第一个</span><br><span class="line">    last:布尔值，当前循环是否是最后一个</span><br></pre></td></tr></table></figure>

<h1 id="mysql-根据拼音首字母查询"><a href="#mysql-根据拼音首字母查询" class="headerlink" title="mysql 根据拼音首字母查询"></a>mysql 根据拼音首字母查询</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT id,full_name ,</span><br><span class="line"></span><br><span class="line">ELT(INTERVAL(CONV(HEX(LEFT(CONVERT(full_name USING gbk),1)),16,10),</span><br><span class="line"></span><br><span class="line">0xB0A1,0xB0C5,0xB2C1,0xB4EE,0xB6EA,0xB7A2,0xB8C1,0xB9FE,0xBBF7,</span><br><span class="line"></span><br><span class="line">0xBFA6,0xC0AC,0xC2E8,0xC4C3,0xC5B6,0xC5BE,0xC6DA,0xC8BB,0xC8F6,</span><br><span class="line"></span><br><span class="line">0xCBFA,0xCDDA,0xCEF4,0xD1B9,0xD4D1),</span><br><span class="line"></span><br><span class="line">&#39;A&#39;,&#39;B&#39;,&#39;C&#39;,&#39;D&#39;,&#39;E&#39;,&#39;F&#39;,&#39;G&#39;,&#39;H&#39;,&#39;J&#39;,&#39;K&#39;,&#39;L&#39;,&#39;M&#39;,&#39;N&#39;,&#39;O&#39;,&#39;P&#39;,</span><br><span class="line"></span><br><span class="line">&#39;Q&#39;,&#39;R&#39;,&#39;S&#39;,&#39;T&#39;,&#39;W&#39;,&#39;X&#39;,&#39;Y&#39;,&#39;Z&#39;) AS PY</span><br><span class="line"></span><br><span class="line">FROM lol_hero WHERE ELT(INTERVAL(CONV(HEX(LEFT(CONVERT(full_name USING gbk),1)),16,10),</span><br><span class="line"></span><br><span class="line">0xB0A1,0xB0C5,0xB2C1,0xB4EE,0xB6EA,0xB7A2,0xB8C1,0xB9FE,0xBBF7,</span><br><span class="line"></span><br><span class="line">0xBFA6,0xC0AC,0xC2E8,0xC4C3,0xC5B6,0xC5BE,0xC6DA,0xC8BB,0xC8F6,</span><br><span class="line"></span><br><span class="line">0xCBFA,0xCDDA,0xCEF4,0xD1B9,0xD4D1),</span><br><span class="line"></span><br><span class="line">&#39;A&#39;,&#39;B&#39;,&#39;C&#39;,&#39;D&#39;,&#39;E&#39;,&#39;F&#39;,&#39;G&#39;,&#39;H&#39;,&#39;J&#39;,&#39;K&#39;,&#39;L&#39;,&#39;M&#39;,&#39;N&#39;,&#39;O&#39;,&#39;P&#39;,</span><br><span class="line"></span><br><span class="line">&#39;Q&#39;,&#39;R&#39;,&#39;S&#39;,&#39;T&#39;,&#39;W&#39;,&#39;X&#39;,&#39;Y&#39;,&#39;Z&#39;) &#x3D; &#39;A&#39;</span><br></pre></td></tr></table></figure>

<h1 id="部署项目"><a href="#部署项目" class="headerlink" title="部署项目"></a>部署项目</h1><h2 id="打包"><a href="#打包" class="headerlink" title="打包"></a>打包</h2><p>包含第三方jar包的工程的build</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">                第三方jar包目录</span><br><span class="line">                <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/resources/lib<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">targetPath</span>&gt;</span>BOOT-INF/lib/<span class="tag">&lt;/<span class="name">targetPath</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.jar<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/resources<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">targetPath</span>&gt;</span>BOOT-INF/classes/<span class="tag">&lt;/<span class="name">targetPath</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.1.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;maven-compiler-plugin.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">source</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">skip</span>&gt;</span>true<span class="tag">&lt;/<span class="name">skip</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">encoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">encoding</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">compilerArguments</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">extdirs</span>&gt;</span>$&#123;project.basedir&#125;/src/main/resources/lib<span class="tag">&lt;/<span class="name">extdirs</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">compilerArguments</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>其余的，如果依赖springboot父工程，加上</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.1.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如果不依赖任何工程，直接打包</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mvn clean install -Dmaven.test.skip=true // 忽略test</span><br></pre></td></tr></table></figure>

<h2 id="准备服务器环境"><a href="#准备服务器环境" class="headerlink" title="准备服务器环境"></a>准备服务器环境</h2><p>安装jdk</p>
<p>在/etc/profile文件的最后配置java环境</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">JAVA_HOME=/opt/sorftware/jdk1.8.0_251</span><br><span class="line">PATH=$PATH:$JAVA_HOME/bin</span><br><span class="line">export JAVA_HOME PATH</span><br></pre></td></tr></table></figure>

<p>安装mysql</p>
<p><a href="https://www.cnblogs.com/cannel/p/11104195.html">参考</a></p>
<p>缺少 libaio</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum install libaio</span><br></pre></td></tr></table></figure>

<p>修改密码需要设置密码的级别：注意！</p>
<p>授权远程连接</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GRANT ALL PRIVILEGES ON *.* TO &#39;root&#39;@&#39;%&#39; IDENTIFIED BY &#39;rootroot&#39; WITH GRANT OPTION;</span><br></pre></td></tr></table></figure>

<p>微服务远程调用报错找不到主机，因为我的redisServer以及mysqlServer在另一个服务器上，所以consumer想要调用这两个server的服务，必须找到我的另一个服务器，但是我发现服务器的名字没有使用ip地址，所以依照<code>参考</code>的调试最后成功了！</p>
<p>运行jar包</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nohup java -jar xxx.jar &gt;/dev/null 2&gt;&amp;1 &amp;</span><br></pre></td></tr></table></figure>



<p>报错：UnknownHostException</p>
<p><a href="https://blog.csdn.net/weixin_39032575/article/details/83011334?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param">参考</a></p>
]]></content>
      <categories>
        <category>项目</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>java随笔</title>
    <url>/2020/09/10/Java/java%E9%9A%8F%E7%AC%94/</url>
    <content><![CDATA[<p>  在学习的过程中，难免会碰到自己从未接触过的知识和技巧，有时候一边看过去会忘记，所以把它记录下来是最好的选择，而不是假装自己会了，又继续学习别的知识，这样的话，对后续的工作和学习都会带来一些不必要的麻烦。</p>
<p>  我自认为，在学习的时候，应该自己主动思考，如果这样的话，结果是怎么样，那样的话，结果是怎么样，我们在整个小学、初中、高中，甚至是大学，都被灌输了一种思想，就是，这样就是对的，那么当我们碰到问题的时候，往往就会一头雾水，不知如何下手，如果有主动思考的能力的话，这种问题是不是就会没有那么棘手呢？</p>
<a id="more"></a>

<p>2020.9.10</p>
<p>在阅读《疯狂java讲义》一书中HashMap的介绍，书中实例HashMap类实例的put方法，发现他有一个返回值，并且是Object类型的，这我就纳闷了，添加元素，一般不是返回true就是false啊？我在一篇博客的评论下发现了答案，原来是</p>
<blockquote>
<p>如果此前存在一个相同的key，那么put方法返回的是前面key的value值，这时候后来put的value就会覆盖前面put进去的值；如果当前put方法，put的是一个新的key，那么返回值就是null。</p>
</blockquote>
<p>2020.9.14</p>
<p>关于将线程不安全的HashSet、HashMap、ArrayList类转化成线程安全的类的介绍中</p>
<p>使用Collections.synchronizeXXX</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Person&gt; allList = Collections.synchronizedList(<span class="keyword">new</span> ArrayList());</span><br><span class="line"> Iterator&lt;Integer&gt; iterator = allList .iterator();</span><br><span class="line">	 <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">		 Integer integer = (Integer) iterator.next();</span><br><span class="line">		 System.out.println(integer);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>如上所示：因为迭代器不是线程安全的，所以还需要同步allList，使获得迭代器的过程也是同步的，这样在操作同步后的集合在遍历的时候就被锁住，不能在进行别的操作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Person&gt; allList = Collections.synchronizedList(<span class="keyword">new</span> ArrayList());</span><br><span class="line"><span class="keyword">synchronized</span>（allList ）&#123;</span><br><span class="line">	Iterator&lt;Integer&gt; iterator = allList .iterator();</span><br><span class="line">	<span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">		Integer integer = (Integer) iterator.next();</span><br><span class="line">		System.out.println(integer);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>











]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>CCF一---202006</title>
    <url>/2020/08/29/ccf/202006/</url>
    <content><![CDATA[<h1 id="线性分类器"><a href="#线性分类器" class="headerlink" title="线性分类器"></a>线性分类器</h1><img src="/2020/08/29/ccf/202006/线性分类器(1).png" style="zoom:75%;">

<a id="more"></a>

<img src="/2020/08/29/ccf/202006/线性分类器(2).png" style="zoom:75%;">

<img src="/2020/08/29/ccf/202006/线性分类器(3).png" style="zoom:75%;">

<p>​    思路：读完题目发现，是有关直线和点的分布问题，所以首先想到将点代入原直线方程，如果得到的结果大于0，那么这个点就在直线的上方，反之在下方，按照这个思路，就可以去写代码了。</p>
<p>​    数据结构：考虑到每个点有x坐标（int）、y坐标（int）和类型（String），集合以及数组都不是很好存放point的数据，所以我这里使用Node类存储每个point，然后使用List类型来存放所有的点，使用一个二位数组存放直线的z、x以及y。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x;</span><br><span class="line">        <span class="keyword">int</span> y;</span><br><span class="line">        String type;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>​    初始化用来存储的过程就不用多说，最主要的思路就在于如果计算，因为在原输入中已经给出了是‘A’类型还是‘B’类型，所以在计算之后要判断一下，并且设置一个总的标记<code>flag</code>，和两个A、B的标记<code>flagA</code>、<code>flagB</code>。只要不满足要求（当有两个同类型的点不在同一边）<code>flag</code>就设为false，结束循环，如果满足就一直进行下去，最后，如果<code>flag</code>为true，仍要判断<code>flagA</code>和<code>flagB</code>是否相等，如果相等，仍然不满足要求，输出No。</p>
<p>以下就是我写的代码（测试为100分）:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x;</span><br><span class="line">        <span class="keyword">int</span> y;</span><br><span class="line">        String type;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">int</span> n = scanner.nextInt();</span><br><span class="line">        <span class="keyword">int</span> m = scanner.nextInt();</span><br><span class="line">        List&lt;Node&gt; points = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">// 初始化所有的点的集合</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; n ; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> x = scanner.nextInt();</span><br><span class="line">            <span class="keyword">int</span> y = scanner.nextInt();</span><br><span class="line">            String type = scanner.next();</span><br><span class="line">            Node node = <span class="keyword">new</span> Node();</span><br><span class="line">            node.x = x;</span><br><span class="line">            node.y = y;</span><br><span class="line">            node.type = type;</span><br><span class="line">            points.add(node);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> [][] line = <span class="keyword">new</span> <span class="keyword">int</span>[m][<span class="number">3</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; m ; i++)&#123;</span><br><span class="line">            line[i][<span class="number">0</span>] = scanner.nextInt();</span><br><span class="line">            line[i][<span class="number">1</span>] = scanner.nextInt();</span><br><span class="line">            line[i][<span class="number">2</span>] = scanner.nextInt();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; m ; i++)&#123;</span><br><span class="line">            <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">int</span> flagA = -<span class="number">1</span> , flagB = -<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> z = line[i][<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> x = line[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">int</span> y = line[i][<span class="number">2</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; n ; j++)&#123;</span><br><span class="line">                Node node = points.get(j);</span><br><span class="line">                <span class="comment">// 大于零说明在这条直线上方</span></span><br><span class="line">                <span class="keyword">int</span> t = (z + node.x*x + node.y*y) &gt; <span class="number">0</span> ? <span class="number">1</span>: <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span>(node.type.equals(<span class="string">&quot;A&quot;</span>) )&#123;</span><br><span class="line">                    <span class="keyword">if</span>(flagA == -<span class="number">1</span>)&#123;</span><br><span class="line">                        <span class="comment">// 初始化A类的flag</span></span><br><span class="line">                        flagA = t;</span><br><span class="line">                    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (flagA != t)&#123;</span><br><span class="line">                        flag = <span class="keyword">false</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span> (node.type.equals(<span class="string">&quot;B&quot;</span>))&#123;</span><br><span class="line">                    <span class="keyword">if</span> (flagB == -<span class="number">1</span>)&#123;</span><br><span class="line">                        flagB = t;</span><br><span class="line">                    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(flagB != t)&#123;</span><br><span class="line">                        flag = <span class="keyword">false</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(flag &amp;&amp; flagA != flagB)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Yes&quot;</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;No&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>CCF</tag>
      </tags>
  </entry>
  <entry>
    <title>ETH十一---反思</title>
    <url>/2020/12/02/%E5%8C%BA%E5%9D%97%E9%93%BE/ETH%E5%8F%8D%E6%80%9D/</url>
    <content><![CDATA[<h1 id="反思"><a href="#反思" class="headerlink" title="反思"></a>反思</h1><p>​    回顾The DAO事件，应该引起什么样的反思？</p>
<a id="more"></a>

<h2 id="关于智能合约的反思"><a href="#关于智能合约的反思" class="headerlink" title="关于智能合约的反思"></a>关于智能合约的反思</h2><p>​    Is smart contract really smart？</p>
<blockquote>
<p>智能合约里并没有用到人工智能的技术，有人认为其实应该把它叫做自动合约，按照实现编写的代码，自动执行某些操作，我们现实世界当中，例如ATM取款机可以看作物理世界的一个自动合约，你把银行卡插进去，输入密码，他就把钱吐给你。所以智能合约其实并不只能，其实挺笨的，一旦写好之后就改不了了，实际上一种代码合同，这个可以作为第一个反思。</p>
</blockquote>
<p>​    smart contract is anything but smart.</p>
<p>​    智能合约写好之后就不能篡改了，这就涉及到了区块链的不可篡改性，一般来说，提到不可篡改性，是区块链的一个优点，有很多区块链的应用都是应用了区块链的不可篡改性，比如说用它来做，防伪、溯源，但是通过The DAO事件，我们应该意识到，不可篡改性，其实是一个双刃剑。</p>
<p>​    Irrevocability is a double edged sword.</p>
<blockquote>
<p>一方面来说，不可篡改性增加了合约的公信力，我们大家都只能按照合约中的规则中来，没有人可以篡改这个规则，这是好的一方面，但是另一方面，不可篡改性也意味着规则中有漏洞，我们想要修补这个漏洞都是很困难的。</p>
</blockquote>
<p>​    软件升级必须硬分叉，不想现实世界中，发布一个一个的patch，对于比特币也好，以太坊也好，硬分叉都不是随便搞的，像这次以太坊的硬分叉，最后就造成了两条平行的链，而且你要硬分叉的话，你要说明理由，一旦说明理由，就有可能把系统漏洞的信息泄漏出去，有恶意的攻击者可能会在还没有来得及升级软件之前抢先发动攻击，这些都是区块链上不可篡改性带来的一些问题，另外，即使已经发现恶意漏洞，有人已经进行攻击了，想要冻结账户，终止交易都是很困难的，这个也是和我们日常生活的体现不太一样的。如果你发现你的私钥泄漏了，这时候不是想着怎么冻结账户，而是把剩下的以太币转移到另外一个安全的账户上去。</p>
<p>​    与之相关的问题，智能合约发布到区块链上去之后，没有办法阻止对他的调用，比如说这次的盗币事件，黑客偷走了1/3的以太币，还有2/3的以太币是在The DAO这个智能合约以及它的子基金里面，同样存在着安全的风险，这样的想法是，既然这个智能合约存在问题，就不能让别人去调用它了，但是区块链上没有办法阻止，要阻止的话，就必须软分叉（增加一个规则，调用这个智能合约的交易都不予执行）。如果你是一个The DAO的用户，你应该怎么办？马上通知以太坊团队这是对的，还能做什么？其实和私钥泄漏的情况是一样的，你应该在第一时间把剩下的2/3的钱转到一个安全的账户：用黑客的漏洞把钱转走。 </p>
<p>​    Nothing is irrevocable.</p>
<p>​    有什么是真的不可篡改的，其实都可以改，我们前面说的比较多的是分叉攻击的例子，比如说有一笔交易本来是写在区块链里面，然后有一个黑客，从这个区块前面进行分叉，后面的交易被回滚，以太坊的The DAO事件，实际上是用软件升级的方法强行改变某些账户的状态，不要迷信区块链的不可篡改性。</p>
<h2 id="语言设计上的反思"><a href="#语言设计上的反思" class="headerlink" title="语言设计上的反思"></a>语言设计上的反思</h2><p>​    为什么会出现重入攻击这样的事情？从某种意义上说，solidity这种语言是“反自然”的，我们一般的理解是我给你转账，你是一个被动的接受者，你不可能再回来调用我，但是solidity语言的特点是，我给你转账，等于是隐性地调用了你的fallback函数，虽然表面上我没有调用任何函数，但是转账本身就是调用了你的fallback函数，接着你可以调用我，这个和我们平时的生活体验不太一样，所以就可能忽视这样一个安全漏洞。有的人提出，干脆使用函数式编程语言，函数式编程语言不容易出现这样的漏洞，而且从长远来看，要实现的是证明智能合约功能的正确性。</p>
<p>​    Is solidity the right programming language?</p>
<blockquote>
<p>编写智能合约的语言应该具有什么样的表达能力，比特币的脚本语言是很简单的，表达能力很差，而以太坊的编程语言，叫图灵完备的，凡是计算机程序能够完成的任务，solidity能够实现。但是这种图灵完备的表达能力是不是一个好事情。</p>
</blockquote>
<p>​    出现智能合约的漏洞之后，有些人认为，应该去选取一种表达能力适中的语言，不能像比特币脚本语言的表达能力太弱，也不要像以太坊的solidity一样，表达能力是图灵完备的：可以实现智能合约要实现的功能，但是又不容易出现安全漏洞。</p>
<p>​    设计的语言很难预料到将来可能出现的应用场景，也很难预料到将来可能出现的所有安全攻击，所以这么设计是很难设计出来的，包括比特币脚本，虽然简单，但是实际应用当中，大多数矿工也只是接受几个常用的脚本，有一个安全脚本的白名单（white list），如果脚本不在白名单里面，很多矿工缺省情况下是不接受的。</p>
]]></content>
      <categories>
        <category>区块链</category>
      </categories>
      <tags>
        <tag>区块链</tag>
      </tags>
  </entry>
  <entry>
    <title>ETH四---交易树和收据树</title>
    <url>/2020/10/12/%E5%8C%BA%E5%9D%97%E9%93%BE/%E4%BA%A4%E6%98%93%E6%A0%91%E5%92%8C%E6%94%B6%E6%8D%AE%E6%A0%91/</url>
    <content><![CDATA[<h1 id="ETH-交易树和收据树"><a href="#ETH-交易树和收据树" class="headerlink" title="ETH-交易树和收据树"></a>ETH-交易树和收据树</h1><p>​    每次发布一个区块的时候，这个区块所包含的交易，会组织成一棵交易树，也是一棵Merkle tree，和比特币的情况是类似的，同时，以太坊还增加了一个收据树，每个交易执行完之后，会形成一个交易，记录这个交易的相关信息，也就是说，收据树和交易树上面的结点是一一对应的。</p>
<a id="more"></a>

<p>​    增加这个收据树主要是考虑到以太坊的智能合约执行过程比较复杂，增加收据树的结构有利于我们快速查询一些执行的结果，从数据结构上来看，收据树和交易树都是MPT（Merkle Patricia tree），和比特币有所区别，比特币中的交易树，就是用普通的Merkle tree。为什么有这个区别？可能是为了方便，以太坊中的三棵树都用同样的结构，代码比较统一，不一定有什么深层次的原因，当然，用MPT的一个好处是：它支持查找操作，它支持通过键值，从顶向下，沿着树进行查找，对于状态树来说，查找的键值，就是这个账户的地址；对于交易树和收据树来说，查找的键值就是这个交易在发布的区块里面的序号（交易的发布顺序是由发布区块的那个结点决定的）。</p>
<p>​    交易树和收据树都是只把当前发布的区块里的交易组织起来的，而状态树，是把系统中所有账户的状态都要包含进去，不管这些账户和当前交易有没有关系。</p>
<p>​    多个区块的状态树是共享结点的，每次新发布一个区块的时候，只有这个区块里的交易影响了账户状态那些结点需要新建一个分支，其他的结点都是沿用原来状态树上的结点就行了。相比之下，每个区块的交易树和收据树都是独立的，他们是不会共享节点的，每个区块中发布的交易本身我们也认为是独立的。</p>
<p>​    交易树和收据树的用途？</p>
<blockquote>
<p>①提供Merkle Proof，就像比特币当中，交易树可以向轻结点证明某个交易被打包到某个区块里了；收据树也是类似的，你要证明某个交易的执行结果也是在收据树中提供一个Merkle Proof。</p>
<p>②除此之外，以太坊还支持一些更加复杂的查询操作，比如说，你想找到过去十天当中，所有跟智能合约有关的交易：一种办法是，把过去十天产生交易的区块都扫描一遍，看看其中有哪些交易和智能合约相关（复杂度比较高，而且对于轻结点来说，没有交易列表，它只有一个块头信息，所有轻结点也没有办法通过扫描所有交易列表的方法，找到符合条件的交易）；以太坊中引入了bloom filter。</p>
</blockquote>
<h2 id="bloom-filter"><a href="#bloom-filter" class="headerlink" title="bloom filter"></a>bloom filter</h2><p>bloom filter：这个数据结构可以支持比较高效的查找某个元素是不是在一个比较大的集合里面，比如有个很大的集合，你先知道某个指定的元素是不是在这个集合里，怎么办？</p>
<blockquote>
<p>一种比较笨的方法，遍历集合，但是这个复杂度是线性的（这个的前提是你得有足够的存储来保存整个集合的元素），对于轻结点来说，他没有交易列表（没有整个集合的元素信息）；</p>
<p>bloom filter使用了一种比较巧妙的思想，给这个大的集合，计算出一个很紧凑的摘要</p>
</blockquote>
<p>​    比如有一个128位的向量，集合中的每一个函数通过哈希函数取哈希，找到向量中的对应位置，然后把他置成1（向量每个位置的初始值为0），所有的元素都处理完了，得到的这个向量，就是原来集合的摘要，这个摘要比原来的集合要小很多，比如我们这个例子中，用一个128位的向量就可以代表一个集合了。</p>
<p>​    这个摘要有什么用？</p>
<blockquote>
<p>我们现在有一个元素d，想知道d是不是在集合中，但是这个集合本身我们不一定能够保存下来，应该怎么办？</p>
<p>我们用给定的哈希函数，给d取哈希值，看他映射的位置，如果该位置向量的值为0，说明这个元素一定不在这个集合里，假设是1，①确实是集合中的元素；②也有可能不在集合中，恰好出现了哈希碰撞而已</p>
</blockquote>
<p>​    所以，使用bloom filter，有可能会出现false positive，但是不会出现false negative（在里面他一定在里面，不在里面他有可能在里面）。</p>
<p>​    有的bloom filter的设计，不是用的一种哈希函数，而是用的一组哈希函数，那么每个哈希函数，独立地把这个函数映射到向量中的某一个位置，用一组哈希函数的好处是，不会所有的哈希函数都出现碰撞。</p>
<p>​    如果从集合中删除一个元素，该怎么操作？</p>
<blockquote>
<p>bloom filter的一个局限性是，不支持删除操作，把映射为1的位置改成0，可能其他的元素也映射到这里（哈希碰撞是可能的），所以简单的bloom filter是不支持删除操作的，如果要支持删除操作，就不能是0/1表示有还是没有了，得改成计数器得形式，还要考虑这个计数器会不会overflow，这样这个数据结构就很复杂了，与初衷是相违背的。</p>
</blockquote>
<p>​    以太坊中bloom filter的作用？</p>
<blockquote>
<p>每个交易执行完之后会形成一个收据，这个收据里面就会有一个bloom filter，记录这个交易的类型，地址等其他信息，发布的区块的块头里，也有一个总的bloom filter，这个总的bloom filter是这个区块里所有交易的bloom filter的一个并集</p>
</blockquote>
<p>​    所以你要根据条件查找交易（我要最近十天之内和智能合约相关的交易）？</p>
<blockquote>
<p>先查一下哪个区块的块头里的bloom filter有我要的这个交易的类型，如果块头里的bloom filter没有的话，那么这个区块就不是我们想要的，如果有的话，我们再去查找这个区块里包含的交易所对应的收据树里的那些bloom filter，有可能都没有（false positive），如果是有的话，找到相对应的交易确认。</p>
</blockquote>
<p>这个好处是什么？</p>
<blockquote>
<p>好处是能够快速过滤掉大量无关的区块，剩下的一些少数的“候选区块”我们再仔细查看，比如你是轻结点，你只有块头信息，那么根据块头，就已经可以过滤掉很多区块了，剩下有可能是你想要的区块，可以问全节点要一些进一步的信息。</p>
</blockquote>
<hr>
<p>​    以太坊的三棵树的哈希值都包含在块头里面的，以太坊的运行过程可以把它看成transaction-driven state machine（交易驱动状态机），这个状态机的状态是：所有账户的状态，就是状态树中包含的内容，那么交易是：每个发布的区块中包含的交易，通过执行这些交易，驱动当前系统从当前状态转移到下一个状态。</p>
<p>​    比特币你也可以认为是一个交易驱动的状态机，那么比特币中的状态是：UTXO（没有被花掉的交易的输出），每次新发布一个区块，会从UTXO用掉一些输出，又会增加一些输出，所以发布的这个区块会驱动这个状态机从当前状态转移到下一个状态。</p>
<p>​    比特币和以太坊中的状态机有一个共同特点，就是状态转移得是确定性的：对一个给定的当前状态，一组给定的交易，能够确定性的转移到下一个状态，因为所有的全节点，所有的矿工，都要执行相同的状态转移，所以状态转移必须是确定性的。</p>
<p>​    有人在以太坊上发布了一个交易，某个结点收到这个交易（A转账给B），有没有可能这个收款人的地址，以前从来没有听说过？</p>
<blockquote>
<p>可能的，创建账户的时候不需要通知其他人的，只有这个账户第一次收到钱的时候，其他账户才会知道这个账户的存在，这个时候要在状态树中新插入一个结点</p>
</blockquote>
<p>​    我们前面所讲的交易树，收据树，状态树的一个区别是状态树要包含所有账户的状态，能不能把这个状态树的设计改一下，改成状态树也只包含这个区块相关的那些账户的状态，这样就和交易树和收据树一致了，而且还大幅度的削减每个区块所对应的状态树的大小？</p>
<blockquote>
<p>你要想查找某个账户的状态就不方便了，还有另外一个问题在于：A要赚钱给B，你要知道A的状态才能转钱给B，也要知道B的状态是什么，当前余额是多少，因为你要收钱，所以A、B的状态都要找到，而B这个账户有可能是新创建的账户，这个时候你要找到创世纪块去，才发现B这个账户不存在。</p>
</blockquote>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p><img src="/2020/10/12/%E5%8C%BA%E5%9D%97%E9%93%BE/%E4%BA%A4%E6%98%93%E6%A0%91%E5%92%8C%E6%94%B6%E6%8D%AE%E6%A0%91/QQ%E6%88%AA%E5%9B%BE20201009192207.png"></p>
<blockquote>
<p>上图第一个判断是交易树的代码，如果交易列表是空的话，那么交易树的根哈希值就是一个空哈希值，否则的话，通过调用DeriveSha来得到交易树的根哈希值，然后创建这个区块的交易列表；</p>
<p>中间的代码是收据树，同样判断收据列表是否为空，如果是空的话，收据列表块头的哈希值就是一个空哈希值，否则的话，和交易树相同，交易列表的长度和收据列表的长度是相同的</p>
<p>下面的代码是处理叔父区块的，首先判断叔父列表是否为空，如果是的话，舒服区块的根哈希值就是个空哈希值，否则，通过调用CalcUncleHash计算哈希值，然后通过一个循环构建区块里的叔父数组（叔父列表和交易树和收据树没有关系）</p>
</blockquote>
<p><img src="/2020/10/12/%E5%8C%BA%E5%9D%97%E9%93%BE/%E4%BA%A4%E6%98%93%E6%A0%91%E5%92%8C%E6%94%B6%E6%8D%AE%E6%A0%91/QQ%E6%88%AA%E5%9B%BE20201009192340.png"></p>
<p><img src="/2020/10/12/%E5%8C%BA%E5%9D%97%E9%93%BE/%E4%BA%A4%E6%98%93%E6%A0%91%E5%92%8C%E6%94%B6%E6%8D%AE%E6%A0%91/QQ%E6%88%AA%E5%9B%BE20201009192401.png"></p>
<p><img src="/2020/10/12/%E5%8C%BA%E5%9D%97%E9%93%BE/%E4%BA%A4%E6%98%93%E6%A0%91%E5%92%8C%E6%94%B6%E6%8D%AE%E6%A0%91/QQ%E6%88%AA%E5%9B%BE20201009192445.png"></p>
<p><img src="/2020/10/12/%E5%8C%BA%E5%9D%97%E9%93%BE/%E4%BA%A4%E6%98%93%E6%A0%91%E5%92%8C%E6%94%B6%E6%8D%AE%E6%A0%91/QQ%E6%88%AA%E5%9B%BE20201009192547.png"></p>
<blockquote>
<p>创建交易树和收据树使用的都是这个函数，这里创建的数据结构（收据树和交易树）是一个trie</p>
</blockquote>
<p><img src="/2020/10/12/%E5%8C%BA%E5%9D%97%E9%93%BE/%E4%BA%A4%E6%98%93%E6%A0%91%E5%92%8C%E6%94%B6%E6%8D%AE%E6%A0%91/QQ%E6%88%AA%E5%9B%BE20201009192610.png"></p>
<p><img src="/2020/10/12/%E5%8C%BA%E5%9D%97%E9%93%BE/%E4%BA%A4%E6%98%93%E6%A0%91%E5%92%8C%E6%94%B6%E6%8D%AE%E6%A0%91/QQ%E6%88%AA%E5%9B%BE20201009192708.png"></p>
<blockquote>
<p>上图是Receipt的数据结构，每个交易执行完之后，形成一个收据，记录这个交易的执行结构，Bloom域就是Bloom filter，Logs为数组，每个收据可以包含多个Logs，这个收据的Bloom filter就是根据这些Logs产生出来的。</p>
</blockquote>
<p><img src="/2020/10/12/%E5%8C%BA%E5%9D%97%E9%93%BE/%E4%BA%A4%E6%98%93%E6%A0%91%E5%92%8C%E6%94%B6%E6%8D%AE%E6%A0%91/QQ%E6%88%AA%E5%9B%BE20201009192750.png"></p>
<blockquote>
<p>上图为区块的块头的数据结构，Bloom域是整个区块的Bloom filter，是由每个收据的bloom filter合并在一起得到的</p>
</blockquote>
<p><img src="/2020/10/12/%E5%8C%BA%E5%9D%97%E9%93%BE/%E4%BA%A4%E6%98%93%E6%A0%91%E5%92%8C%E6%94%B6%E6%8D%AE%E6%A0%91/QQ%E6%88%AA%E5%9B%BE20201009192820.png"></p>
<blockquote>
<p>上图中的红框中的代码就是创建区块的块头中的Bloom filter，通过调用CreateBloom这个函数</p>
</blockquote>
<p><img src="/2020/10/12/%E5%8C%BA%E5%9D%97%E9%93%BE/%E4%BA%A4%E6%98%93%E6%A0%91%E5%92%8C%E6%94%B6%E6%8D%AE%E6%A0%91/QQ%E6%88%AA%E5%9B%BE20201012191502.png"></p>
<blockquote>
<p>三个相关的代码实现，CreateBloom的三个参数是这个区块中的所有收据，这个for循环对每个收据再通过调用LogsBloom函数生成这个收据的bloom filter，然后把生成的bloom filter使用Or操作合并起来得到整个区块的bloom filter；</p>
<p>LogsBloom的功能是生成每个收据的bloom filter，他的参数是这个收据的Logs数组，每个收据里面包含一个Logs数组，这个函数有两层for循环，外层循环对每个一Log进行处理，首先把这个Log的地址取哈希之后加到Bloom filter里面，bloom9是bloom filter中使用的哈希函数，内层循环把这个Log中包含的每个topic加入到Bloom filter里，这样就得到了这个收据的bloom filter</p>
<p>bloom9是bloom filter中使用的哈希函数，和我们讲的有所区别，我们例子中的哈希函数是把集合中的每个元素映射到digest中的某一个位置，我们说这个集合要生成一个digest，哈希函数就是把每个函数映射到这个digest中的某一个位置，把这个位置置为1。这里所说的bloom9是把输入映射到digest中的三个位置（也就是说，把三个位置都置为1）：b为32个字节的哈希值，r是最后返回的bloom filter，这里初始化为0，接下来循环，把刚才生成的32个字节的哈希值前六个字节，每两个字节组成一组，拼接在一起，然后&amp;2047（相当于对2048取余），得到了一个位于0-2047区间里的数，之所以要这样做，是因为以太坊中bloom filter的长度是2048位，循环的最后一行把1左移 ，然后合并到上一轮得到的bloom filter里（通过Or运算），经过三轮循环，把三个位置置为1后，返回创建的bloom filter</p>
</blockquote>
<p><img src="/2020/10/12/%E5%8C%BA%E5%9D%97%E9%93%BE/%E4%BA%A4%E6%98%93%E6%A0%91%E5%92%8C%E6%94%B6%E6%8D%AE%E6%A0%91/QQ%E6%88%AA%E5%9B%BE20201012193342.png"></p>
<blockquote>
<p>查询某个bloom fiter里是否包含了感兴趣的topic呢？</p>
<p>通过调用BloomLookup函数来实现，查找bin这个bloom filter里有没有包含我们要找的topic，首先用bloom9函数将topic转换成一个byte vector，然后把他和bloom filter取And操作，看看得到的结果是不是和byte vector相等（这个bloom fiter中可能还包含别的topic，所以要先做一个And，然后再和他自身比较），相当于判断一下我们要找的topic在bloom fiter中对应的位置是不是都是1</p>
</blockquote>
]]></content>
      <categories>
        <category>区块链</category>
      </categories>
      <tags>
        <tag>区块链</tag>
      </tags>
  </entry>
  <entry>
    <title>ETH十---The DAO</title>
    <url>/2020/11/30/%E5%8C%BA%E5%9D%97%E9%93%BE/The-DAO/</url>
    <content><![CDATA[<h1 id="TheDAO"><a href="#TheDAO" class="headerlink" title="TheDAO"></a>TheDAO</h1><p>​    冲入攻击在现实中真的会发生吗？本文章讲解一下2015年发生过的一次真实的案例。这个案例在以太坊的历史上赫赫有名，造成了以太坊的分裂，可以说以太坊的历史都被他改写了。</p>
<p>​    我们说比特币实现了去中心化的货币，以太坊实现了去中心化的合约，那么去中心化这么好，那为什么不把所有的都改成去中心化的？所以有的人就提议：DAO(Decentralized Autonomous Organization)，去中心化的自治组织。</p>
<a id="more"></a>

<blockquote>
<p>​    传统社会上，组织是建立在某种法律文件上的，规范组织的行为，有时候还可能需要到政府登陆注册，在区块链上，DAO这个组织就是建立在代码之上的，组织上的规章制度，是写在代码里的，通过区块链的共识协议来维护规章制度的正确执行，这就是DAO。</p>
</blockquote>
<p>​    在2016年5月的时候，出现了一个致力于众筹投资的DAO，他的名字叫做The DAO（是指这个DAO叫做The DAO），它的工作原理，有点像众筹的一个投资基金，只不过投资的钱的来源，是通过在区块链上众筹的方法得到的，本质上是运行在以太坊上的一个智能合约，如果你想参与这个The DAO，那么你可以把以太币发给这个智能合约，然后可以换回The DAO的代币，需要决定投资哪个项目是大家投票决定的，你手里的代币越多，投票的权重越大，那么最后如果有了收益，也是按照智能合约中规定的制度来进行收益分配的，就是The DAO的工作原理。工作方法实际上有点像DAC（Decentralized Autonomous Corporation，去中心化的自治公司）的模式，一般来说DAC是出于盈利目的的，是为了经营赚钱，DAO可以是出于非营利性目的，DAC虽然叫做公司，但是不具有社会上公司的法人地位，一般来说，也没有董事长、CEO之类的职务。</p>
<p>​    The DAO在当时收到了很高的关注度，因为以前从来没有这样民主的投资基金，在当时被称为一种“伟大的尝试”，引起了互联网社区里很大的兴奋，从2016年5月份开始众筹，一个月的时间就筹集了价值1.5亿美元的以太币，当时的以太币价格还是比较便宜的，这些以太币放在现在的话，大概是价值几十亿美元，众筹的速度和规模在历史上是非常罕见的，比很多众筹网站要快得多，这也反映出了区块链技术的强大生命力，遗憾的是，The DAO只存活了三个月，问题出在哪里？比如你是一个投资者，你怎么取回The DAO的收益？这个在The DAO的基金里是通过“拆分”的方法实现的，叫做<code>Split DAO</code>，拆分的方法不是单纯的用来取回你的收益，也是一种建立子基金的方法，叫<code>child DAO</code>（拆分完之后叫做child DAO），设计理念是：</p>
<blockquote>
<p>​    我们说这个The DAO投资项目是靠大家一起用手中的代币去投票，那么如果有一小部分人投资理念和其他人不太一样，怎么办？比如说有一个小众的项目，少数人觉得很好，值得投，得不到大多数人的认可，这种情况下，这一小部分人可以用拆分的方法，从The DAO里面独立出来，成立自己的一个子基金，就是<code>child DAO</code>，然后拆分的时候，手中的代币，是要被收回去的，然后换成相应数量的以太币，就是把相应数量的以太币打到他们这个子基金里，然后他们就可以投他们想投的项目了。</p>
</blockquote>
<p>​    拆分的一个极端的例子，就是单独的一个投资者成立一个子基金，这个child DAO里就是他一个人，这样就可以把所有的钱投给自己，这是投资者取回投资和收益的唯一途径，它没有像上一篇文章所说的那种withdraw函数，拆分之前有7天的辩论期（决定要不要加入这个拆分，或者评价），拆分之后有28天的锁定期（成立一个子基金之后，需要28天之后才能把以太币取出来），我们后面会看到这28天的锁定期给了以太坊社区采用补救措施的时间，拆分的理念并没有错，而且可以说是民主制度的体现，民主制度并不是绝对的，少数的服从多数，而是说，也要尊重少数人选择的权力，既然这个拆分的理念没有错，那么问题出在哪里了？问题就出现在了<code>split DAO</code>的实现上。</p>
<p>相关代码：</p>
<p><img src="/2020/11/30/%E5%8C%BA%E5%9D%97%E9%93%BE/The-DAO/QQ%E6%88%AA%E5%9B%BE20201130191502.png"></p>
<blockquote>
<p>withdrawRewardFor把钱还给调用这个函数的人，之后把The DAO中的金额减少相应的数量，再把调用者的账户清零，这里就有问题了，按照上一篇文章所说的，应该先把账户清零，然后再转账，黑客就是利用这个漏洞进行的重入攻击。</p>
</blockquote>
<p>​    The DAO是从2016年五月开始众筹的，差不多一个月的时间，筹集了价值1.5亿美元的以太币，然后黑客就利用这个重入攻击，从里面转走了5000万美元的以太币，差不多1/3，这件事情当前在以太坊社区引起了很大的恐慌。这个时间也引起了以太币价格的大跳水，那么以太坊社区对此进行了激烈的讨论，社区的意见分裂为两派，一派认为要回滚交易（成立的子基金有28天的锁定期，所以黑客暂时还没有办法把钱取走，还有时间可以采取补救措施），通过回滚交易就不能让黑客得逞，这样能保障广大投资者的正当利益，另一派认为，不需要采取补救措施，因为黑客的行为并没有违法，既然我们说code is law，规则是由代码决定的，那么代码中的漏洞，也是规则的一部分，发生这个事情之后，网上流传了一封据说是黑客也给以太坊社区的公开信，公开信里黑客说，我没有做错任何事情，我只是利用了你代码中的一个feature。所以以太坊有一部分人认为是不应该采取补救措施，尤其是回滚交易，因为区块链最重要的特性是不可篡改性，如果出了问题就回滚，那么怎么能叫做不可篡改呢？而且这次出问题的只是以太坊运行的一个应用而已，The DAO是以太坊上的一个智能合约，以太坊本身的代码没有问题，如果每个智能合约出了问题都回滚的话，那不乱套了？</p>
<p>​    以太坊的开发团队是支持补救措施的，主要是这个事情的影响太大了，The DAO筹集的以太币的数目已经占到了当时流通量的很大一部分，大概是百分之十几。如果放纵不管，这些以太币的1/3要落入黑客的手里，我们真的希望这么多的以太币都集中在黑客的手里吗？而且投资者的利益怎么办？（too big to fail 出自2008年美国金融危机），以太坊社区有人认为The DAO的危机也是属于too big to fail，如果只是个小的智能合约出了问题，以太坊社区是不管的，开发团队也是不管的。</p>
<p>​    假设要采取补救措施，怎么补救？</p>
<blockquote>
<p>比如我们就从开始攻击的那个区块开始分叉，这样行不行？从攻击的链的上一个区块分叉，让下面的一条链，比上一条链要长（常见的分叉攻击的方法）</p>
<p><img src="/2020/11/30/%E5%8C%BA%E5%9D%97%E9%93%BE/The-DAO/QQ%E6%88%AA%E5%9B%BE20201130193824.png"></p>
</blockquote>
<p>​    上图所说的方法行不行？</p>
<blockquote>
<p>这个问题不是所有人都要统一，假设所有人都往下挖，这样会有什么后果？</p>
<p>不光是黑客攻击的交易回滚，上面这条链上攻击之后的所有交易都回滚了。上面有很多合法的交易，The DAO只是以太坊中运行的一个智能合约，另外还有很多智能合约在运行，还有一些正常的网上支付的交易，那就乱套了。要回滚的话，只能是精确定位，只能是针对黑客盗取以太币的那些交易，其他发生的正常交易不能发生影响，这是采取补救措施的一个原则。</p>
</blockquote>
<p>​    以太坊团队制定了两步走的方案，第一步，首先要锁定黑客的账户，第二步再设法把盗取的以太币退回去，清退The DAO基金上的这些钱。</p>
<blockquote>
<p>第一步：以太坊团队发布了一个软件升级，在升级的软件里增加了一条规则，凡是跟The DAO这个基金上的账户相关的，不允许做任何交易，发布之后，大多数以太坊的矿工都升级了这个软件。这个是属于软分叉，软件升级只是增加了一个判断规则，当一个节点收到一个交易的时候，判断这个交易是否合法，增加一个判断规则，The DAO相关的账户不允许任何交易，如果这个交易和The DAO账户相关的，就认为这个交易非法，增加这个规则之后，新矿工挖出的这个区块，旧矿工是认可的，因为旧矿工不知道这个新规则，他也不会去查这个，但是旧矿工挖出的区块，新矿工有可能不认可，如果这个区块里包含了The DAO这个账户的交易，就不认可，所以是软分叉。软件升级的想法是挺好的，也得到了大多数矿工的支持，遗憾的是，升级之后的软件，有一个bug，这个bug不是功能上的bug，也不是安全漏洞，而是和汽油费相关的，我们说你增加一个规则，收到一个交易，判断一下这个交易是不是和The DAO账户相关的，如果是的话，认定是非法交易，不予执行，这个时候还要不要收取汽油费？汽油费的机制很大的一方面是为了防范恶意的攻击者不断地去发放非法交易，浪费矿工的资源，反正对他来说成本很低，以太坊发布的软件升级，在这种情况下，恰恰是没有收汽油费，结果网上有大量的非法的交易，本来是大多数矿工都升级了软件的，但是升级之后不停地收到这种攻击，过不了多久，矿工就受不了了，于是回滚了软件升级，又改回了原来的版本，于是软分叉的方案就失败了，这个时候，形势就比较严峻了。</p>
</blockquote>
<p>​    子基金成立之后，有28天的锁定期，然后黑客就可以把钱取走了，软分叉的方案失败之后剩下的时间就不多了，既然软的不行，就来硬的。</p>
<p>​    以太坊团队设计了一个硬分叉的方案，通过软件升级的方法，把The DAO账户上的所有资金强行转到另外一个新的合约上去，这个新的智能合约只有一个功能，就是退钱，当初用以太币买的The DAO的代币，现在可以把这个代币退回成以太币，就这一个功能，为什么是硬分叉？</p>
<blockquote>
<p>用软件升级的办法强行重新记账，本来要转账得有合法的签名，比如说我要把你账上的钱转走，那得经过你的同意，有你的签名才行，这个时候就不管这些了，这是非常时期，凡是The DAO上面的资金，不管本人同意不同意，都要强行转到一个新的智能合约上去，就有点像法院的强制执行，那么升级的软件里规定了强制执行的具体日期：挖到第192万个区块的时候。所有升级软件的矿工，挖到第192万个区块的时候，自动执行这个转账交易，不用合法的签名，这是在升级的软件里写死的一条规则，旧矿工是不会认可这个区块的，因为没有合法的签名，认为是非法交易，所以是硬分叉。</p>
</blockquote>
<p>​    硬分叉的方案一提出来，在以太坊社区引起了非常激烈的辩论，我们前面说过，社区本来就分成了两派，有一派是认为不应该采取补救措施，这些人认为这种强行重新记账的办法是没办法接受的，这不是“耍流氓”吗？其实比中心化的组织还要差，法院强制执行都要走法律程序，被告还能聘请律师辩护呢。支持硬分叉和反对硬分叉的两派，争论地非常激烈，之后就投票，以太坊团队实现了一个用智能合约投票的功能，你可以把手里的以太币发到合约里进行投票，最后投票的结果是大部分人支持硬分叉，于是绝大多数矿工也升级了硬分叉的版本，大家就等着挖出第192万个区块的历史性时刻，这一次没有出现意外，硬分叉成功了，黑客盗取以太币的行为最终还是没有能够获利。故事到这也就结束了。</p>
<p>​    当初那些反对硬分叉的人，并没有因为投票结果而改变立场，他们认为，首先这次投票参与的人不是很多，投票是由两个智能合约，如果支持硬分叉，就把以太币投到一个合约里，如果反对硬分叉，发到另外一个合约里，然后锁到这个合约里，等投票之后再退回来，有很多以太币根本没有参加投票，这是第一点。第二点，也是最重要的一点，投票能说明问题吗？大多数人的意见一定是对的吗？你这样做是不是真的公平？硬分叉之后，旧的那条链并没有消亡，还有一些矿工留在上面继续挖，只不过算力大幅度下降，不到原来的1/10，但是这样做也有一定的好处，挖矿的难度大幅度的下调了，因为竞争没有这么激烈了，所以还是有些矿工愿意留在旧链上继续挖，过一段时间，有一些交易所开始上市交易旧链上的以太币（ETC：Ethereum Classic）。在旧链上挖的那些矿工有一些是出于投机目的，因为旧链上挖矿难度小，容易挖到币，而且上到交易所之后，盈利就有了途径，也有一些人在旧链上挖是出于信仰，出于坚持，纯而又纯的去中心化的理念，认为旧链中的以太坊根正苗红，这个ETC刚开始上交易所的时候，有很多人认为它的前途有非常大的不确定性，因为以太坊的核心开发团队都是支持硬分叉的，都是转到新链上开发的，那么旧链还能存活多久，这是大家的一个疑问，结果一直存活到了现在。</p>
<p>​    在刚开始的时候，两条链并存实际上带来了很多问题，因为这两条链的代码基本上是一样的，除了硬分叉相关的规则不一样之外，其他大部分代码都是一样的，而且硬分叉之前，用的也是同一套历史账本，用的同一套账户，私钥都一样，这样会带来一个什么问题？重放攻击，在新链上一个合法的交易，放在旧链上去，同样是合法的，重放之后仍然是可以执行的，同样，反过来也是一样，带来了很多管理上的混乱，后来给两条链增加了一个chain ID。旧链上的算力，已经比刚硬分叉的时候提高了很多倍了，到这里，这个故事才真正讲完了。</p>
<p>​    不论是软分叉的解决方案，还是硬分叉的解决方案，目标都是为了锁定黑客盗币的那些账户，但是我们讲解决方案的时候，都是把The DAO的所有账户都作为目标，比如软分叉的时候，The DAO的所有账户都不准交易，硬分叉的时候，The DAO的所有交易都必须转账，为什么不能只针对黑客的那些账户？</p>
<blockquote>
<p>我把黑客的钱没收了，然后按照发生攻击之前，每个人的账户余额去退，实际上最后也是这么操作的，智能合约的内容是公开的，包括智能合约所有的变量，存储什么的，函数定义成public，是大家都可以调用，但是不定义成public，函数的内容还是可以看得见的，就区块链上的代码都是开源的。</p>
<p>如果我们只冻结黑客的账户，The DAO的其他账户该怎么处理？其他账户是好人的所以不用管？如果你的智能合约写的有bug，你发布到区块链上之后，就改不了了，The DAO这个智能合约是有bug的，这个bug黑客这次用了，下次别人也可以用，光是把黑客的账户冻结了 ，剩下的账户继续运行，那任何人都可以成为黑客，在用同样的方法盗取以太币，这个bug你修不了，所以智能合约出现这种致命的bug，就作废了，事实上最后他也作废了，为什么他只存活了三个月，硬分叉之后，这个风靡一时的投资基金，The DAO就随之解体了，所有的账户都不安全了。</p>
</blockquote>
]]></content>
      <categories>
        <category>区块链</category>
      </categories>
      <tags>
        <tag>区块链</tag>
      </tags>
  </entry>
  <entry>
    <title>ETH五---以太坊中的共识机制</title>
    <url>/2020/10/19/%E5%8C%BA%E5%9D%97%E9%93%BE/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E4%B8%AD%E7%9A%84%E5%85%B1%E8%AF%86%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<h1 id="以太坊中的共识机制"><a href="#以太坊中的共识机制" class="headerlink" title="以太坊中的共识机制"></a>以太坊中的共识机制</h1><p>​    以太坊把出块时间降低到了十几秒，和比特币相比，以太坊的出块速度相当于提高了40倍，但是降低出块时间之后也带了一些新的问题：比特币和以太坊都是运行在应用层的共识协议，它的底层都是使用p2p overlay network，这个network本身传输的时间是比较长的，因为它的拓扑协议做flooding的时候是没有考虑实际的拓扑结果，这就带来一个问题，你发布一个区块之后，区块在网络上传到其他节点可能需要十几秒的时间，对于比特币来说，十分钟的出块时间相当于600秒，这个是足够让新发布的区块传播到网上的其他节点的，当然，即使这样，因为挖矿是个概率的过程，所以仍然有可能是有两个矿工同时获得记账权，同时发布区块，这种情况会带来临时性的分叉，那么对于以太坊来说，这种临时性的分叉就会变成常态，而且分叉的数目也会更多，这对于共识协议来说，有什么挑战呢？</p>
<a id="more"></a>

<blockquote>
<p>比特币的情况：只有在最长合法链上的那些区块的出块奖励才是真正有用的。因为对于出现临时性分叉的情况不是很多，所以这么规定还是可以接受的。</p>
<p>如果以太坊也这么处理，意味着这个矿工所挖到的区块有很大的概率可能是白挖了，可能你挖出的区块最终没有成为最长合法链，这样对矿工来说，不是很公平（尤其是对于个体矿工；挖矿的两大趋势：设备的专业化，矿池的出现），正常情况下，我们希望的情况是，矿池能够得到的收益应该和你的算力比例是相关的（公平），但是如果共识协议设计不好的话，有可能大型矿池的收益比例大于它所占的算力比例（会出现恶行循环），中心化mining centralization 带来的不成比例的优势centralization bias，所以如果以太坊沿用比特币的共识协议，是会有很大的问题的</p>
</blockquote>
<h2 id="uncle-block"><a href="#uncle-block" class="headerlink" title="uncle block"></a>uncle block</h2><p>​    以太坊中采用了GHOST协议的共识机制，GHOST的出现比以太坊早，以太坊对这个协议做了修改，这个协议的核心思想是：你挖到了矿，发布了一个区块，这个区块最后作废了，你挺伤心的，我们给你一些安慰，给你一些奖励，这种时候你也能得到一些出块奖励</p>
<p>​    为什么叫uncle block？</p>
<blockquote>
<p>因为它跟当前最长合法链上的区块来说，这个区块是它的叔父区块（和它的父亲是一个辈分的），最长合法链上的区块在发布的时候，可以把它的叔父区块包含进来，在这个区块发布的时候，它的叔父区块可以获得7/8的出块奖励，这个区块能得到额外的1/32（每包含一个，就得到额外的1/32）的出块奖励，一个区块最多可以包含两个叔父区块</p>
<p><img src="/2020/10/19/%E5%8C%BA%E5%9D%97%E9%93%BE/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E4%B8%AD%E7%9A%84%E5%85%B1%E8%AF%86%E6%9C%BA%E5%88%B6/QQ%E6%88%AA%E5%9B%BE20201015184922.png"></p>
</blockquote>
<p>​    以太坊的出块奖励刚开始的时候，是5个以太币，17年下半年的时候改了，改成3个以太币。这样设计，有利于鼓励系统中出现分叉之后及时进行合并，相当于新发布的区块把它的叔父区块招安过来了，这是Ghost协议最初的版本。</p>
<p>​    最初版本的协议有没有什么缺陷？</p>
<blockquote>
<p>①只能包含两个叔父区块，如果出现第三个怎么办？</p>
<p>②如果这个矿工比较自私的话，他有可能故意不把叔父区块包含进去：这样对于叔父区块来说7/8的出块奖励就得不到了，因为矿池之间有竞争关系，所以有的矿池就故意这么做</p>
<p><img src="/2020/10/19/%E5%8C%BA%E5%9D%97%E9%93%BE/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E4%B8%AD%E7%9A%84%E5%85%B1%E8%AF%86%E6%9C%BA%E5%88%B6/QQ%E6%88%AA%E5%9B%BE20201015190413.png"></p>
<p>有竞争关系的区块不包含叔父区块没有关系，但是你不包含，别人会包含，下一个区块就不一定是你挖出来的，也可能是自己来挖，把自己当作叔父区块包含进来</p>
</blockquote>
<p>​    本质：我们为了改进最初版本的ghost协议存在一些问题，所以我们把叔父的定义扩展了，不一定是当代叔父，可能是隔了几代的叔父，但是问题是隔了多少代？是不是可以隔一百代？那我就在很久很久以前，挖矿难度比较低的时候不断地产生叔父区块，期待着被包含。</p>
<p>​    以太坊中的规定：</p>
<p><img src="/2020/10/19/%E5%8C%BA%E5%9D%97%E9%93%BE/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E4%B8%AD%E7%9A%84%E5%85%B1%E8%AF%86%E6%9C%BA%E5%88%B6/QQ%E6%88%AA%E5%9B%BE20201015193058.png"></p>
<p>​    这样设置有什么好处？如果不这样设计会有什么坏处</p>
<blockquote>
<p>首先，如果你不限制叔父的辈分，那么这个实现起来对于一个全节点来说，他要维护的状态就太多了，可能要记录隔着一百代以前有哪些区块，你发布的这些区块包含的叔父区块，其他节点同样也是要验证的。</p>
<p>设计是最多隔着七代，并且七代以内出块奖励是递减的，这样有利于鼓励，出现分叉之后，尽早进行合并。</p>
</blockquote>
<p>​    叔父区块的奖励把它叫做uncle reward，他会递减，但是对于包含叔父区块的区块来说，包含一个叔父区块，可以得到1/32的奖励，这个是固定的。</p>
<p>​    我们设计这个协议，主要是解决系统中临时性的分叉，最长合法链也是为了解决临时性的分叉，合并的机制就是最长合法链会胜出，如果这个分叉是别的原因造成的，比如说，是对运行的区块链协议有不同的意见，那么这种方法是解决不了的，我们讲的这些例子都是state fork：对于区块链当前的状态产生了意见分歧（临时的）；如果是别的原因，像我们以前讲的比特币脚本的时候，CHECKMULTISIG的时候，要想堆栈中添加一个多余的元素，应对这个操作会弹出一个无用的元素，为什么不把这个bug改掉？</p>
<blockquote>
<p>改完之后，版本不一样了，这样会出现硬分叉，如果分叉的区块认为对方的区块是非法的，那么合并是不可行的。</p>
<p>仍然沿着矿工自己的分叉链去挖。</p>
</blockquote>
<p>​    我们说，比特币发布一个区块，实际上得到的是两种奖励，一部分叫做block reward（静态奖励），一部分叫做tx fee（动态奖励），以太坊中也是类似的，三个以太币是block reward，动态奖励叫做gas fee，在区块里包含了智能合约，执行智能合约的时候可以得到gas fee，我们说的uncle block得到的7/8的奖励，只限于3个以太币（也就是block reward），汽油费是得不到的，但是汽油费是很少一部分的，大部分是block reward。（和比特币类似）</p>
<p>​    如果以太坊中也变成了block reward趋于0，那么uncle reward不也是趋于0吗？</p>
<blockquote>
<p>以太坊中没有规定时间减少block reward的说法。比特币这么规定是因为比特币的稀缺性，以太坊中的5个以太币17年降为3个以太币不是为了人为制造稀缺性，实际上和挖矿难度调整有关的。（17年的事件是一次性的，没有说会一直下调）比特币被别人当成数字黄金，是用来储值的，以太币被别人比喻成石油，是用来花的，并且可以执行智能合约。（但是这里的比喻其实是不恰当的，因为石油用完就没了，但是以太币就是相当于电子现金），发布智能合约要花费gas fee，执行智能合约的那个矿工可以得到gas fee。（以太币和比特币的设计理念是不一样的）</p>
</blockquote>
<p>​    把叔父区块包含进来的时候，叔父区块里的交易要不要执行？</p>
<blockquote>
<p>以太坊是一个交易驱动的状态机，比特币也一样，所以每次发布一个新的区块都会使当前状态转化成下一个状态。</p>
<p>不应该执行，最长合法链上的父区块，和uncle block里面的交易可能是重复的，一种想法是相同的交易不执行，不同的交易就执行，但是这种情况下，不同的交易可能不可以一起执行。（可能是有冲突的交易）你要执行叔父区块的交易，可能某些交易就变成了非法交易，叔父区块的交易不一定是非法的，你执行完父区块的交易，再去执行叔父区块的交易，可能就变成非法的了。</p>
</blockquote>
<p>​    以太坊是不执行叔父区块里的交易的，而且是不检查叔父区块的合法性的，主链上的区块知道这个叔父区块的时候，只检查叔父区块是不是一个合法发布的区块，换句话说，这个区块是不是符合挖矿难度，至于这个区块里的交易合不合法不检查，不执行，执行起来的话，可能和主链上的交易是冲突的，叔父区块里的交易不执行，但是主链上的区块收到叔父区块里的交易，这个交易会被放在主链上执行。</p>
<p>​    怎么检测链上有多少个叔父区块？</p>
<blockquote>
<p>听到一个就查一下，每个发布的区块说明它的父区块是哪一个，所以可以检测到你的父区块和当前区块是不是有共同祖先。</p>
</blockquote>
<p>​    上述的例子的叔父区块都是分叉的第一个区块，如果分叉之后，分叉的那个区块后面跟着的那些区块怎么办？</p>
<p><img src="/2020/10/19/%E5%8C%BA%E5%9D%97%E9%93%BE/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E4%B8%AD%E7%9A%84%E5%85%B1%E8%AF%86%E6%9C%BA%E5%88%B6/QQ%E6%88%AA%E5%9B%BE20201019195216.png"></p>
<p>这样的话，可不可以给他们每个分叉都一部分奖励，“招安”的时候相当于是“招安一伙”？免得出现两个分叉的情况</p>
<blockquote>
<p>这样改的话，forking attack就变得太便宜了，攻击成了，我把你的交易回滚了，攻击不成，你反正把我“招安”过去，我也能得到一些出块奖励，所以以太坊规定，只有分叉后的第一个区块可以得到uncle reward</p>
</blockquote>
<p><img src="/2020/10/19/%E5%8C%BA%E5%9D%97%E9%93%BE/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E4%B8%AD%E7%9A%84%E5%85%B1%E8%AF%86%E6%9C%BA%E5%88%B6/QQ%E6%88%AA%E5%9B%BE20201019200320.png"></p>
<p>叔父区块的不同情况：</p>
<p><img src="/2020/10/19/%E5%8C%BA%E5%9D%97%E9%93%BE/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E4%B8%AD%E7%9A%84%E5%85%B1%E8%AF%86%E6%9C%BA%E5%88%B6/QQ%E6%88%AA%E5%9B%BE20201019200352.png"></p>
<p>Block Height：区块的序号，也就是block number </p>
<p>UncleNumber：叔父区块在区块链中的序号</p>
<p>看uncle number 和block height的差值，判断，相差多少代，上图说明，系统中的大多数区块都及时地得到了合并</p>
<p>叔父区块奖励的具体内容：</p>
<p><img src="/2020/10/19/%E5%8C%BA%E5%9D%97%E9%93%BE/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E4%B8%AD%E7%9A%84%E5%85%B1%E8%AF%86%E6%9C%BA%E5%88%B6/QQ%E6%88%AA%E5%9B%BE20201019200937.png"></p>
]]></content>
      <categories>
        <category>区块链</category>
      </categories>
      <tags>
        <tag>区块链</tag>
      </tags>
  </entry>
  <entry>
    <title>ETH六---以太坊挖矿算法</title>
    <url>/2020/10/29/%E5%8C%BA%E5%9D%97%E9%93%BE/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%8C%96%E7%9F%BF%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>对于基于工作量证明的区块链系统来说，挖矿是保障区块链安全的一个重要手段。</p>
<p>​    Block chain is secured by mining.比特币中的挖矿算法，总的来说是比较成功的。</p>
<blockquote>
<p>bug bounty：有的公司悬赏来找软件中的漏洞，如果能找到软件中的漏洞，就可以得到一笔赏金。</p>
<p>比特币的挖矿算法，是一个天然的bug bounty，如果你能找到里面的漏洞，或者是某一个挖矿的捷径，就能有很大的利益。所以比特币的挖矿算法，是比较成功的，能够经受时间的检验的</p>
</blockquote>
<a id="more"></a>

<p>​    但是比特币的挖矿算法也有一些值得改进的地方，其中有一个饱受争议的问题，就是挖矿设备的专业化（用普通的计算机挖不到矿），很多人认为，这和比特币去中心化的思想时背道而驰的，也和比特币的设计初衷是相违背的（one cpu one vote，理想情况下，让普通老百姓也能参与挖矿的过程），这样有恶意的攻击者想要聚集50%的算力发动攻击，这个难度就会大得多，所以这之后的很多加密货币，包括以太坊在内，都是要做到ASIC resistance。</p>
<p>​    如何设计一个对ASIC芯片不友好的mining puzzle？</p>
<blockquote>
<p>常用的做法是增加这个puzzle对内存访问的需求，也就是所谓的memory hard mining puzzle，ASIC对普通cpu的主要优势是算力强，但是在内存访问的性能上，并没有那么大的优势，所以如果我们能设计一个对内存要求很高的puzzle，那么就能够起到遏制ASIC芯片的作用。</p>
<p>​    这里面的一个早期的例子就是LiteCoin（莱特币），曾经市值仅次于比特币的第二大加密货币，它用的puzzle是基于scrypt（对内存要求很高的哈希函数，以前用于计算机安全领域，和密码相关的），具体思想：开设一个很大的数组，然后按照顺序填充一些伪随机数</p>
<p><img src="/2020/10/29/%E5%8C%BA%E5%9D%97%E9%93%BE/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%8C%96%E7%9F%BF%E7%AE%97%E6%B3%95/QQ%E6%88%AA%E5%9B%BE20201027190819.png"></p>
<p>​        注：这里的seed的去哈希，实际上是通过一些运算得到一个数</p>
<p>​    这里我们不能真的用随机数，用随机数我们没有办法验证，这个数组的取值是有前后依赖关系的，需要求解puzzle的时候，按照伪随机的顺序，从这个数组中读取一些数，每次读取的位置，也是和前一个数是相关的（每次读取的数，通过一些运算（哈希运算），得到下一个需要读取数的位置，以此类推），如果这个数组足够的大的话，那么对于矿工来说，就是memory hard，因为如果不保存这个数组，挖矿的复杂度会大幅度上升（需要读取数组中的数的时候，没有保存这个数组，还得从第一个算，算出第一个位置的值，然后要读取第二个位置的数，还要继续计算到第二个位置的值，计算复杂度会大幅度地上升，所以要想高效的挖矿，这个内存区域是需要保存的），有的矿工可能保存一部分内存区域的内容（比如只保存奇数位置的元素，当用到偶数位置，根据另一半算一下），有时候也叫做time-memory trade off。</p>
<p>好的地方：对矿工来说：memory hard</p>
<p>不好的地方：对轻结点来说，也是memory hard，求解puzzle很难，但是验证应该是很简单的，这个问题就在于，验证这个puzzle需要的内存区域跟求解这个puzzle的内存区域几乎是一样大的，对于早期的计算机安全领域，没有这个问题（因为他没有轻结点），所以，这就导致，这个内存区域不能设置得太大，比如你设置的1G大小的内存区域，问题不大，但是是手机上的app，就太大了，所以实际使用莱特币的时候只有128k。</p>
</blockquote>
<p>​    当初，莱特币发明的目标，不止是ASIC resistance，还有GPU resistance（挖矿连GPU都不要用），大家都用普通的cpu挖矿，后来就出现了GPU挖矿，现在出现了ASIC芯片挖矿，实验证明，莱特币要求的128k内存不足以对ASIC芯片的生产和设计带来实质性的障碍，所以从这点来说，莱特币设计的目标是没有达到的，但是对于解决莱特币的能启动问题，是很有帮助的，任何一个加密货币都存在能启动的问题，包括比特币（一开始的时候没有人知道你这个货币，没有人理你，没有人参与），而且对于基于工作量证明的加密货币来说，挖矿人太少是不安全的，因为发动恶意攻击的难度就太低了，比特币的早期也是不安全的。解决能启动的问题实际上是一个循环迭代的过程，一个好的加密货币是可以经过时间的检验的。</p>
<p>​    除了mining puzzle这个区别之外，莱特币和比特币的区别还有就是出快速度是比特币的四倍，出块间隔是两分半，除此之外，这两种加密货币基本上是一样的。</p>
<p>​    以太坊也是一种memory hard mining puzzle，但是在设计上和莱特币有很大的不同，以太坊用的是两个数据集，一大一小，小的是一个16M的cache，大的是一个1G的dataset（DAG），这1G的数据集是从这16M的cache生成出来的，为什么要这样设计？一大一小？</p>
<blockquote>
<p>就是为了便于验证，轻结点只需要保存16M的cache就可以了，只有需要挖矿的矿工才需要保存1G的数据集，基本思想是：这个小的数据集cache的生成方式跟前面所讲的数组的生成方式是比较类似的，首先从一个种子节点，通过一些运算，算出数组的第一个元素，然后依次取哈希，第一个元素取哈希得到第二个元素，以此类推，将数组从前往后填充伪随机数，得到这个cache，之后就和莱特币就不一样了，</p>
<p>莱特币：直接从数组当中按照伪随机的顺序读取一些数，然后进行运算。</p>
<p>以太坊：先生成一个更大的数组，这个大数组比cache大得多，小的cache和大的dataset都是定期增长的，每隔一段时间，会增大，因为计算机的容量也是定期增长的，比如现在，这个大的dataset已经增长到2.5G了，大的数据集的生成方式：每个元素都是从小的cache里按照伪随机的顺序读取一些元素，方法和刚才讲的莱特币里面求解puzzle的过程是类似的：第一次比如说读取A位置的元素，读取完之后，对当前的哈希值进行一些更新迭代，算出下一个要读取的位置，比如说B位置，然后再算出下一个要读取的位置，从cache中依次读，一共读256次，最后算出来一个数，最后放在dataset的第一个元素，然后第二个元素也是一样的。</p>
<p>求解这个puzzle的时候，用的是这个大数据集中的数，cache是不用的，按照为随机的顺序 ，从这个大的数据集中读取128个数。一开始的时候，根据这个区块的块头，包括里面的nonce，算出一个初始的哈希，根据这个哈希，映射到大数据集中的某个位置，把这个位置上的数读取出来，然后进行一些运算，得到下一个要读取的位置……（这里有个区别，除了把算出的位置要读，还要读取它的下一个位置的元素也要读出来，所以每次读的时候，回一次读取两个位置的元素，这样循环64次，每次读两个，一共128个），最后算出一个哈希值来，跟挖矿难度的目标阈值比较一下，是不是符合难度要求，如果不是的话，把block header的nonce替换一下，然后重新算</p>
</blockquote>
<p>​    </p>
<p>​    ethash算法伪代码：</p>
<p><img src="/2020/10/29/%E5%8C%BA%E5%9D%97%E9%93%BE/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%8C%96%E7%9F%BF%E7%AE%97%E6%B3%95/QQ%E6%88%AA%E5%9B%BE20201029200329.png"></p>
<p><img src="/2020/10/29/%E5%8C%BA%E5%9D%97%E9%93%BE/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%8C%96%E7%9F%BF%E7%AE%97%E6%B3%95/QQ%E6%88%AA%E5%9B%BE20201029200958.png"></p>
<p><img src="/2020/10/29/%E5%8C%BA%E5%9D%97%E9%93%BE/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%8C%96%E7%9F%BF%E7%AE%97%E6%B3%95/QQ%E6%88%AA%E5%9B%BE20201029201222.png"></p>
<p><img src="/2020/10/29/%E5%8C%BA%E5%9D%97%E9%93%BE/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%8C%96%E7%9F%BF%E7%AE%97%E6%B3%95/QQ%E6%88%AA%E5%9B%BE20201029201557.png"></p>
<blockquote>
<p>上图中的两个函数：</p>
<p>第一个函数，矿工用来挖矿的函数，以太坊，和比特币一样，挖矿只用到块头的信息（这样的话，轻结点只下载块头，就可以验证这个区块，是否验证这个区块是否符合挖矿的难度要求），第二个参数nonce，表示当前尝试的nonce值，第三个参数full_size是大数据集中元素的个数，每三万个区块会增加一次，增加原始大小的1/8，也就是1G的1/8，等于8M，最后的参数dataset，就是前面生成的大数据集。</p>
<p>挖矿：首先根据块头的信息，和当前的nonce算出一个初始的哈希，然后经过64轮循环，每个循环读取大数据集中相邻的两个数，读取的位置，是由当前哈希值计算出来的，然后根据当前位置上的数值，更新当前的哈希值（每次读取的相邻位置上的值是没有联系的，虽然在位置上相邻，但是生成的过程是独立的，每个都是由前面那个16M的cache中的256个数生成的，而且这256个数的位置，是按照伪随机的顺序产生的），这和生成大数据集的元素的方法是类似的，最后返回一个哈希值，和挖矿难度的目标阈值相比较。</p>
<p>下面这个函数，是轻结点用来验证的函数。也是有四个参数，但是含义和矿工用的函数有所不同，轻结点是不挖矿的，当他收到某个矿工发布的区块的时候，这里用来验证的这个函数的第一个参数header，是这个区块的块头，第二个nonce是发布的这个区块的nonce（是矿工选好的），轻结点的任务是验证这个nonce是否符合要求，验证用的是16M的cache，也就是最后这个参数，注意，第三个参数full_size仍然是大数据集中的元素个数</p>
<p>验证：也是64轮循环，看上去和挖矿的过程类似，只有一个地方有区别，每次需要从大数据集读取元素的时候，因为轻结点没有保留大数据集，所以要从cache重新生成。</p>
</blockquote>
<p><img src="/2020/10/29/%E5%8C%BA%E5%9D%97%E9%93%BE/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%8C%96%E7%9F%BF%E7%AE%97%E6%B3%95/QQ%E6%88%AA%E5%9B%BE20201029203435.png"></p>
<p><img src="/2020/10/29/%E5%8C%BA%E5%9D%97%E9%93%BE/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%8C%96%E7%9F%BF%E7%AE%97%E6%B3%95/QQ%E6%88%AA%E5%9B%BE20201029203623.png"></p>
<p>​    那以太坊设计的这个puzzle，实际效果怎么样？</p>
<blockquote>
<p>到目前为止，以太坊挖矿，主要还是以GPU为主，用ASIC矿机的很少，所以从这点上来说，他比莱特币要成功，起到了ASIC resistance的作用，这个和以太坊挖矿算法需要的大内存是很有关系的</p>
</blockquote>
<p>​    ethash：eth+hash，矿工挖矿需要1g的内存，跟莱特币的128kb，差了有8000多倍，即使16M的cache和128kb相比，爷要大了100多倍，而且还是按照这两个数据集最初的大小来算的。</p>
<p>​    以太坊没有出现ASIC矿机，还有另外一个原因：</p>
<blockquote>
<p>以太坊从很早开始就计划，要从工作量证明转向权益证明（PoW-&gt;PoS[proof of stake]），就是按照所占的权益进行投票形成共识（类似股份制公司按照股份多少来投票，这样就不挖矿了），这样对于ASIC矿机的厂商来说，是一个威胁，因为ASIC矿机的生产周期是很长的，一款芯片，从设计研发到最后的生产，一年的周期就已经算是很快的了，而且研发的成本也很高，那么转向权益证明之后就不挖矿了，那么投入的研发费用都白费了。</p>
<p>其实，以太坊到现在为止，还是基于工作量证明，转移的时间点一再往后推迟，要想达到ASIC resistance，一个简单的办法，就是不断地“吓唬大家”，以太坊成为主流的加密货币，其实也就是最近的两年的时间</p>
</blockquote>
<p>​    关于挖矿：以太坊采用了预挖矿的过程（pre-mining）。</p>
<blockquote>
<p>所谓的预挖矿，并不是说真的去挖矿，而是说在当初发行货币的时候，预留一部分货币，给以太坊的开发者，将来这个加密货币成功了的话，这些预留的币就变得很值钱了，像以太坊的早期开发者，现在都很有钱，和比特币相比，比特币就没有采用pre-mining的模式，所有的比特币都是挖出来的，只不过早些时候，挖矿的难度要容易得多，与pre-mining相关的概念叫做pre-sale（把pre-mining预留的那些币，通过出售的方式来换取一些资产，然后用于加密货币的开发工作，有点像拉风头，或者众筹）。</p>
</blockquote>
<p>以太坊的一些统计数据：</p>
<p><img src="/2020/10/29/%E5%8C%BA%E5%9D%97%E9%93%BE/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%8C%96%E7%9F%BF%E7%AE%97%E6%B3%95/QQ%E6%88%AA%E5%9B%BE20201102193027.png"></p>
<p><img src="/2020/10/29/%E5%8C%BA%E5%9D%97%E9%93%BE/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%8C%96%E7%9F%BF%E7%AE%97%E6%B3%95/QQ%E6%88%AA%E5%9B%BE20201102193205.png"></p>
<p>以太坊价格变化（2017年-2018）：</p>
<p><img src="/2020/10/29/%E5%8C%BA%E5%9D%97%E9%93%BE/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%8C%96%E7%9F%BF%E7%AE%97%E6%B3%95/QQ%E6%88%AA%E5%9B%BE20201102193243.png"></p>
<p>以太坊市值：</p>
<p><img src="/2020/10/29/%E5%8C%BA%E5%9D%97%E9%93%BE/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%8C%96%E7%9F%BF%E7%AE%97%E6%B3%95/QQ%E6%88%AA%E5%9B%BE20201102193345.png"></p>
<p><img src="/2020/10/29/%E5%8C%BA%E5%9D%97%E9%93%BE/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%8C%96%E7%9F%BF%E7%AE%97%E6%B3%95/QQ%E6%88%AA%E5%9B%BE20201102193432.png"></p>
<blockquote>
<p>上图中的HashRate指的是所有的矿工加在一起每秒钟计算的哈希次数</p>
<p>不同的加密货币，如果采用的mining puzzle不同的话，那么他们的HashRate是不可比的。</p>
</blockquote>
<p>如果让通用计算机参与挖矿，发动攻击的成本也会大幅度得降低，如果一个大公司有几百万台甚至几千万台服务器，如果这个公司有恶意，就可以临时征用服务器，来挖矿，没有必要专门买特有的设备。所以有些人认为，让通用计算机参与挖矿是不好的。</p>
]]></content>
      <categories>
        <category>区块链</category>
      </categories>
      <tags>
        <tag>区块链</tag>
      </tags>
  </entry>
  <entry>
    <title>ETH一---概述</title>
    <url>/2020/10/04/%E5%8C%BA%E5%9D%97%E9%93%BE/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%A6%82%E8%BF%B0/</url>
    <content><![CDATA[<h1 id="以太坊概述"><a href="#以太坊概述" class="headerlink" title="以太坊概述"></a>以太坊概述</h1><p>比特币和以太坊是区块链中的最主要的两种加密货币，比特币被称为区块链1.0，以太坊被称为2.0</p>
<p>以太坊对比特币运行过程中出现的问题做出了改进，比如说出块时间，比特币是十分钟，有人认为太长了，以太坊当中出块时间大幅度地降低到了十几秒，而且，为了这种出块时间，以太坊还设计了一套ghost的共识机制；另一个重大的改进是mining puzzle：比特币的mining puzzle是计算密集型的，比拼的是挖矿的计算能力，这种结果就造就了现在的挖矿设备专业化。以太坊对内存的要求是很高的，memory hard mining puzzle，这样就在一定程度上限制了ASIC芯片的使用，我们管它叫做ASIC resistance，将来以太坊还会有一些更高的改进，用proof of stake（权益证明，不挖矿，而是按照股份和权益，用类似于投票的方式来决定下一个区块该怎么产生）替换proof of work。</p>
<a id="more"></a>

<p>以太坊还增加了一个重要的功能，就是对智能合约（smart contract）的支持。智能合约？</p>
<p>我们知道Bitcoin：decentralized currency，根据比特币成功的案例，我们知道他是去中心化的，如果货币去中心化怎么办？还有什么可以去中心化？</p>
<blockquote>
<p>以太坊就提出了decentralized contract（去中心化的合约）什么是decentralized contract？</p>
<p>货币本来是由政府发行的，货币的价值建立在政府公信力的基础上，然后政府通过司法手段维护货币体系的正常运行，比特币的出现，将政府的这些职能取代了，通过密码学、共识机制来维护加密货币体系的正常运行。</p>
<p>去中心化的合约也是类似。现实中的合约应该也是通过司法手段、通过政府来维护，那么我们能不能通过技术手段，将司法手段取代了，这就是以太坊智能合约设计的一个目的，如果合同中的内容可以通过程序代码来实现出来的，那么我们把这个代码就可以放在区块链上，通过区块链的不可篡改性，来保证这个代码的正确运行，当然，不是所有的合约的内容都可以用编程语言来实现，也不是所有的合同条款能够量化的。</p>
</blockquote>
<p>这种去中心化的合同有什么好处呢？</p>
<blockquote>
<p>首先思考去中心化的货币有什么好处？有什么应用场景？</p>
<p>可以实现跨国转账，手续没有跨国转账那么麻烦；智能合约也有一些类似的应用场景，比如如果合同的签署方是来自世界各地的，没有一个统一的司法管辖权，这个时候如果用司法来管辖，就比较困难：比如说众筹，你都不知道每个人都来自哪，所以可以使用程序写好的规则来管辖，这时候就会比较方便。（其实，就算是所有的人都在同一个司法管辖之下的，你想真正用司法手段来维护，也是一个比较费时费力的过程）。</p>
</blockquote>
]]></content>
      <categories>
        <category>区块链</category>
      </categories>
      <tags>
        <tag>区块链</tag>
      </tags>
  </entry>
  <entry>
    <title>ETH八---以太坊权益证明</title>
    <url>/2020/11/10/%E5%8C%BA%E5%9D%97%E9%93%BE/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%9D%83%E7%9B%8A%E8%AF%81%E6%98%8E/</url>
    <content><![CDATA[<h1 id="权益证明proof-of-stake"><a href="#权益证明proof-of-stake" class="headerlink" title="权益证明proof of stake"></a>权益证明proof of stake</h1><h2 id="图解"><a href="#图解" class="headerlink" title="图解"></a>图解</h2><p>​    比特币和以太坊目前用的都是基于工作量证明，这种机制收到了一个普遍的批评，就是“浪费电”。</p>
<a id="more"></a>

<p><img src="/2020/11/10/%E5%8C%BA%E5%9D%97%E9%93%BE/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%9D%83%E7%9B%8A%E8%AF%81%E6%98%8E/QQ%E6%88%AA%E5%9B%BE20201110182306.png"></p>
<blockquote>
<p>上图是比特币的能耗图，TWh指的是Terawatt hours (10^12)，常见的KWh：kilowatt hours（10^3），就是千瓦时，这个图上可以看出比特币的能耗随时间推移是不断增长的。</p>
</blockquote>
<p><img src="/2020/11/10/%E5%8C%BA%E5%9D%97%E9%93%BE/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%9D%83%E7%9B%8A%E8%AF%81%E6%98%8E/QQ%E6%88%AA%E5%9B%BE20201110182732.png"></p>
<p>​    一个交易要花费1000度电，信用卡公司处理一个交易远远到不了这个数字。</p>
<p>以太坊的统计数据：</p>
<p><img src="/2020/11/10/%E5%8C%BA%E5%9D%97%E9%93%BE/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%9D%83%E7%9B%8A%E8%AF%81%E6%98%8E/QQ%E6%88%AA%E5%9B%BE20201110182928.png"></p>
<p><img src="/2020/11/10/%E5%8C%BA%E5%9D%97%E9%93%BE/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%9D%83%E7%9B%8A%E8%AF%81%E6%98%8E/QQ%E6%88%AA%E5%9B%BE20201110182951.png"></p>
<p>​    根据每个区块所消耗的能源来看，以太坊比比特币要小得多，这是为什么？</p>
<blockquote>
<p>从交易上来看，比特币的交易都是非常简单的，而以太坊的交易有可能包含对智能合约调用，所以以太坊的能耗应该更高才对，但是实际上不是这样。</p>
<p>出块时间：比特币要十分钟才能挖出一个区块，以太坊15秒就能挖出一个区块。</p>
</blockquote>
<p>​    当然，以太坊一个交易的能耗还是要比信用卡公司高上很多。</p>
<hr>
<p>​    把比特币和以太坊当成一个国家来看，它的能耗排名：</p>
<p><img src="/2020/11/10/%E5%8C%BA%E5%9D%97%E9%93%BE/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%9D%83%E7%9B%8A%E8%AF%81%E6%98%8E/QQ%E6%88%AA%E5%9B%BE20201110183442.png"></p>
<h2 id="这些能耗是不是必须的？"><a href="#这些能耗是不是必须的？" class="headerlink" title="这些能耗是不是必须的？"></a>这些能耗是不是必须的？</h2><p>​    矿工为什么要挖矿？</p>
<blockquote>
<p>为了取得出矿奖励，获得收益。</p>
</blockquote>
<p>​    为什么要给矿工这些收益？</p>
<blockquote>
<p>激励矿工参与区块链的维护。</p>
</blockquote>
<p>​    矿工是怎么参与挖矿的？如果你是一个矿工，你会怎么做？</p>
<blockquote>
<p>需要找一大笔资金，购买一些设备（现成的，如矿机，GPU）</p>
</blockquote>
<p>​    挖矿的收益，有什么决定？</p>
<blockquote>
<p>挖了多少区块。</p>
</blockquote>
<p>​    挖了多少区块由什么决定？</p>
<blockquote>
<p>由你的算力所占比例所决定的</p>
</blockquote>
<p>​    你的算力由什么决定？</p>
<blockquote>
<p>你有多少矿机，有多少设备</p>
</blockquote>
<p>​    说白了，挖矿的收益是由什么决定的？靠拼钱决定的</p>
<p>​    既然是为了拼钱，那我们直接拿钱出来比一比不就知道了吗？</p>
<blockquote>
<p>现在是由矿工竞争算力来决定挖矿的收益如何分配，能不能靠比钱的多少来分配收益？</p>
<p>比如，我出一百万，你出五十万，现在的做法是，用这钱都去买矿机，大家的矿机开始挖矿，比拼一下算力，看谁挖的区块多，与其这样，还不如我们都把这钱投入到区块链的开发，将来按照资金的多少，来决定收益的分配，这就是权益证明的基本思想。有的时候把这种做法叫做：virtual mining。</p>
</blockquote>
<p>​    采用权益证明的加密货币，一般在正式发行之前，会先预留一部分货币，留给开发者，也会出售一部分货币，来换取开发这个加密货币所需要的资金，将来，按照权益证明的共识机制，每个人按照持有货币的数量来进行投票的，这种方法和工作量证明相比，有什么优点？</p>
<blockquote>
<p>省去了挖矿的过程，也避免了由此带来的能耗和对环境的影响，减少了温室气体的排放。</p>
<p>基于工作量证明的系统，从某种意义上来说，维护这个区块链安全的资源，不是一个“闭环”（我们的矿机，是从生态系统外面得到的，这就带来一个问题：跟世界经济总量相比，是微乎其微的，所以，如果有某一个组织想要发动恶意攻击，只需要用足够的资金来购买挖矿设备，然后聚集到这个加密货币总算力一半以上的算力就行了，也就是说，发动这种攻击的资源是可以从外面的世界得到的），像比特币这种主流的货币，它的抗攻击能力相比，还是比较强的，如果是一些刚刚发行不久的小的币种，那么遇到这种攻击可能就是致命性的，如AltCoin。对矿工和早期的开发者，造成的损失可能是灾难性的。（Infanticide，“扼杀在摇篮里”），如果采用权益证明，情况会有什么不同？</p>
<p>如果有某人像发动恶意攻击（51攻击），首先要设法获得这个币种一半以上的份额才行，发动攻击的资源，只能从这个加密货币系统内部得到，这就是为什么是一个“闭环”。无论攻击者在外部有多少钱，都不会对加密货币系统造成直接的影响，发动攻击只能大量的买币，而一旦有人大量的买币，会有什么情况？</p>
<p>价格会大涨，本来一个刚刚发行的小币种，没有人买的，价值也不高，突然有人为了搞垮他，结果价格大涨，如果你是这个币的开发者或者投资者，出现这种情况，你就会怎么想？</p>
<p>这不一定是坏事，我正好可以从中大赚一笔，有点类似股份制公司遭受恶意收购。</p>
</blockquote>
<p>​    权益证明和工作量证明并不是互斥的，有的加密货币采用的是一种混合模型，有些加密货币仍然是要挖矿的，但是挖矿的难度和你占有的权益（你持有多少币）是相关的，比如说每个矿工持有一定数量的这种币，挖矿的时候，持有的币越多，挖矿的难度就越小。当然，这么设计是有一定问题的。</p>
<blockquote>
<p>这样的话，系统中持有币数量最多的那个人，每次挖矿都是最容易的，所以有的加密货币要求你投入的币要被锁一段时间，不能够重复使用，比如挖这个区块的时候，你投入一定数量的币，用于降低挖矿难度，等这个区块发不出来之后，你投入的这些币就会被锁定一段时间，你下次在挖下一个区块的时候，这些币就不能用了，这个有时候管它叫做（Proof of deposit）。</p>
</blockquote>
<p>​    基于权益证明的共识机制该怎么设计，有很多挑战，其中早期的权益证明遇到的一个挑战就是“两边下注”的问题（nothing at stake）。如下图的区块链所示。</p>
<p><img src="/2020/11/10/%E5%8C%BA%E5%9D%97%E9%93%BE/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%9D%83%E7%9B%8A%E8%AF%81%E6%98%8E/QQ%E6%88%AA%E5%9B%BE20201112191201.png"></p>
<blockquote>
<p>挖矿的话，不能两边都挖，如果两边都挖，那么你的算力就分散了，挖到区块的概率就小了，但是你用权益证明的话，可以两边都下注，如果上面那条链成为最长合法链，你在下面锁定的那些币是没有影响的，你投的这些币，只是记在下面这个分叉上，并不影响你在上面分叉的使用，这就是为什么叫做nothing at stake。这也是早期基于权益证明共识机制遇到的一个问题。</p>
</blockquote>
<p>​    以太坊中准备采用的权益证明协议叫做Casper the Friendly Finality Gadget（FFG），在过渡阶段也是要和工作证明混合使用的，为工作量证明提供Finality，Finality是一种最终的状态，包含在Finality中的交易不会被取消，单纯基于工作量的证明，是有可能被回滚的。</p>
<p>​    Casper协议是怎么做的？</p>
<blockquote>
<p>引入了一个Validator(验证者)，要想成为一个Validator，必须要投入一定数量的以太币作为保证金，这个保证金会被系统锁定，Validator的职责是推动系统达成共识，投票决定那条链是最后合法链，投票的权重取决于保证金的数目大小，有点类似数据库中的two-phase commit。</p>
<p>还是有人挖矿的，每挖出100个区块，就作为一个epoch，然后要决定他能不能称为Finality，要通过投票，第一轮投票是一个Prepare Message，第二轮是Commit Message，Casper中规定了每一轮投票都要得到2/3以上Validator，才能通过，实际系统中，不区分两个Message，而且把这个epoch从原来的100个区块减少到50个区块，每个epoch只需要一轮投票就行了，这一轮投票对于上一个epoch来说，是Commit Message，对于下一个epoch来说，是一个Prepare Message，那么要连续两轮投票，两个epoch都得到2/3以上才算有效。</p>
</blockquote>
<p>​    原始的版本：</p>
<p><img src="/2020/11/10/%E5%8C%BA%E5%9D%97%E9%93%BE/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%9D%83%E7%9B%8A%E8%AF%81%E6%98%8E/QQ%E6%88%AA%E5%9B%BE20201112192940.png"></p>
<p>​    优化之后：（要有两个连续的epoch）</p>
<p><img src="/2020/11/10/%E5%8C%BA%E5%9D%97%E9%93%BE/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%9D%83%E7%9B%8A%E8%AF%81%E6%98%8E/QQ%E6%88%AA%E5%9B%BE20201112193242.png"></p>
<p>​    验证者参与这个过程有什么好处？</p>
<blockquote>
<p>如果验证者参与这个过程的话，可以得到相应的奖励，就像挖矿能得到出块奖励一样，相反，如果验证者有不良行为，被发现的话，要受到相应的处罚，比如某个验证者，行政不作为，该投票的时候没有投，结果导致系统迟迟达不成共识，那么这种情况下要扣除它的一部分保证金，如果某个验证者乱作为（乱投票，给两个有冲突的分叉都投票），要没收全部的保证金，没收的保证金被销毁，相当于减少了系统中以太币的总供应量，每个验证者有一定的任期，即使你交了保证金，也不是说你可以永远地当验证者，任期满了之后，要经过一定时间的等待期（为了让其他的结点可以检举揭发这个验证者有没有什么不良行为，进行惩处），如果等待期过了，验证者可以取回保证金和应该得到的奖励，这就是Casper协议的过程。</p>
</blockquote>
<p>​    我们原来说Casper协议可以给挖矿挖出来的区块链的某种状态做一个检查点（check point），这个检查点是不是一定安全的？</p>
<blockquote>
<p>通过这个验证者投票达成的Finality，有没有可能被推翻？以前说的，包含在Finality中的交易不会被推翻，这个是不是绝对的？</p>
<p>假设有某个有恶意的组织向要发动攻击，这个组织仅仅是矿工的话，那么他是没有办法推翻已经完成的Finality的，因为Finality是验证者投票投出来的，单纯是矿工的话，无论他算力有多强，如果没有验证者作为同伙，是没有办法推翻Finality，那么什么情况下会出现攻击成功的情况？</p>
<p>一定是由大量的验证者两边下注，给前后 两个有冲突的Finality下注。我们要求Casper协议每轮投票要有2/3以上支持才算通过，所以如果出现这种情况，那么至少是有1/3的验证者两边都投票的，一旦发现，1/3验证者的保证金将会被没收。</p>
</blockquote>
<p>​    所以我们可以看到，基于权益证明的共识机制和基于工作量证明的共识机制是很不一样的，以太坊的设想是，要逐步成工作量证明过渡到权益证明。随着时间的推移，挖矿得到的奖励是越来越少的，权益证明获得的奖励是越来越多的，最后达到完全不用挖矿的境界。</p>
<p>​    权益证明这么好，为什么以太坊不从一开始就用权益证明呢？</p>
<blockquote>
<p>因为权益证明不是很成熟，工作量证明是比较成熟的，经过了时间的检验，比特币和以太坊的挖矿算法都经过了bug bounty的检验，没有人发现什么漏洞，很多人认为权益证明是未来的方向，但是目前主流的加密货币，用的还是工作量证明。</p>
</blockquote>
<p>​    EOS加密货币就是完全基于权益证明的，用的协议是DPOS:Delegated Proof of stake，先用投票方法选出21个超级节点，然后再由这些超级结点产生区块。</p>
<p>​    到目前为止，都是假设，工作量证明消耗太多的电是不好的，但是也有人持有不一样的观点，首先挖矿消耗的电并不是很多，比特币的能耗只占全世界的总能耗的0.31%，以太坊只占0.09%，很多人对工作量证明很反感，是因为做的是无用功，其实挖矿对环境的影响是有限的，挖矿为解决边远地区用不到的电提供了一个很好的手段，把多余的电能转化为了加密货币，很多比特币的矿场都是建在电力资源丰富的地方，所以，可以认为挖矿消耗电能并不一定是坏事，可以有效地带动过量电能，带动经济的发展。</p>
]]></content>
      <categories>
        <category>区块链</category>
      </categories>
      <tags>
        <tag>区块链</tag>
      </tags>
  </entry>
  <entry>
    <title>ETH三---状态树</title>
    <url>/2020/10/04/%E5%8C%BA%E5%9D%97%E9%93%BE/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E7%8A%B6%E6%80%81%E6%A0%91/</url>
    <content><![CDATA[<h1 id="ETH-状态树"><a href="#ETH-状态树" class="headerlink" title="ETH-状态树"></a>ETH-状态树</h1><p>以太坊的账户是基于账户的模式，系统中显示的维护每个账户有多少余额。</p>
<p>我们需要完成的是账户地址，到账户状态的映射（addr(160 bits == 表示成40个16进制的数)-&gt;state）,这里的状态指的是外部账户和合约账户的状态。</p>
<a id="more"></a>

<p>①这有点像key-value对，给出一个账户地址，要找出一个相应的状态。如果就用一个哈希表怎么样？每创建一个账户就存入哈希表（不考虑哈希碰撞，它的效率是常量级的）</p>
<blockquote>
<p>用这个表的话，如果要提供Merkle proof，怎么提供？</p>
<p>比如说，你要和一个人签合同，希望他能证明一下他有多少钱，一种方法是，把这个哈希表中的元素（内容）组织成一个Merkle tree，然后算出一个根哈希值，这个根哈希值得保存在block header里，公布出去，那么这个根哈希值只要是正确的，就能保证底下的树不会被篡改。那如果有新的交易怎么办，新的交易必然会导致哈希表的内容变化，然后我们发布下一个区块的时候，要把这些哈希表中的内容在组织成一棵Merkle tree吗？这个代价会不会太大了点，实际上发生变化的状态只是一小部分。难道，比特币在构建新区块的时候就不用构建一颗新的Merkle tree吗？那个为什么没有这个问题？因为比特币发布的区块中的Merkle tree是通过区块中的交易来构建的，每个区块中的交易都不一样。如果像以太坊中的所有账户都构成一个Merkle tree来比较，代价就太大了（这比交易构成Merkle tree要高出好几个数量级）。</p>
<p>除了提供Merkle proof 证明账户上有多少钱之外，这个Merkle tree还有另外的作用：维护各个全节点之间状态的一致性（这也就是为什么比特币把根哈希值写在块头里的一个原因，对于这个区块中包含那些交易，全节点要有一个共识）。</p>
</blockquote>
<p>所以如果就简单的全节点在本地维护一个哈希表，然后需要Merkle tree的时候构建Merkle tree，根哈希值放在块头，这个方法是不行的。</p>
<p>②我们不需要哈希表了，直接就把所有的账户放进去，你要改的时候直接在Merkle tree里改，因为你每次更新的都是一小部分账户，所以你每次修改的都是Merkle tree中的一小部分？</p>
<blockquote>
<p>这个方法的问题在于，没有提供一个高效的查找和更新的方法，还有一个问题在于，我们这个Merkle tree要排序吗？如果不排序会怎么样？</p>
<p>​    如果不规定这些账户在叶子节点的顺序，那么构建出来的Merkle tree不是唯一的。系统中有很多的全节点，每个    全节点按照自己的某个顺序，构建一颗Merkle tree，最后构建出来的Merkle tree是不一样的。比特币中不也是不    排序吗？为什么比特币中就没有这个问题？</p>
<p>​    比特币中每个结点收到的交易顺序也是不一样的，所以理论上说，这样构建的Merkle tree也是不一样的，但是比    特币中的Merkle tree最终是获得记账权的结点说了算。</p>
<p>​    如果以太坊也这么做的话，需要把账户的状态发布到区块里（也就是每个全节点决定怎么把账户组织成一个Merkle tree），但是你是发布的账户的状态，不是交易的状态，差了好几个数量级。</p>
<p>如果使用排序的Merkle tree呢？</p>
<p>如果你新增一个账户怎么办，这个账户地址生成的时候是随机的，可能是在中间，那么后面的这些账户的结构都得变。其实可以这样：你产生一个新账户，其他人其实是没有必要知道的，当你产生交互的时候或者别人往里面转账别人才需要知道，当产生交易需要把这个账户加入到数据结构中，问题在于，这个代价有多大？如果你用哈希表的话，代价是常量级的，如果直接使用账户的哈希，这个代价可能得重构这个数据结构。</p>
</blockquote>
<p>以太坊采用的做法：</p>
<p>首先介绍trie（中文叫做字典树）的数据结构。</p>
<p><img src="/2020/10/04/%E5%8C%BA%E5%9D%97%E9%93%BE/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E7%8A%B6%E6%80%81%E6%A0%91/QQ%E6%88%AA%E5%9B%BE20200928200145.png"></p>
<p>这个结构的特点：</p>
<blockquote>
<p>①在trie中，每个节点的分支数目，取决于这个key值里每个元素得取值范围，这个例子中，每个结点得分支个数最多是26个加上一个结束标志位，表示这个单词到这是不是就结束了。</p>
<p>②trie的查找效率，取决于这个key的长度。</p>
<p>③如果使用哈希表来存储这个key-value对，从理论上说，是有可能出现哈希碰撞（两个地址不一样，但是它的内容碰巧一样）的，但是trie是如果两个的地址不一样，最后肯定映射到树中的不同分支，所以trie不会出现碰撞</p>
<p>④我们前面讲的Merkle tree，如果你不排序，一个问题是，你的账户插入到Merkle tree中的顺序不一样 ，Merkle tree的结构也不一样，trie中只要给定一组输入，这个输入不变，最后插入这个trie当中是一样的。</p>
<p>⑤每次发布一个区块，系统中的绝大多数状态是不变的，只有个别受到影响的状态才会变，所以更新操作的局部性很重要，要想访问genesis，只要访问对应的分支即可，更新的局部性也是很好的</p>
</blockquote>
<p>但是trie也有缺点：只有一个分支的情况很浪费内存，如果能把一个分支的分支合并起来，就能够提高存储的开销，同时提高查找和更新的开销，这就引入了我们的Patricia tree（trie）[经过路径压缩的前缀树]，如果经过路径压缩，上例就变成了下图：</p>
<p><img src="/2020/10/04/%E5%8C%BA%E5%9D%97%E9%93%BE/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E7%8A%B6%E6%80%81%E6%A0%91/QQ%E6%88%AA%E5%9B%BE20200928202332.png"></p>
<p>对于Patricia tree来说，如果你需要添加结点，原来压缩的结点可能会需要扩展开来，路径压缩在什么情况下比较好？</p>
<blockquote>
<p>树中插入的这些键值的分布如果是比较稀疏的情况下。比如上图中的，每个单词都很长，但是总共没有多少个单词的时候。</p>
<p>例如：下图的三个单词插入一个普通的tria中，效率就变得特别低</p>
<p><img src="/2020/10/04/%E5%8C%BA%E5%9D%97%E9%93%BE/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E7%8A%B6%E6%80%81%E6%A0%91/QQ%E6%88%AA%E5%9B%BE20201003181750.png"></p>
<p>如果用Patricia tree，如下图</p>
<p><img src="/2020/10/04/%E5%8C%BA%E5%9D%97%E9%93%BE/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E7%8A%B6%E6%80%81%E6%A0%91/QQ%E6%88%AA%E5%9B%BE20201003181926.png"></p>
</blockquote>
<p>在以太坊中是怎么样的？</p>
<p>我们在前面讲过，地址表示成40个16进制的数，所以这个分叉数目，有时候管他叫做branching factor（17 == 16个[0 - f] 加上一个结束标志位），比特币和以太坊的地址是不通用的，两个地址的格式、长度都是不一样的，有一点是一样的，以太坊中的地址，也是公钥经过转化得来的（公钥取哈希，截一段，前面不要，只要后面的一部分）</p>
<p>那么我们这个应用场景（以太坊）中键值是否是稀疏的呢？</p>
<blockquote>
<p>键值是地址，160位，总共的地址空间有2^160，以太坊中全世界的账户数目加在一起也远远没有这么大，所以以太坊的账户是非常非常稀疏的。</p>
</blockquote>
<p>为什么不把账户地址缩短一点？这样访问效率还快，也没必要那么稀疏了</p>
<blockquote>
<p>更大地避免哈希碰撞，这是一个去中心化的系统防止账户冲突的唯一办法。</p>
</blockquote>
<h2 id="MPT"><a href="#MPT" class="headerlink" title="MPT"></a>MPT</h2><p>Merkle Patricia tree</p>
<p>和Patricia tree有什么区别？</p>
<blockquote>
<p>把普通指针换成了哈希指针，所有的账户组织成一个Patricia tree，用路劲压缩提高效率，然后把普通指针换成哈希指针，所以就能计算出一个根哈希值，存放在block header里。比特币有一个根哈希值（这个区块里所有交易组成的根哈希值），以太坊中有三个，这里讲的是状态树。</p>
</blockquote>
<p>这个根哈希值有什么用？</p>
<blockquote>
<p>①防止篡改，只要根哈希值不变，整棵树的任何部分都没有办法被篡改。</p>
<p>②Merkle Proof，这棵树能证明什么？能证明每个账户的余额：这个账户所在的分支，作为Merkle Proof，发给轻结点，轻结点就可以验证账户上有多少钱。</p>
<p>③能不能证明一个账户是不存在的？你想给一个账户转账之前，你想验证一下节点里，有没有这个账户信息，证明方法和sorted Merkle tree类似，如果存在是存在什么样的分支里，把这个分支作为Merkle tree发出去，可以证明它是不存在的。</p>
</blockquote>
<p>以太坊中用到的还不是原生的MPT，以太坊中使用的是Modified MPT：</p>
<p><img src="/2020/10/04/%E5%8C%BA%E5%9D%97%E9%93%BE/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E7%8A%B6%E6%80%81%E6%A0%91/QQ%E6%88%AA%E5%9B%BE20201003184519.png"></p>
<p>根节点取得的根哈希值KECCAK256是要写在块头里的，这里的指针都是哈希指针。</p>
<p>每次发布一个新的区块的时候，这个状态树中有一些结点的值会发生变化，这些改变不是在原地改的，而是新建一些分支，原来的状态其实是保留下来的：</p>
<p>我们可以看到，虽然每个区块都有一个状态树，但是这两棵树的大部分节点，是共享的，只有那些发生改变的节点，是需要新建一个分支的，这个例子中合约账户发生了变化（因为他有code，还有存储），合约账户的存储也是用MPT的形式保存下来的，这个存储其实也是一个key-value，维护的是从变量到这个变量取值的映射，所以以太坊中的结构是一个大的MPT，包含很多小的MPT（每个合约账户的存储都是一棵小的MPT） </p>
<p><img src="/2020/10/04/%E5%8C%BA%E5%9D%97%E9%93%BE/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E7%8A%B6%E6%80%81%E6%A0%91/QQ%E6%88%AA%E5%9B%BE20201003185717.png"></p>
<p>这个例子中，nonce、balance发生了变化，code不变，所以Codehash指向原来树中的节点，存储中大部分结点也是没有变化，只有一个节点发生了变化，整数变量从29变为了45，所以新建了一个分支。</p>
<p>所以，系统中的全节点维护的不是一棵MPT，而是每次出现一个区块，都要新建一个MPT，只不过这些状态树中大部分节点是共享的，只有少数发生变化的节点是需要新建分支的，那么，为什么要保留历史状态？（为什么不在原地直接改了）</p>
<blockquote>
<p>系统中可能会出现分叉，临时性的分叉实际上是很普遍的，以太坊把出块时间降到十几秒之后，临时性的分叉是常态。</p>
<p><img src="/2020/10/04/%E5%8C%BA%E5%9D%97%E9%93%BE/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E7%8A%B6%E6%80%81%E6%A0%91/QQ%E6%88%AA%E5%9B%BE20201003190631.png"></p>
<p>回滚的话，就需要维护这些历史记录，不是为了证明我以前有多少钱，而是因为当前这个交易有可能要undo，</p>
<p>比特币中简单的转账交易是很容易的，以太坊中为什么不行？</p>
<p>以太坊中有智能合约，以太坊如果不保存原来的状态，智能合约执行完成之后，你想要roll back，这是不可能的。</p>
</blockquote>
<p>以太坊中代码的数据结构：</p>
<p>block header：</p>
<p><img src="/2020/10/04/%E5%8C%BA%E5%9D%97%E9%93%BE/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E7%8A%B6%E6%80%81%E6%A0%91/QQ%E6%88%AA%E5%9B%BE20201003191125.png"></p>
<p>ParentHash：前一个区块块头的哈希值</p>
<p>uncleHash：叔父区块的哈希值（ghost协议中会提到）[uncle可能回避parent大很多辈分]</p>
<p>CoinBase：挖出这个区块的矿工的地址</p>
<p>Root：状态数的根哈希</p>
<p>TxHash：交易树的根哈希值</p>
<p>ReceiptHash：收据树的根哈希值</p>
<p>Bloom：和收据树相关，提供一种高效的查询，符合某种条件的交易的执行结果</p>
<p>Difficulty：挖矿的难度，会根据需要调整</p>
<p>GasLimit、GasUsed：和汽油费相关，有点类似比特币中的交易费</p>
<p>Time：这个区块大致的产生时间</p>
<p>MixDigest、Nonce：和挖矿过程相关，Nonce：类似于比特币中的随机数；MixDigest是从Nonce通过一些计算出来的哈希值。</p>
<p>区块的结构：</p>
<p><img src="/2020/10/04/%E5%8C%BA%E5%9D%97%E9%93%BE/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E7%8A%B6%E6%80%81%E6%A0%91/QQ%E6%88%AA%E5%9B%BE20201003191918.png"> </p>
<p>header：指向block header的指针</p>
<p>uncles：指向叔父区块block header的指针（数组类型）</p>
<p>transactions：交易列表</p>
<p>区块真正在网上发布的信息：</p>
<p><img src="/2020/10/04/%E5%8C%BA%E5%9D%97%E9%93%BE/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E7%8A%B6%E6%80%81%E6%A0%91/QQ%E6%88%AA%E5%9B%BE20201003192042.png"></p>
<p>状态树中保存的是key-value pair，key就是地址， 我们前面所讲的都是key（地址的管理方式），那么这个value（账户的状态）呢？</p>
<blockquote>
<p>实际上是要经过一个序列化的过程：RLP（Recursive Length Prefix），极简主义，和protocal buffer相比；它只支持一种类型：nested array of bytes，说白了就是字节数组，以太坊的其他所有类型（整数、哈希表），最后都得变成nested array of bytes，所以你要实现一个RLP，比较容易。</p>
</blockquote>
]]></content>
      <categories>
        <category>区块链</category>
      </categories>
      <tags>
        <tag>区块链</tag>
      </tags>
  </entry>
  <entry>
    <title>ETH二---账户</title>
    <url>/2020/10/04/%E5%8C%BA%E5%9D%97%E9%93%BE/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E8%B4%A6%E6%88%B7/</url>
    <content><![CDATA[<h1 id="以太坊的账户"><a href="#以太坊的账户" class="headerlink" title="以太坊的账户"></a>以太坊的账户</h1><p>比特币是基于交易的账本模式，这种模式下，并没有显式地记录每个账户有多少钱，这种模式的好处是，隐私保护得比较好，你有多少钱，可能连你自己都说不清楚，别人就更搞不明白了。</p>
<blockquote>
<p>别人转到你账上的钱，你一定要花出去，比如别人转给你10个，你花了3个比特币，你必须把剩余的7个比特币再转回给自己的另外一个账户，要不然这7个比特币全都会被当成tx fee给矿工了</p>
</blockquote>
<a id="more"></a>

<p>以太坊设计了一个基于账户的交易模型account-based ledger：系统上显式地记录账户上有多少个以太币</p>
<p><img src="/2020/10/04/%E5%8C%BA%E5%9D%97%E9%93%BE/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E8%B4%A6%E6%88%B7/QQ%E6%88%AA%E5%9B%BE20200925195000.png"></p>
<p>上述，也不需要把币转给自己，剩下的ETH放在自己的账户上就可以了，上面的指针也不需要了</p>
<p><img src="/2020/10/04/%E5%8C%BA%E5%9D%97%E9%93%BE/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E8%B4%A6%E6%88%B7/QQ%E6%88%AA%E5%9B%BE20200925195122.png"></p>
<p>这样做的一个好处是什么？</p>
<blockquote>
<p>以太坊的这种模式，对double spending attack有天然的防御作用：花钱就扣余额，你要花两次，我就扣两次。</p>
<p>但是，如果有人篡改余额怎么办？</p>
<p>你消费的时候不需要指出你的余额，而是从全节点中维护的一个状态树中的一个状态<code>balance</code>查找（后面会说明）,这个<code>balance</code>无法篡改</p>
<p>但是还有一种重放攻击（replay attack），A给B转账，B有恶意，将A给B转账的交易重放了一次，这样不就可以扣除A的两次余额吗？</p>
<p>防止这种攻击的做法其实有多个：可以增加一个nonce（记录A转账（消费）的次数），如果有人想重放这个交易，就会发现，这个交易已经被执行过了，就不会再执行一遍了。</p>
</blockquote>
<p>以太坊中有两类账户，一类叫做外部账户</p>
<p>①externally owned account，其中有两个属性balance 和nonce </p>
<p>②smart contract account，有balance nonce、code（代码）以及storage（相关的状态），合约账户不是通过公私钥对来管理的，不是你有这个合约账户的公私钥就有这个账户的控制权，一个合约可以调用另外一个合约（所以它同样需要一个nonce来记录一下合约调用的次数），但是智能合约账户不能主动发起一个交易（所有的交易只能由外部账户发起，外部账户发起了一个交易，如果调用了一个合约账户，这个合约账户可以发送一个message调用一个合约账户）</p>
<p>合约账户怎么被调用？你创建合约的时候，会返回一个地址，知道这个合约的地址就可以调用这个合约，状态（storage）会发生变化，代码不变。</p>
<p>为什么要创建这样一种新的模型？</p>
<blockquote>
<p>比特币基于交易的账户的好处：隐私的保护比较好一点，以太坊注重的是智能合约，要求合约参与者要有比较稳定的身份。</p>
</blockquote>
<p>现在有人提出的一些智能合约的衍生品：financial derivative，比如说你投钱投给一个合约账户，合约账户的地址变了，你找不到了就比较麻烦，以太坊在创建的时候，考虑到了已有的一些模型的利弊得失，最终没有采用比特币中基于交易的账户模型。</p>
]]></content>
      <categories>
        <category>区块链</category>
      </categories>
      <tags>
        <tag>区块链</tag>
      </tags>
  </entry>
  <entry>
    <title>ETH七---以太坊难度调整</title>
    <url>/2020/11/09/%E5%8C%BA%E5%9D%97%E9%93%BE/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E9%9A%BE%E5%BA%A6%E8%B0%83%E6%95%B4/</url>
    <content><![CDATA[<h1 id="难度调整"><a href="#难度调整" class="headerlink" title="难度调整"></a>难度调整</h1><p>​    比特币是每隔2016个区块会调整一下挖矿难度，目标是维持出块时间十分钟左右，以太坊是每个区块都有可能调整挖矿难度，调整的方法也比较复杂，而且改过好几个版本，我们遵循以代码的原则。</p>
<a id="more"></a>

<h2 id="难度调整算法"><a href="#难度调整算法" class="headerlink" title="难度调整算法"></a>难度调整算法</h2><p> <img src="/2020/11/09/%E5%8C%BA%E5%9D%97%E9%93%BE/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E9%9A%BE%E5%BA%A6%E8%B0%83%E6%95%B4/QQ%E6%88%AA%E5%9B%BE20201103215359.png"></p>
<p>​    上图中的H指的是当前区块，Hi是当前区块的序号D(H)是当前区块的难度，难度调整的公式由两部分，max中的是第一部分，ε指的是“难度炸弹”，主要是为了向权益证明过渡，将来的以太坊想把共识机制从工作量证明逐步转入权益证明，第一部分调整的方法，是在父区块难度基础上加上一些自调整的部分，P(H)就是父区块的难度（所谓的父区块就是当前区块链的最后一个区块，对于我们正在挖的这个区块来说，他是这个区块的父区块），第一部分的难度调整有一个下限，就是这里的D0，这一部分，不论你怎么样调整，最小不能低于这个难度（这是为了保证挖矿有个最低的难度）</p>
<p><img src="/2020/11/09/%E5%8C%BA%E5%9D%97%E9%93%BE/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E9%9A%BE%E5%BA%A6%E8%B0%83%E6%95%B4/QQ%E6%88%AA%E5%9B%BE20201103215518.png"></p>
<p>​    x是调整的力度，是父区块的难度除以2048，所以调整难度的时候，不论是上调还是下调，都是按照这个力度的整数倍进行调整的，按照父区块的1/2048作为调整的一个单位，下面这个奇怪的符号叫做ε，ε的取值和两个因素有关，一个是出块时间，另外一个就是有没有叔父区块（就是父区块有没有叔父区块），那么为什么要和叔父区块相关呢？</p>
<blockquote>
<p>因为如果是当前区块的最后一个区块，它包含有叔父区块的话，那么这个时候系统的货币总供应量是增加的，因为叔父区块要得到叔父奖励，包含叔父区块的这个父区块也要得到一部分的奖励，所以这两个合在一起就会使总供应量增加，它为了维持系统的总供应量的稳定，所以当前正在挖的这个区块的难度就要提高一个单位</p>
</blockquote>
<p>​    后面这个-99，是说难度调整这个系数部分有一个下限，就是说，max前面这个部分，有可能是正的，也有可能是负的，如果是负的话，说明难度要往下调，那么最多一次性只能调整99个单位，每个单位是刚才说的父区块的1/2048，所以一次性下调难度最多是99/2048。</p>
<p>​    <img src="/2020/11/09/%E5%8C%BA%E5%9D%97%E9%93%BE/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E9%9A%BE%E5%BA%A6%E8%B0%83%E6%95%B4/QQ%E6%88%AA%E5%9B%BE20201103220442.png"></p>
<p>​    y取决于又没哟叔父区块，如果有的话，y = 2，没有的话，y = 1，不论是那种情况，y都是一个常数减去后面这一项，如果后面这一项比前面这个大的话，减出来是个负数，说明难度是要下调的，相反，上调</p>
<p><img src="/2020/11/09/%E5%8C%BA%E5%9D%97%E9%93%BE/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E9%9A%BE%E5%BA%A6%E8%B0%83%E6%95%B4/QQ%E6%88%AA%E5%9B%BE20201103221000.png"></p>
<p>​    如果出块时间更长，下调的幅度就要更大，但是不要忘了那个-99，如果单次出块时间非常非常长，也不能下调大于99个单位。</p>
<p><img src="/2020/11/09/%E5%8C%BA%E5%9D%97%E9%93%BE/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E9%9A%BE%E5%BA%A6%E8%B0%83%E6%95%B4/QQ%E6%88%AA%E5%9B%BE20201103221155.png"></p>
<p><img src="/2020/11/09/%E5%8C%BA%E5%9D%97%E9%93%BE/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E9%9A%BE%E5%BA%A6%E8%B0%83%E6%95%B4/QQ%E6%88%AA%E5%9B%BE20201103221326.png"></p>
<p>​    以太坊的工作机制要从工作量证明逐步转入权益证明，而权益证明是不挖矿的，这就带来一个问题：那些已经在挖矿设备上投入了大量资金的矿工，会不会联合起来抵制这个转换，本来工作量证明转向权益证明就是经过硬分叉来实现的（相当于你改了共识协议了），如果有人因为不愿意抛弃矿机，那么以太坊可能会分裂成两条链。</p>
<blockquote>
<p>为了避免这种情况，所以以太坊在设计难度调整公式的时候加了一个难度炸弹。</p>
<p>当初设计难度炸弹的时候，是没有第二行的（Hi’ = max（Hi - 3000000，0）），当前的区块号除以十万向下取整，然后作为2的指数，也就是说难度炸弹这部分的取值是呈指数形式成长的，那么指数函数的特点是什么呢？</p>
<p>早期的时候，以太坊刚刚上线不久的时候，区块号都比较小，那么难度炸弹这部分算出的值，是很小的，基本上可以忽略不计，难度调整主要是由刚才讲完的第一部分来决定的，或者说是由系统中的出块时间来决定的，然而随着时间的推移，区块号变得越来越大，这个时候难度炸弹的威力主键显现出来，指数函数增长到后期，速度是非常恐怖的，所以当初设计的思想是，等到这个难度炸弹的威力开始发挥出来的时候，也正好是以太坊需要从工作量证明，转入权益证明的时候，那个时候，因为挖矿变的越来越难了，所以大家也就愿意转入权益证明了，因为你不转的话，挖出矿来，就太费劲了。这是当初设计以太坊的一个“如意算盘”，但实际情况怎么样？</p>
<p>基于权益证明的共识机制实际设计出来有很多问题要解决，远远没有当初想象的那么顺利，这样造成的结果就是，转入权益证明的时间点被一再推迟，然后出现的情况，是挖矿已经变的越来越难了，因为难度炸弹的威力已经显现出来了，但是大家还是得继续挖，因为没有别的方法可以达成共识。（现在是希望大家转，但是现在得情况是，你想转也转不了），这个情况在2017年的四五月份到中旬的时候，就已经很明显了，出块时间就逐渐地开始增长了，原来是说要稳定在15秒，那个时候就已经不断地增加了，最后增加到了30秒左右，如果不采取措施还会继续增长上去。</p>
<p>那么怎么办呢？</p>
<p>可以看到上面的公式是将区块号回退了，用真实地区块号减去三百万计算出来一个假的区块号，然后用这个假的区块号去计算难度炸弹，这给权益证明的上线争取了一些时间，那么这样做的结果怎么样？</p>
<p><img src="/2020/11/09/%E5%8C%BA%E5%9D%97%E9%93%BE/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E9%9A%BE%E5%BA%A6%E8%B0%83%E6%95%B4/QQ%E6%88%AA%E5%9B%BE20201109195508.png"></p>
<p>前半部分按照原来的算法计算的，呈指数形式上升，到达最高的位置就是以太坊决定回调这个难度炸弹的区块号的时候，所以一下就掉下来了。（前面那个部分其实也在增长，但是因为“尖峰太高了”，所以不太明显）</p>
</blockquote>
<h2 id="以太坊的发展"><a href="#以太坊的发展" class="headerlink" title="以太坊的发展"></a>以太坊的发展</h2><p><img src="/2020/11/09/%E5%8C%BA%E5%9D%97%E9%93%BE/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E9%9A%BE%E5%BA%A6%E8%B0%83%E6%95%B4/QQ%E6%88%AA%E5%9B%BE20201109200049.png"></p>
<p>​    BIP:BitCoin Improvement Proposal。</p>
<p>​    为什么在回调区块的同时，还要把block reward降低？</p>
<blockquote>
<p>因为如果不这么调的话，对之前的矿工是不公平的（这个回调是突然进行的，一夜之间突然降低，对之前挖矿的矿工就不太公平，而且也要维护系统中供应量的稳定）</p>
</blockquote>
<p>​    需要注意的是：比特币出块奖励每过一段时间减半的操作，在以太坊中是没有的，5个以太币降为3个是一次性的，并不是说定期都会这么做。</p>
<p><img src="/2020/11/09/%E5%8C%BA%E5%9D%97%E9%93%BE/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E9%9A%BE%E5%BA%A6%E8%B0%83%E6%95%B4/QQ%E6%88%AA%E5%9B%BE20201109200939.png"></p>
<blockquote>
<p>上图是“拜占庭”阶段调整挖矿难度的代码，输入时父区块的时间戳和父区块的难度，计算出当前正在挖的这个区块的难度，难度计算公式和前文所讲的是一样的。（括号里面是第一部分，后面是难度炸弹）</p>
<p>bigTime：当前区块的时间戳，bigParentTime：夫区块的时间戳</p>
</blockquote>
<p><img src="/2020/11/09/%E5%8C%BA%E5%9D%97%E9%93%BE/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E9%9A%BE%E5%BA%A6%E8%B0%83%E6%95%B4/QQ%E6%88%AA%E5%9B%BE20201109201522.png"></p>
<p>最后那个“if”是指最低不能小于那个D0</p>
<p><img src="/2020/11/09/%E5%8C%BA%E5%9D%97%E9%93%BE/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E9%9A%BE%E5%BA%A6%E8%B0%83%E6%95%B4/QQ%E6%88%AA%E5%9B%BE20201109201802.png"></p>
<blockquote>
<p>上图难度炸弹的计算之所以不减三百万，是因为判断的是父区块的序号，而我当前正在挖的区块，区号要大1</p>
<p>x是算出来的基础部分的值。</p>
</blockquote>
<p><img src="/2020/11/09/%E5%8C%BA%E5%9D%97%E9%93%BE/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E9%9A%BE%E5%BA%A6%E8%B0%83%E6%95%B4/QQ%E6%88%AA%E5%9B%BE20201109202213.png"></p>
<blockquote>
<p>上图是以太坊挖矿难度的变化曲线，在以太坊的早期，挖矿难度的变化是不明显的，当时以太坊市值很小，谁也没有想到以太坊会成为一个主流的加密货币，从2017年开始，挖矿难度的增长就比较明显了，尤其是难度炸弹这一部分。</p>
<p><img src="/2020/11/09/%E5%8C%BA%E5%9D%97%E9%93%BE/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E9%9A%BE%E5%BA%A6%E8%B0%83%E6%95%B4/QQ%E6%88%AA%E5%9B%BE20201109202454.png"></p>
</blockquote>
<p><img src="/2020/11/09/%E5%8C%BA%E5%9D%97%E9%93%BE/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E9%9A%BE%E5%BA%A6%E8%B0%83%E6%95%B4/QQ%E6%88%AA%E5%9B%BE20201109202746.png"></p>
<blockquote>
<p>上图是出块时间的变化，如果不考虑一些小的波动的话，总体来说，出块时间稳定在15秒上下，有了很长的时间，说明在早期的时候，挖矿难度的调整，主要是以稳定出块时间为主的。</p>
<p><img src="/2020/11/09/%E5%8C%BA%E5%9D%97%E9%93%BE/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E9%9A%BE%E5%BA%A6%E8%B0%83%E6%95%B4/QQ%E6%88%AA%E5%9B%BE20201109202933.png"></p>
<p>难度炸弹回调之后，总的挖矿难度主键又恢复到了原来的水平，这个是因为，挖矿变容易之后，有更多的矿工加入，竞争更激烈了，而这个图从出块时间的角度来看，并没有受到影响。</p>
<p><img src="/2020/11/09/%E5%8C%BA%E5%9D%97%E9%93%BE/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E9%9A%BE%E5%BA%A6%E8%B0%83%E6%95%B4/QQ%E6%88%AA%E5%9B%BE20201109203237.png"></p>
<p><img src="/2020/11/09/%E5%8C%BA%E5%9D%97%E9%93%BE/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E9%9A%BE%E5%BA%A6%E8%B0%83%E6%95%B4/QQ%E6%88%AA%E5%9B%BE20201109203553.png"></p>
<p>我们所说的最长合法链，对于以太坊来说其实是最“难”合法链，每个区块的难度反应挖出这个区块所需要的工作量，而总难度最大，就是挖出这条链所有区块需要的总工作量最大，一般来说，靠后的区块，挖出来的工作量是比较大的。</p>
</blockquote>
]]></content>
      <categories>
        <category>区块链</category>
      </categories>
      <tags>
        <tag>区块链</tag>
      </tags>
  </entry>
  <entry>
    <title>BTC九---分叉</title>
    <url>/2020/09/09/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%88%86%E5%8F%89/</url>
    <content><![CDATA[<h1 id="分叉"><a href="#分叉" class="headerlink" title="分叉"></a>分叉</h1><p>fork:原来是一条链，现在是两条链形成了分叉。有两种情况：</p>
<p>①如果同时有两个结点发布了区块，这时候就会形成分叉：state fork，由于对比特币这个区块链当前的区块状态有意见分歧而导致的分叉，forking attack也属于state fork，只不过分叉攻击这个意见分歧是故意造成的，所以有时候我们管这个叫deliberate fork。</p>
<p>②比特币的协议发生了改变，要修改比特币的协议，需要软件升级，在一个去中心化的系统里，在升级软件的时候，没有办法保证所有的结点同时都升级软件，我们假设大部分结点升级了软件，少数结点因为种种原因没有升级，有可能还没有来的及升级，也可能是不同意这个协议的修改，这种分叉叫做protocol fork，因为对比特币的协议产生了分歧，因为使用不同的协议造成了分叉。</p>
<a id="more"></a>

<blockquote>
<p>可以根据对协议修改的内容的不同，分为硬分叉（hard fork）和软分叉（soft fork）</p>
</blockquote>
<p>什么是硬分叉？什么是软分叉？</p>
<h2 id="hard-fork"><a href="#hard-fork" class="headerlink" title="hard fork"></a>hard fork</h2><p>出现硬分叉的情况，如果对比特币协议增加新的特性，有一些new feature，这些没有升级软件的那些旧的节点，他是不认可这些新特性的，他认为这些new feature是不合法的。这个时候就属于我们对比特币协议的内容产生了意见分歧，就会导致分叉。一个例子就是：比特币中的区块大小限制（block size limit）。</p>
<blockquote>
<p>比特币规定每个区块是1M字节，有些人认为1M这个限制太小了，增加了比特币的延迟。</p>
<p>一个交易差不多可以认为是250个字节，所以1000000字节大概是4000个交易左右，平均十分钟一个区块，算下来大概是每秒钟七笔交易</p>
<p><img src="/2020/09/09/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%88%86%E5%8F%89/QQ%E6%88%AA%E5%9B%BE20200907211038.png"></p>
<p>我们用信用卡处理交易和这个完全不是一个数量级的，很多电商网站很多都不止这些，所以有的人认为这个区块太小了，限制了比特币的throw put（不知道老师是不是说的这个），同时也增加了延迟，因为你区块就只能装这么多区块，如果交易太多了的话，那可能有些交易，就得等到下一个区块才能被发布，平均要等十分钟</p>
</blockquote>
<p>我们假设有人发布了软件更新，把这个block size limit从1M增加到了4M（大多数结点更新了这个软件，少数节点没有更新【这里所说的节点数目不是按照账户的数目来算的，是按照算力的多少来算的】），这个时候系统运行起来会有什么结果？</p>
<p><img src="/2020/09/09/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%88%86%E5%8F%89/QQ%E6%88%AA%E5%9B%BE20200907212426.png"></p>
<p>备注：图中的解释有错误，应该是新产生的区块，旧结点不认可</p>
<p><img src="/2020/09/09/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%88%86%E5%8F%89/QQ%E6%88%AA%E5%9B%BE20200907212813.png"></p>
<p>备注：图中的“就”为“旧”</p>
<p>只要这些旧结点不更新软件，分叉就不会消失，这就是为什么管他叫硬分叉（hard fork）。</p>
<p>比特币社区中，有些人是比较保守的，像这种block size limit这种new feature，有些人真的是不会同意，而且，区块的大小不是越大越好（详情看比特币网络）。</p>
<p>如果存在了硬分叉，那么下面的那一条链的出块奖励还有吗？</p>
<blockquote>
<p>是有的（在各自的链上是承认的），会造成社区的分裂，如果一直存在下去，就会分家了，相当于变成了两种币，原来没有分裂的币，应该变成上下两条链都认可。</p>
<p><img src="/2020/09/09/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%88%86%E5%8F%89/QQ%E6%88%AA%E5%9B%BE20200907214138.png"></p>
<p>后来有了一个措施：在各自的链上加上一个chain ID</p>
</blockquote>
<h2 id="soft-fork"><a href="#soft-fork" class="headerlink" title="soft fork"></a>soft fork</h2><p>软分叉出现的情况？如果我们对比特币协议加一些限制。加这个限制之后，原来合法的交易或者是合法的区块，在新的协议中，有可能变得不是合法了，这就引起软分叉。</p>
<p>举例：</p>
<p>如果有人发布了软件更新，block size limit缩小了，由1M变成0.5M（实际上不会这样做，因为1M已经是比较小的了）</p>
<p><img src="/2020/09/09/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%88%86%E5%8F%89/QQ%E6%88%AA%E5%9B%BE20200909193415.png"></p>
<p>实际当中可能出现软分叉的情况</p>
<p>①给某些目前协议中没有规定的域增加一些新的含义，赋予他们一些新的规则：coinBase域，每个发布的区块里可以有一个铸币交易，coinBase可以有个特别的用途（作为extra nonce 拿出8bytes），其实coinBase不止8个字节，那其他字节干嘛用呢？有人就建议，把他作为UTXO集合的根哈希值，目前这个集合只是全节点自己在内存中维护这样一个集合，主要是为了快速查找能够交易是不是double spending，但是这个集合的内容并没有写到区块链，这个和我们说的Merkle proof不太一样。</p>
<p>如果你要证明某个账户上有多少钱，如果你是全节点的话，可以算一下，就是看一下A这个账户在这个UTXO里对应的输出上面一共收到多少个币，就是A账户上有多少钱。</p>
<p>有很多区块链钱包（手机上的app），他不可能在手机上维护一个全结点，他需要知道账户的余额，需要询问其他的全节点，那么全节点返回一个结果，你怎么知道他是不是对的？</p>
<blockquote>
<p>你现在是证不出来的，你自己如果没有维护一个UTXO集合，是没有办法用Merkle proof证出来的，所以有人就提议：</p>
<p>把UTXO集合当中的内容也组织成一条Merkle tree，这个Merkle tree有一个根哈希值，这个哈希值写在coinBase中，因为你block header没有办法再改了（block header动静太大了），coinBase中的内容在网上传递的时候，最终会传递到block header中，这样的话，你就可以用Merkle proof证出来</p>
</blockquote>
<p>有人发布软件更新，规定coinBase域要这样写，这样是硬分叉还是软分叉？软分叉，因为新节点发布的区块，旧结点认为是合法的，因为旧结点不管你coinBase什么内容，都认为是合法的，但是旧结点发布的区块，新节点可能是不认的。</p>
<p>比特币历史上，一个比较著名的软分叉的例子，是P2SH（Pay to Script Hash），这个在最初的比特币版本里是没有的，是后来通过软分叉加进去的：</p>
<p>你支付的时候，不是付给一个Public Key的哈希，而是付给一个赎回脚本的哈希，这是新节点要做的；而对于旧结点，他不理解P2SH的特性，他只会做第一阶段的验证，所以，旧结点认为合法的交易，新节点可能认为是非法的</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>soft fork：只要系统中有半数以上的结点更新了软件，就不会出现永久的分叉，可能会出现临时的分叉。</p>
<p>hard fork：必须是所有的节点都要更新软件，系统才不会出现永久性的分叉，如果有小部分节点不愿意更新，那么这个系统就会分成两条链。</p>
]]></content>
      <categories>
        <category>区块链</category>
      </categories>
      <tags>
        <tag>区块链</tag>
      </tags>
  </entry>
  <entry>
    <title>BTC十二---思考</title>
    <url>/2020/10/04/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%80%9D%E8%80%83/</url>
    <content><![CDATA[<h1 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h1><h2 id="哈希指针"><a href="#哈希指针" class="headerlink" title="哈希指针"></a>哈希指针</h2><p>比特币系统在设计的时候，很多地方都使用到了哈希指针，比如区块的块头，就包括了前一个区块的指针，指针保存的是本地内存的地址，那么只是在本地计算机上才有意义，发布到别的计算机上就没有意义了，那么哈希指针是怎么通过网络进行传输的呢？</p>
<a id="more"></a>

<blockquote>
<p>所谓的哈希指针，只是一种形象的说法，实际系统中使用的时候，只有哈希，没有指针。</p>
<p><img src="/2020/10/04/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%80%9D%E8%80%83/QQ%E6%88%AA%E5%9B%BE20200923185402.png"></p>
<p>那么怎么找到前一个区块的内容呢？</p>
<p>全节点一般是把这个区块存储在一个（key，value）的数据库（这里面的key就是前一个区块的哈希，value就是区块的内容）里面，常用的数据库是levelDB。</p>
<p>所谓的区块链的链表结构，实际上是在levelDB里用哈希值串起来的，只要你掌握最后一个区块的哈希值，就可以把最后一个区块中的内容取出来，然后通过这个区块中的上一个区块的哈希值，找到前一个区块的内容，这样一步一步往前找，就可以把所有的区块都找出来。所以实际中，只有哈希，没有指针，或者可以认为哈希值就是指针。哈希指针的性质，保证了区块链中的内容是不可篡改的。</p>
</blockquote>
<h2 id="区块恋"><a href="#区块恋" class="headerlink" title="区块恋"></a>区块恋</h2><p>据说17年七夕的时候，有的情侣，两个人合在一起买比特币，然后把私钥从中间截断，分成两部分，每人保存其中的一段，将来如果两个人继续好下去的话，那么两段私钥合在一起就能把钱取出来，如果两个人分手了，比特币就被永久地锁在了区块链上。</p>
<p>按照这种逻辑，如果推到n个人，如果有四个合伙人，就应该把私钥切成四份，每个人掌握其中的一份，需要用的时候，四个人的私钥合在一起才能用，这样有什么问题？</p>
<blockquote>
<p>①任何一个人把私钥丢了，这个钱就取不出来了。</p>
<p>②这种截断私钥的做法，会降低比特币账户的安全性：比特币系统中账户的安全性是和每个账户私钥的长度是相关的，256位的私钥，尽管你把世界上所有的电脑集中起来破解，也是不可能成功的，但是你从中截断，128位的长度，他的可能性就远远小于2^256次方个，破解的难度变得容易很多了，如果其中三个合伙人，瞒着第四个合伙人要把钱取出来，那么他只要尝试2^64可能性就可以了。</p>
</blockquote>
<p>说明，对于多个人的共享账户，不要采用截断私钥的做法，那怎么办？</p>
<blockquote>
<p>使用多重签名，多重签名中的每一个签名都是独立产生的，而不是把一个私钥拆成若干个私钥，而且多重签名还提供了一些别的灵活性：比如n个人中，任意给出m个签名就可以了。</p>
</blockquote>
<p>区块恋还有另一个问题，如果这两个人分手了，那么他们购买的比特币就会永久地保存在UTXO里，这对全节点是不友好的。</p>
<p>还有一些别的原因，钱变成’死钱’，早期有的人就是挖矿挖着玩，这种情况就造成了大量的私钥的丢失，造成了UTXO集合的膨胀。</p>
<h2 id="分布式共识"><a href="#分布式共识" class="headerlink" title="分布式共识"></a>分布式共识</h2><p>关于分布式共识，学术界有很多不可能的结论，从理论上证明，分布式系统当中取得共识是不可能的，既然从理论上证明是不可能的，实际当中，又怎么变成可能了？</p>
<p><img src="/2020/10/04/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%80%9D%E8%80%83/QQ%E6%88%AA%E5%9B%BE20200923191841.png"></p>
<blockquote>
<p>严格意义上来说，比特币并没有取得真正意义上的共识，因为取得的共识，随时都可能被推翻。</p>
<p>比如出现了分叉攻击，本来你以为已经达成了某一个共识，分叉攻击之后，系统会回滚到前一个状态，从理论上来说，甚至可能回滚到创世纪块，按照分布式系统理论的要求，共识一旦达成之后，就不应该再改了，所以从这个意义上看，比特币系统并没有绕过分布式系统那些不可能的结论，因为他根本没有达到根本意义上的共识</p>
</blockquote>
<p>理论和实际往往是有距离的，很多理论上的不可能结论，对于实体来说是并不适用的，这个不可能结论只是对某种固定的模型下是不可能的。</p>
<p>你怎么判断远程的一台服务器是不是死机了？（连不上，但是是不是真的死机了？）</p>
<blockquote>
<p>分布式系统的理论已经证明了，在异步（通讯传输的延迟是没有上限的：我发一个消息给你，你什么时候能收到，谁也不知道）的环境中，不能区分远程的服务器，到底是死机了，还是运行缓慢。</p>
<p>但是也并不是没有办法，打个电话给管理员，让他看看是否死机了就行了，所以这在理论上不可能的事请，又变成了可能。</p>
<p>如果实际上，每次都给管理员打电话，也比较复杂，所以有一种做法是给服务器加一根电话线（十几年前），如果你发现连不上，就不用internet那根线连接，就用电话线连接，一般来说不会同时出现拥堵，所以你发现用电话线，还是连不上，那就是服务器死机了。</p>
</blockquote>
<p>说明：理论上很多不可能的结论，只是在某些特定的模型下，现实中，把模型改一改，所谓的理论上的结论也就可能不成立了。</p>
<h2 id="比特币的稀缺性"><a href="#比特币的稀缺性" class="headerlink" title="比特币的稀缺性"></a>比特币的稀缺性</h2><p>挖矿的收益，要大于挖矿的开销，那就是有利可图的，所以，要吸引大家来挖矿，要么增加预期收益，要么降低开销。</p>
<p>比特币是如何做到这一点的呢？</p>
<blockquote>
<p>早期的挖矿难度比较低很容易就可以挖到，另一方面，早期的出块奖励也非常的高。</p>
</blockquote>
<p>有人认为比特的设计是十分巧妙的，比特币的总量是恒定的，越到后面越难挖，所以到了后面大家都会抢着去挖，有人认为这是比特币获得成功的一个重要原因，其实，这种总量固定的东西，是不适合作为货币的。有些新型的货币，甚至要自带一种通胀的功能，每年会自动把货币的发行量提高一个比例。</p>
<p>稀缺的东西，是不适合作为货币的，一个好的货币实际上是要有通货膨胀的功能的，如果这个东西的总量是定死的，他是不适合作为货币的（所以现在都不使用黄金作为货币：每年黄金产量增加的速度远远敢不上社会新创造财富的速度，如果我们使用黄金作为货币，这会导致黄金越来越值钱，如果祖上已经有黄金，就只需要坐等升值就行了，国内的房地产就是这种情况，一个健康向上的社会，是不应该出现这种情况的）。</p>
<h2 id="量子计算"><a href="#量子计算" class="headerlink" title="量子计算"></a>量子计算</h2><p>比特币这种加密货币，是建立在密码学的基础上的，将来量子计算发展起来之后，这些加密货币会不会变得不安全了？</p>
<blockquote>
<p>传说中的量子计算，可以破解现有的各种加密算法。但是，这种担心是没有必要的</p>
<p>①量子计算技术离使用还有很长一段距离，如果量子计算技术使用，首当其冲的是传统金融业，网上进行的很多金融活动，都会变得不安全，与其担心量子计算对比特币的冲击，还不如担心量子计算对传统金融的冲击。将来还会有量子加密算法</p>
<p>②比特币当中并没有把账户的公钥直接暴露出来，而是用公钥取哈希之后得到一个地址，非对称加密中，私钥是可以推出公钥的，所以只要保管好私钥，公钥即使丢了也没有关系。公钥显然不能推出私钥。假如量子计算发达了，能够从公钥当中推出私钥，那怎么办？</p>
<p>比特币在设计的时候，又加了一层保护，没有用公钥本身，而是用公钥的哈希，所以有人想偷你账户上的钱的话，</p>
<p>首先是要用地址推导出你的公钥，相当于将公钥的哈希值逆运算，推导出真实的公钥，而这一点，即使是用量子计算机，也是没有办法完成的</p>
</blockquote>
<p>加密是要保证数据的完整性的，为了解密之后得到的明文不丢失信息</p>
<p>而取哈希是可以丢失信息的，哈希算法是不可逆的过程。</p>
<p>比特币使用的哈希算法是SHA-256，不管多大的输入，最后取哈希都变成256位的，这肯定会造成信息的丢失，而且不可逆，如果不是这样的话，变成了超级的压缩算法，这是不可行的。</p>
<p>比特币中，如果只需要收钱的话，只提供一个公钥的哈希就可以了，将来你要取钱的时候，再提供公钥，和私钥产生的签名。假设有一个坏人，在网上监听到了你取钱的交易，知道了你的公钥，他要偷你的钱需要怎么做？</p>
<blockquote>
<p>他要通过你的公钥，实时的破解你的私钥，然后在产生一个把钱转到他的账户上去的交易，即时这个坏人拥有量子计算技术，也很难在几分钟内就把你的私钥破解了，而且他发布的这个交易还要抢在你这个交易的前面，一旦你把账上的钱都转走了，他这个交易就没用了。</p>
</blockquote>
<p>所以从安全性的角度来看，比特币的一个地址，一旦用过之后，就不要再用了。</p>
]]></content>
      <categories>
        <category>区块链</category>
      </categories>
      <tags>
        <tag>区块链</tag>
      </tags>
  </entry>
  <entry>
    <title>区块链---总结</title>
    <url>/2020/12/06/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>​    社会上对区块链的争议是非常大的，有很多对区块链的质疑也是有道理的，其中一个原因是区块链的概念被滥用了，有些人把什么问题都往区块链上放，无论是效率上的问题，还是监管上的问题，好像区块链是解决问题的法宝，有什么问题放在区块链里好像都能解决一样，这个是不对的。</p>
<a id="more"></a>

<p>​    国外有人提出把保险理赔业务放在区块链上，原因是现有的保险理赔过程非常慢，可能需要几个星期，甚至更长的时间，所以他们觉得放在区块链上之后（因为区块链的转账速度，比如说比特币要等6个确认区块，也就是一个小时的时间就可以完成），这比保险理赔（几个星期）的速度要快得多。这个应用场景有什么问题？</p>
<blockquote>
<p>保险理赔的速度慢，并不是支付技术本身的局限性，只要你决定了理赔的金额，就用普通的银行转账很快地可以转到对方的账上，那么它为什么会慢？主要是因为理赔的内容需要人工审核，你说需要理赔，汽车保险也好，还是说健康保险，很多时候都要人工审核这就是为什么它比较慢，而在这一方面，区块链并没有什么好的优势。也就是说支付技术本身不是瓶颈。</p>
</blockquote>
<p>​    还有一些人提出用区块链做防伪溯源的，比如有人提出把有机蔬菜生产的全过程放在区块链上（这个蔬菜从哪里生产的放在区块链上），采摘之后运输的每个环节也都放在区块链上，到最后销售的时候，到哪个市场销售的，也放在区块链上，他们的观点是：因为区块链是不可修改的，在区块链上可以查到这个有机蔬菜生产销售的全过程，所以这是一个很好的应用场景，这个应用场景由什么问题？</p>
<blockquote>
<p>应用场景本身没有任何的问题，但是并不是说你用区块链把整个过程记录下来，就能保证你买到的蔬菜真正是有机的？这个是不一定的，如果这块地施过化肥的，或者是蔬菜本身是撒了农药的，但是被当作有机蔬菜记录在区块链里，那么区块链技术本身是检测不出来的。同样的在运输销售过程中，被人掉包了，把某些不是有机的蔬菜当作有机蔬菜拿上去卖，这个也不是区块链能够检测出来的。区块链的不可篡改性只是内容写在区块链之后，是没有办法篡改的，但是你本身写的是假的内容，那么这个是没有办法检测出来的。</p>
</blockquote>
<p>​    还有一些区块链的争议是跟信任机制相关的，区块链的一个共识机制它的目的是要在互不信任的实体之间，建立共识，那么有些人认为这本来就是一个伪命题，因为互不信任的实体之间是没有办法进行交易的，比如说网上购物，假设有某个电商网站是去中心化的，你不信任它，你怎么能够在上面买东西呢？在一个中心化的世界里，信用卡有些保护措施，比如像paypal这样的机构也可以建立线上和线下的信任关系，但是在区块链上没有办法做到。这个质疑是有一定道理的，但同时中心化和去中心化的界限并不是黑白分明的，在一个成功的商业模式里面，既可以有中心化的成分，也可以有去中心化的成分，比特币只不过是一种支付方式，并不是说采用比特币作为支付方式的商业模式本身也的是去中心化的，比如说亚马逊网站，这个网站是中心化的，但是他在将来也许也可以采用比特币作为一种支付方式。所以不要因为区块链是去中心化的，就认为所有用到区块链作为支付方式的商业模式也得是去中心化的。</p>
<p>​    区块链的不可篡改性：一个交易一旦发布到区块链上之后，是没有办法撤销的，有些人认为是有问题，比如说前面所提到的网上购物的例子。你在网上买一个东西，付款之后，对方没有给你发货，或者是发货的质量有问题，如果是用信用卡的支付方式的话，你可以找对方申诉要求退款，但是比特币转账交易写在区块链上之后就没有办法撤销了，这是有些人对区块链技术的质疑，这种说法有什么问题？</p>
<blockquote>
<p>我们要分清楚，所谓的退款，包括用信用卡，并不是把原来的付款交易取消掉，而是说在应用层发起一个新的交易，把原来你付的钱，还给你，比如说你用信用卡在网上买东西，支付完之后，你发现由什么问题，你要求对方退款，对方退款之后，你信用卡是有两笔交易的。用比特币支付其实也可以达到同样的效果。这个和区块链的不可篡改性实际上是没有关系的。</p>
</blockquote>
<p>​    还有一些质疑适合法律的监管和保护相关的，有些支付方式对用户、消费者是有一定的法律保护的，区块链目前的状态时缺乏监管的，有些人认为这是一个好事情，他们认为去中心化的一个好处就是可以不受到中心化的管理方式，但是监管本身不一定是坏事，没有法律监管同时意味着没有法律保护，出了问题没有人可以保护你，比如用信用卡支付，美国法律规定，信用卡如果被盗刷的话，只要你及时报告（2个月），你最多承受50美元的损失，剩下的损失由信用卡公司来承担。如果时储蓄卡的话，你最多承受500美元的损失。如果你用比特币支付的话，这些保护的功能就都没有了，这也是有些人反对比特币的一个原因。这里我们要注意的一点是，这些法律上的监管和保护，跟支付的技术手段其实是没有关系的。上面所说的信用卡盗刷的例子，只是在美国，不同国家不一样，甚至有些欧洲国家都没有这种保护，即使是美国，各个州的法律规定也不是完全一样的。更重要的是，比特币本来就不应该用于跟已有的支付方式进行竞争。</p>
<p>​    既然信用卡那么好用，那为什么不用信用卡呢？加密货币应该干嘛用？应该用在已有的支付方式解决的不是很好的领域，有人说互联网是过去一个世纪以来最伟大的发明，互联网的一个重要作用使得信息传播变得非常方便，信息能够无国界的传到世界上的每一个角落，但是支付方式并没有跟上，如果你仅仅是获取信息，这个是比较容易的，网上有各种文章、论坛，但是你如果想要支付的话就会比较难。比特币被称为world wide currency是有一定道理的，因为现在的金融体系当中缺乏一种能够在全球范围内流通的电子货币，而且这个货币的支付方式要能够和信息传播的方式融合在一起，现有的体系当中，支付渠道和信息传播的渠道是分开的。</p>
<p>​    有人说，下一代的互联网是价值交换网络（internet of value），我们现在的互联网可以认为是信息传播网络，现在问题就在于，信息传播很方便，信息的交互也比较方便，但是价值交换是不方便的（information can flow freely on the internet，but payment cannot），未来的趋势就是支付渠道和信息传播渠道将会逐渐融合，使得价值交换也会变得和信息传播一样的方便。</p>
<p>​    还有一些质疑是和支付方式的效率相关的，有些人认为加密货币支付方式是非常低效的，无论是比特币还是以太坊，平均到每个交易上它的能耗都是很大的，比信用卡的能耗要大得多，所以有些人觉得没有什么好处。</p>
<blockquote>
<p>①加密货币本来就不是用于和已有的支付方式做竞争。 </p>
<p>②随着区块链技术的发展，共识协议的不断改进，一些新的加密货币在支付效率上已经是大大提高了，原始版本的比特币，每个区块只能有1M字节，出块时间平均是10分钟，每秒钟可以支持7笔交易，现在有些新型的加密货币号称每秒钟能够支持几百万个交易，这个效率已经有了质的飞跃，其实就是以太坊和比特币相比，以太坊的支付效率也已经比比特币高很多了，这是发展的一个大的趋势。</p>
<p>③我们评价一个支付方式效率的好坏要在当时特定的历史条件下去看，要跟当时存在的其他支付方式相比较。加密货币在某些场景下，已经是相对高效的。（跨国转账）将来随着技术的发展会有更高效的支付手段出现，这是个大趋势。</p>
</blockquote>
<p>​    还有一些质疑是和智能合约相关的，智能合约出现了一系列的安全漏洞之后，有些人就觉得，用智能合约由什么好处？还不如用传统的法律合同，法律合同使用自然语言书写的，老百姓还能看得懂。智能合约使用编程语言来写的，除了程序员之外其他人都看不懂，反而不利于检查安全漏洞，对于这种观点，首先程序化是一个大趋势，“software is eating the world”，也有人把它翻译成软件将会颠覆世界，任何技术，任何领域在早期都会有些问题。物理世界的取款机可以看作是一个智能合约，按照事先设定的规定操作，你把银行卡插进去，输入密码会自动把钱取出来，ATM机也会出问题。（ATM机出现了几十年，到现在还会发生故障。在ATM机刚出现的时候，发生故障的频率肯定是要高很多的）。智能合约的历史相对比较短的，所以他在早期的时候出现安全漏洞其实也不是很奇怪，很多软件都出现过各种各样的安全漏洞，随着技术的发展，将来会出现一些智能合约中的一些常用的模板。软件将会改变世界是一个大趋势，另一方面，也不要认为智能合约可以解决所有的问题，或者说以为去中心化能够解决所有的问题。</p>
<p>​    即使The DAO不出现黑客盗币事件，The DAO的商业模式是不是就没有问题？The DAO刚刚出现众筹的时候曾经引起了一阵强大的兴奋（以前从来没有出现过如此民主的投资基金），民主一定是好事情嘛？大多数人觉得好是真的好吗？</p>
<p>​    <img src="/2020/12/06/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%80%BB%E7%BB%93/QQ%E6%88%AA%E5%9B%BE20201208183152.png"></p>
<p>民主制度不是一种最完美的制度，它和过去的奴隶制度、封建制度相比，它是一种历史的进步，但是民主制度也存在弊病的，包括效率上的弊病，也包括决策上的正确性这方面的问题，不要以为任何问题用民主投票的方法都可以解决。</p>
<p>​    去中心化一定是好事情吗？这个其实是不一定的，在现实生活中的风投决定要投哪个项目要怎么进行判断？得考察这个项目，和创始人谈判，看看这个项目是否靠谱，如果这个公司已经运行了一定时间，还要去检查一下公司的财务状况、适用一下公司的产品等等，都不是简单的投票就能解决的，所以不要以为去中心化能够解决所有问题。    </p>
<p><img src="/2020/12/06/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%80%BB%E7%BB%93/QQ%E6%88%AA%E5%9B%BE20201208183911.png"></p>
<p>​    不要以为所有的概念用去中心化的概念包装一下，就捧上天，去中心化的管理方式和中心化的管理方式是各有利弊的，要具体问题具体分析，像The DAO这样的基金就不应该受到热捧。</p>
]]></content>
      <categories>
        <category>区块链</category>
      </categories>
      <tags>
        <tag>区块链</tag>
      </tags>
  </entry>
  <entry>
    <title>BTC十一---匿名性</title>
    <url>/2020/09/17/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%8C%BF%E5%90%8D%E6%80%A7/</url>
    <content><![CDATA[<h1 id="匿名性"><a href="#匿名性" class="headerlink" title="匿名性"></a>匿名性</h1><h2 id="匿名性介绍"><a href="#匿名性介绍" class="headerlink" title="匿名性介绍"></a>匿名性介绍</h2><p>BitCoin and anonymity</p>
<p>一般来说，大家说的匿名是和隐私保护联系（privacy）在一起的，比特币不要求是真名，是需要公钥产生的地址即可，因此有一定的匿名性，但不是说完全没有名字，他用的是“化名”，因此有人称它为“preudonymity”，就好像很多作家有笔名一样，比特币系统中的“匿名”其实不是真的匿名。</p>
<a id="more"></a>

<p>这种匿名性能给我们带来什么样的保护呢？和现金相比，和美元，法币相比？它的匿名性没有现金好，现金是完全匿名的。比特币的匿名性和银行存款相比，因为银行账户是实名制。（其实以前国内的银行不要求实名制，可以使用化名，如果这样的话，和比特币相比，哪个匿名性更好？从某种程度上来说，这时候的匿名性就比比特币要好，比特币的账户是公开的，而银行里普通老百姓想要知道别人的账户，这个是没有办法的。）</p>
<p>比特币系统中，什么情况下有可能破坏匿名性？有些人建议在你每次收款的时候，都创建一个新的账户，但是某些情况下，这些账户是可以被关联在一起的？（这个时候就破坏了比特币的匿名性）</p>
<blockquote>
<p>比如网上购物，一个交易可以有多个输入和输出。</p>
<p><img src="/2020/09/17/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%8C%BF%E5%90%8D%E6%80%A7/QQ%E6%88%AA%E5%9B%BE20200916195151.png"></p>
<p>这个Inputs有多个，这两个地址可能是同一个人（因为可能一个账户的钱，不够买这件商品，所以同时使用另一个账户来消费）；而Outputs其中一个一般是一个找零钱的输出。 像上图中的交易，一般都是由比特币钱包软件生成的，很多钱包软件交易的时候会生成一个新的找零钱的地址，有没有可能把输入地址和输出地址也关联起来呢？（有没有可能我们把这个找零钱的地址也找到？）</p>
<p>比特币钱包并没有规定找零钱的地址在Outputs中出现的位置，但其实有些情况下，你可以把它分析出来，我们想要对敌人造成干扰，就可以生成一些不必要的转账地址，但是一般没有人会这么干。</p>
<p><img src="/2020/09/17/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%8C%BF%E5%90%8D%E6%80%A7/QQ%E6%88%AA%E5%9B%BE20200916200401.png"></p>
</blockquote>
<p>这就说明，我们可以生成很多的地址账户，但是这些地址账户是可以被关联起来的。第二点是，这个地址账户跟你在社会现实世界中的真实身份也产生关联，那么什么时候会知道比特币的地址账户对应现实中的某个人呢？</p>
<blockquote>
<p>①任何比特币系统中的地址和现实世界发生联系的时候都有可能泄漏身份。在资金转入和转出区块链的时候都有可能泄漏，我们刚开始都没有比特币，这时候需要去交易所买，在交易所登记；也有场外交易的情况（就是两个人之间私下交易，以前国外有些做场外交易的公共场所）。</p>
<p>②很多国家有反洗钱法，那么怎么防范使用比特币洗钱的违法行为呢？</p>
<p>盯住这个资金的转入转出链其实是一个常用手段，如果你有很大的资金像转入到比特币，或者你有很大一部分比特币，你想转成法币，这个你想不引起司法部门的注意，实际上是很难的，这也是比特币隐私有可能被破坏的一个很重要的时机。</p>
<p>③用比特币做支付的时候，比如国外有的商家，是接受比特币支付的，咖啡店，餐馆之类（当然，这是一个bad idea，1.延迟大，等六个确认需要等待1个小时；2.交易费也很贵）。这个其实不仅仅是接受你支付的商家会知道，</p>
<p>其他人其实也会知道：以前曾经有一家信用卡公司，为了支持学术界的科研，把他收集到的一些信用卡的记录公开，公开的时候做一些隐私保护（信用卡号码取哈希，年龄，性别 等都抹掉了），有人就做了科研（其实不是为了研究信用卡的消费行为，而是怎么通过这些公开的数据推测出这个人实际上是谁）—&gt;通过过滤在某个时间某个人在哪里消费，就可以精准地定位到某个人</p>
</blockquote>
<p>这就说明，信用卡记录不能公开，去了哈希值之后依然是不应该公开的，但是比特币系统本来就是公开的，这时候你去咖啡店，你把你的账户的地址告诉了营业员，你周围有其他认识你的人都会意识到这时候你在比特币网络上做了一笔消费，然后就可以在区块链中查出来。所以比特币的匿名性并不像我们想象中的那么好</p>
<p>实际上那些用比特币的人，匿名性保存的有多好？中本聪！（因为他根本没有花钱）</p>
<p>中本聪为什么要发明比特币，当时他在发明比特币的时候还是花了很大的功夫的，有人说是为了赚钱，但是到现在，他账户上的比特币都没有花出去过（一旦花出去，就要和现实中的银行，交易所发生联系，这样会暴露他的身份，这是他不愿做的事情），所以他不是为了钱，可能是为了某种事业或者信念。</p>
<blockquote>
<p>以前有个叫silk road的网站：通过比特币卖各种违禁品，最后运行了两三年就被政府查封了，这个人通过这个网站赚了很多钱，但是他只是在纸面上很多钱，十几万个比特币一个都没花，因为一花就暴露身份了。所以，比特币的匿名性没有我们想象的那么好。</p>
</blockquote>
<p>所以，过去的经验表明，凡是用比特币从事违法活动的，最后都能被抓起来，中本聪能这么好的保持匿名性，实际上是一个个例，而且他没有干坏事</p>
<p>hide your indetiny from whom？</p>
<blockquote>
<p>如果你只是像让你的亲戚朋友不知道你的账户上有多少钱，这个是很容易办到的，如果是像silk road这样的想逃避fbi，是很难的。</p>
</blockquote>
<h2 id="如何提高匿名性"><a href="#如何提高匿名性" class="headerlink" title="如何提高匿名性"></a>如何提高匿名性</h2><p>假设你是一个比特币用户，你能用什么方法来提高你的匿名性？</p>
<blockquote>
<p>我们知道，比特币是运行在应用层的应用程序，它的底层是P2P的network，所以提高匿名性，是从两个方面入手。</p>
<p>network layer：如果很多交易都是从一个ip地址发出来的，那么从物理世界中，通过ip地址就可以知道是谁。这个我们已经有解决方案了，比较普遍的一种方法就是使用多路径转发的方法（TOR的原理），sender不是直接发给reciever，而是中间经过很多跳，中间的结点只是知道它的上一跳是谁，而不知道最早发出这个消息的是谁，中间的结点可能是坏的，但是只要中间有一个结点是诚实的，就可以将发件人的身份隐藏起来。</p>
<p>application layer：破坏匿名性的原因之一是，同一个人的不同的比特币账户之间会被关联起来。其中一个做法是</p>
<p>coin mixing：把你的身份和周围的人的身份混在一起，让别人分不清谁是谁。如何做到coin mixing？有些网站专门提供coin mixing的服务，收取一定的服务费，所有想使用coin mixing的用户，把币发给这些网站，内部进行一些重组，再取回来，取回来的币就不是原来的币了，实际上是一个复杂的过程。还有一个问题是，现在这个区块里世界里，没有什么信誉度非常高的coin mixing的服务，很多提供这个服务的网站，他自己也是匿名的，卷款跑路我们一点办法也没有。</p>
<p>我们不一定要刻意的coin mixing，我们使用的一些软件，有些自己就带有coin mixing的一些性质，比如在线钱包，存进去的币，他可能会把其他人的币混合起来，但是在线钱包并不一定要履行coin mixing的功能</p>
<p>还有一些交易所，他天然的有coin mixing的性质，我把一些比特币存进交易所，一段时间，我觉得它的价格会下跌，于是我把他换成美元，我有可能买入以太币，又可能换成莱特币，折腾几次之后，我又可能把他买回来，这时候我账户上的比特币，就不一定是我存进去的比特币了。（coin mixing的性质）。当然这个的前提是，这个交易所不是泄漏相关的记录（相关的提币存币的记录）</p>
</blockquote>
<p>为什么比特币的匿名性很差，其中一个本质原因是他是公开的，而且他是不可篡改的，好像不可篡改性对比特币有好处，其实堆隐私保护是灾难性的，因为一旦你在一个交易里把你的身份暴露了，这个交易永久地写在区块链里，你想抹都抹不掉了。这也是为什么我们说账户之间的关联性也是我们需要小心的，如果账户是单独出去的，如果你暴露了一个账户，这个影响还是比较有限的，如果是关联的，一个账户暴露了，后面的就都完了。</p>
<h2 id="零知识证明"><a href="#零知识证明" class="headerlink" title="零知识证明"></a>零知识证明</h2><p><img src="/2020/09/17/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%8C%BF%E5%90%8D%E6%80%A7/QQ%E6%88%AA%E5%9B%BE20200921195428.png"></p>
<p>比如，我要证明某个比特币账户是我的，我要证明这一点，我要怎么证明？</p>
<blockquote>
<p>实际上是要证明我有这个比特币账户的私钥，但是我不能把这个私钥告诉你，这时候就可以签名，你是知道这个账户的公钥的，你可以验证这个签名的合法性</p>
</blockquote>
<p>这个例子作为零知识证明，实际上是有争议的，我虽然没有泄露我的私钥，但是我泄露了我私钥的签名，这个和零知识证明中的无需透露该陈述是正确的外的任何信息是有冲突的。但是这里透露的额外信息要看你实际的应用场景。</p>
<p><img src="/2020/09/17/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%8C%BF%E5%90%8D%E6%80%A7/QQ%E6%88%AA%E5%9B%BE20200921195956.png"></p>
<p>零知识证明的数学基础是同态隐藏。</p>
<p>①不会出现哈希碰撞，如果x、y不相等，那么加密值也不相等，反过来说，如果两个加密函数值是相等的，那么原来的函数值也是相等的。</p>
<p>②说明加密函数不可逆，密码学的哈希函数的性质和这个是类似的，hiding propetry，知道哈希值没有办法知道它的输入值。</p>
<p>③对这些加密后的函数进行函数运算，等价于，对进行运算的函数，然后在进行加密。</p>
<p><img src="/2020/09/17/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%8C%BF%E5%90%8D%E6%80%A7/QQ%E6%88%AA%E5%9B%BE20200921200714.png"></p>
<p><img src="/2020/09/17/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%8C%BF%E5%90%8D%E6%80%A7/QQ%E6%88%AA%E5%9B%BE20200921200915.png"></p>
<p>说明：</p>
<p><code>E(X+Y) = E(7)</code>,说明没有碰撞</p>
<p>这个版本实际上有些缺陷，Bob可以用蛮力的方式，猜出原始的x、y是多少，Bob虽然通过E(x)不能知道x是多少，但是他可以通过遍历x的取值，Alice需要在发送E(x)和E(y)之前，对x、y进行随机化处理（使得x、y加起来还是不变的）。</p>
<p>在比特币的共识协议中，央行发行货币，有个属于他自己的签名，在前面所讲的，这样会产生double spending，所以可以在每张货币上加上一个id，记录现在这张货币在谁手里。这样的话，央行不是什么都知道了？</p>
<p>那么，有没有什么办法，让央行做中心化的记账，但是又不让他知道呢？</p>
<blockquote>
<p>这个虚拟货币的编号不能是央行产生的，这个编号得是我自己产生的，我在本地产生一个编号，但是不告诉央行，这样的话，央行怎么知道这个编号是不是正确的呢？这就引入了盲签。</p>
<p>用户A提供编号，银行是要签名的，但是他看不到内容,Token就是银行对序号的签名。</p>
<p><img src="/2020/09/17/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%8C%BF%E5%90%8D%E6%80%A7/QQ%E6%88%AA%E5%9B%BE20200921202409.png"></p>
</blockquote>
<h2 id="零币和零钞"><a href="#零币和零钞" class="headerlink" title="零币和零钞"></a>零币和零钞</h2><p><img src="/2020/09/17/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%8C%BF%E5%90%8D%E6%80%A7/QQ%E6%88%AA%E5%9B%BE20200921202540.png"></p>
<p>基础币可以是比特币，你用的时候，你要证明，本来是有一个基础币的，你把这个基础币搞得是不能花了，然后换取一个零币，零币在花的时候，只需要用零知识证明你花掉的币是系统中存在的某一个合法的币就行了，但是不用透露你花的是系统中的哪一个币。</p>
<p>这样就把关联性破坏掉了。</p>
<p>这些零币和零钞都不是主流的加密货币：这些币为了匿名性，在性能上是有一定的损失的，而且在数学原理上，对初始化，有比较严格的要求（初始的时候用的随机源要能够销毁掉，如果没有销毁掉，会有一定的安全漏洞），更重要的是，需要强匿名性的用户本来也不是很多，大多数用户觉得比特币的这种匿名性，其实也够用了。</p>
<p>虽然零币和零钞在数学原理上，存在很强的匿名性，但是也并不是100%匿名安全的，与实体世界发生交互的时候也会有问题。</p>
]]></content>
      <categories>
        <category>区块链</category>
      </categories>
      <tags>
        <tag>区块链</tag>
      </tags>
  </entry>
  <entry>
    <title>BTC三---协议</title>
    <url>/2020/08/30/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%8D%8F%E8%AE%AE/</url>
    <content><![CDATA[<h1 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h1><h2 id="1-需要解决的问题"><a href="#1-需要解决的问题" class="headerlink" title="1.需要解决的问题"></a>1.需要解决的问题</h2><p>举个例子，央行可以发行数字货币，每张数字货币上都有央行的私钥的签名</p>
<a id="more"></a>

<p><img src="/2020/08/30/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%8D%8F%E8%AE%AE/QQ%E6%88%AA%E5%9B%BE20200810202143.png"></p>
<p>央行的公钥我们大家都知道，所以我收到一个数字货币，我可以验证一下是不是真的，买东西的时候，我把数字货币发给你，同理你也可以验证确实是央行发行的，这就完成了支付的一个过程。</p>
<p>这里用到了密码学中的非对称加密体系，但是没有用到区块链，这样会带来什么问题？</p>
<p>这个数字货币是个文件，我们不能篡改，但是可以复制，可以复制很多份，这和人民币不一样，我把人民币给你了，我就没有人民币了。这就是数字货币和纸质货币的区别</p>
<p>double spending attack（双花攻击），数字货币面临的一个主要挑战，就是防范double spending attack</p>
<p>改进的方案：</p>
<p><img src="/2020/08/30/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%8D%8F%E8%AE%AE/QQ%E6%88%AA%E5%9B%BE20200810203047.png"></p>
<p>央行发行的货币，再每个数字货币上添加一个编号，并且在数据库中保存这个编号对应的货币目前在谁手上，收款方不仅验证数字货币的真实性，还需要验证付款方是否合法，央行的 数据库进而修改017对应的数字货币的所有者。</p>
<p>这样做是没有问题的，但是这是一个中心化的方案，数字货币的发行是由央行统一控制的，而且每次交易也是由央行控制的。</p>
<p>那么有没有去中心化的方案呢？将央行这个职能，改成由广大用户共同承担，这就是比特币，这个数字货币系统要解决的问题。</p>
<p>去中心化的货币要解决两个问题：数字货币的发行（没有央行了，都是普通群众，那怎么决定数字货币的发行：什么时候发行，该发行多少）、怎么验证交易的有效性（如何防止double spending attack）</p>
<p>①谁来发行货币？在比特币系统中，是由挖矿来决定的，这个在后面详细讲</p>
<p>②如何防止double spending attack：也是维护一个数据结构，检测数字货币有没有花过，被谁花过，只不过这个数据结构不是由央行来维护，而是由所有的用户来维护，这个数据结构就是区块链</p>
<p>比如用户A，拥有了发行货币的能力</p>
<p><img src="/2020/08/30/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%8D%8F%E8%AE%AE/QQ%E6%88%AA%E5%9B%BE20200810204843.png"></p>
<p><strong>比特币中的交易都包含输入和输出两部分，输入部分说明币的来源，输出部分要给出收款人公钥的哈希</strong></p>
<p>这里有两个哈希指针，一个哈希指针是用来连接各个区块，把他们串起来构成一个链表，还有一个指针是用来说明币的来源的（用于证明这个数字货币不是凭空捏造的，同时防范double spending attack）</p>
<p><img src="/2020/08/30/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%8D%8F%E8%AE%AE/QQ%E6%88%AA%E5%9B%BE20200810205441.png"></p>
<p>A要给B转钱，需要知道B的地址，这个地址是由B的公钥取哈希，经过一些转换推算得到的，那A要怎么知道B的地址呢？</p>
<p>比特币系统没有提供一种功能去查询某个指定人的所对应的比特币地址，这个需要其他的渠道来获得</p>
<p>A要给B转钱，B要知道A的什么信息？币的来源？（B不需要知道，这个其实是A要知道的）</p>
<p>答案是B要知道A的公钥。B要知道A的身份，好知道这笔钱是哪来的。但是不仅仅是B需要知道A的公钥，所有结点都需要知道A的公钥—-&gt;为了验证A的签名，那问题又来了，怎么知道A的公钥？</p>
<p>输入当中不仅要说明币的来源，还需要说明A的公钥是什么</p>
<p><img src="/2020/08/30/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%8D%8F%E8%AE%AE/QQ%E6%88%AA%E5%9B%BE20200810211410.png"></p>
<p><img src="/2020/08/30/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%8D%8F%E8%AE%AE/QQ%E6%88%AA%E5%9B%BE20200810211619.png"></p>
<p>在比特币系统中，这些验证的过程，是通过执行脚本来实现的—–&gt;BitCoin Script</p>
<p>将后面交易的输入的执行脚本和前面交易的输出的执行脚本拼接，如果能顺利执行，那么这个验证就是通过的</p>
<p>每个区块由block header 和 block body组成</p>
<p>block header：保存每个区块的一些宏观的信息，包括</p>
<p>①：用的是比特币哪个版本的协议</p>
<p>②hash of previous block header：区块中指向前一个区块的指针</p>
<p><strong>注意：</strong>前一个区块的哈希只算的是区块的块头</p>
<p>③Merkle root hash：整棵Merkle tree的根哈希值</p>
<p>④target：挖矿的难度目标阈值</p>
<p><img src="/2020/08/30/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%8D%8F%E8%AE%AE/QQ%E6%88%AA%E5%9B%BE20200810213647.png"></p>
<p>block header存的就是target的一个编码：nBits</p>
<p>⑤nonce：随机数nonce    </p>
<p>block body：</p>
<p>①transaction list：交易列表</p>
<p>貌似所有的结点都需要验证区块链中的每一个交易</p>
<p>实际上区块链分为全节点full node 和轻结点light node 两种结点</p>
<p>full node ：保存所有的信息，验证每一个交易，也叫做fully validating node</p>
<p>light node：并不参数验证，只是利用区块链的一些信息做一些查询之类的工作</p>
<p>交易如何写入区块链，按照什么顺序？账本的内容要取得分布式的共识（distributed consensus）</p>
<p>分布式的共识？举个例子，就是简单的哈希表distributed hash table，就是，一台机器在hash表中插入了一条数据（key-value pair），在别的机器也能查询到。</p>
<h2 id="2-分布式系统中的结论和协议"><a href="#2-分布式系统中的结论和协议" class="headerlink" title="2.分布式系统中的结论和协议"></a>2.分布式系统中的结论和协议</h2><p>分布式系统有很多的不可能结论impossibility result，最著名的一个叫做FLP impossibility result:</p>
<p>在一个异步的系统里（asynchronous system），网络传输时延没有上限，即时只有一个成员是有问题的（faulty），也不可能取得共识</p>
<p>还有一个结论CAP Theorem：</p>
<p>C：consistency（一致性）   A：Availability（可用性）   P：Partition tolerance（分区容错性）</p>
<p>任何一个分布式系统CAP三个性质最多只能满足两个，不可能三个性质都满足。</p>
<p>分布式共识的一个重要协议：Paxos，这个协议能够保证Consistency，如果这个协议达成了共识，那么这个共识一定是一致的，不会说一个成员认为的共识和另外一个成员认为的共识不一样。但是，某些情况下，Paxos协议有可能一直没有办法达成共识，这种可能性在实际系统中是比较小的，但是是客观存在的</p>
<h2 id="3-比特币系统中的分布式共识协议"><a href="#3-比特币系统中的分布式共识协议" class="headerlink" title="3.比特币系统中的分布式共识协议"></a>3.比特币系统中的分布式共识协议</h2><p>需要解决的问题是，某些节点可能是有恶意的，我们假设系统中大多数节点是好的，如何去设计共识协议？</p>
<p>一种想法，既然大多数结点是好的，那直接投票行不行，比如说：某一个结点提出一个候选区块，他根据收到的交易信息，选一下那些交易是合法的，然后把这些交易按照某个顺序打包到一个区块里，候选区块发布给所有的结点，每个结点收到这个区块之后，检查这里面的交易是不是都是合法的，如果都是合法的，那么这个结点就投赞成票，如果有个交易是非法的，就投反对票，最后算出得票，如果超过半数，就将这个候选区块正式接受，写道区块链中</p>
<p>会带来什么问题？</p>
<p>①某个结点提出候选区块，万一这个节点是有恶意的呢，就不停的产生一些非法的交易让系统一直投票，会阻塞系统的发展</p>
<p>②并不能强迫每个节点都投票（行政不作为）</p>
<p>③效率的问题，网络的延迟状况不是很清楚</p>
<p>最大的问题：所有基于投票的方案，首先要确定谁有投票权（需要有membership）。如果这个系统的membership是有严格定义的，不是谁都可以加入的，比如hyperledger，只有某些符合条件的大公司才能加入，这种情况下，基于投票的方案是可行的。</p>
<p>但是比特币系统不是这样的，比特币系统中创建一个账户是很容易的，在本地产生一个公私钥对其他人其实都不知道，只有在你和外部交易的时候别人会知道，这种情况下，有恶意的结点，用一台超级计算机，不停的创建账户，当账户超过总数的一半时，就会对投票产生控制权，这种攻击叫做女巫攻击（sybil attack）。</p>
<p>所以简单的随机投票是不行的</p>
<p>比特币中采用了一个巧妙地机制来解决这个问题，也是投票，但不是按照账户的数目投票，而是用计算力来投票，每个结点都可以在本地组装出一个候选区块，把他认为合法的交易放在这个区块里，就开始尝试各种nonce值，看那个结点可以满足不等式的要求，求出的hash落在指定的范围之内，如果某个节点找到了符合要求的nonce，我们就说他获得了记账权（向比特币这个去中心化的账本里写入下一个区块的权力），只有这样的结点，才有权力发布下一个区块，其他节点要先验证这个区块的合法性，block header 中的nBits（挖矿的难度要求）是否正确，然后验证nonce，总的来说，就是先查询block header中的各种值，然后验证block body中的交易是否合法（是否有合法的签名、是否被花过）</p>
<p>有没有可能这个区块的所有内容都符合要求，但是我们仍然不愿意接受他？</p>
<p><img src="/2020/08/30/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%8D%8F%E8%AE%AE/QQ%E6%88%AA%E5%9B%BE20200812212804.png"></p>
<p>分叉攻击，通过像区块链中间插入一个区块，来回滚某个已经发生的交易，但是区块链在正常情况下也会出现分叉，</p>
<p>如果同时有两个结点获得了记账权，就有可能发生，可能会出现两个等长的分叉</p>
<p><img src="/2020/08/30/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%8D%8F%E8%AE%AE/QQ%E6%88%AA%E5%9B%BE20200812213645.png"></p>
<p>比特币系统中，缺省情况下，每个结点是接受他最早收到的那个，不同的结点在网络中的位置不同，接受的结点可能也不同，什么叫做接受？在接受一个区块之后会向后扩展区块</p>
<p><img src="/2020/08/30/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%8D%8F%E8%AE%AE/QQ%E6%88%AA%E5%9B%BE20200812214435.png"></p>
<p><img src="/2020/08/30/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%8D%8F%E8%AE%AE/QQ%E6%88%AA%E5%9B%BE20200812214518.png"></p>
<p>那么为什么要争夺记账权？</p>
<p>记账的结点可以拥有某些权力，决定那些交易被写到区块链里，但是设计的时候不应该让这个权力称为争夺记账权的主要动力，因为我们希望所有的合法的交易都应该被写进区块链里</p>
<p>比特币系统规定，获得记账权的哪个结点，在发布的区块里可以有一个特殊的交易，就是铸币交易，可以发布一定数量的比特币。coinbase transaction（交易）</p>
<p>比特币系统要解决两个问题，一个是谁来决定发行货币，另一个是验证交易的合法性，回过头来说明第一个问题：</p>
<p>coninbase transaction （交易）是比特币系统中发行货币的唯一方法，其他所有的交易都是把已有的比特币从一个账户转移到另一个账户，coinbase transaction不用指明币的来源，那能铸多少个币呢</p>
<p>比特币刚上线时，每一个新增的区块可以铸50 BTC，但是每21万个区块之后，这个奖励就要减半，现在的情况就是12.5 BTC</p>
<p><strong>注意：orphan block中的奖励的比特币就无效了</strong></p>
<h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4.总结"></a>4.总结</h2><p>最后，那么比特币要取得的共识是什么？去中心化账本中的内容要取得共识，只有获得记账权的结点才能往里面写东西，</p>
<p>我们通过算例来获得记账权，每秒钟能够试多少个nonce的数目（hash rate），hash rate越高，得到出块奖励的概率越大</p>
]]></content>
      <categories>
        <category>区块链</category>
      </categories>
      <tags>
        <tag>区块链</tag>
      </tags>
  </entry>
  <entry>
    <title>BTC十---回顾问答</title>
    <url>/2020/09/14/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%9B%9E%E9%A1%BE%E9%97%AE%E7%AD%94/</url>
    <content><![CDATA[<h1 id="BTC问答回顾"><a href="#BTC问答回顾" class="headerlink" title="BTC问答回顾"></a>BTC问答回顾</h1><p>1.转账交易的时候，如果接收者不在线（你转账给A，但是A那时候没有连接到比特币网络上）怎么办？</p>
<blockquote>
<p> 这个时候不需要接收者在线，转账交易只不过要在区块链上记录一下。</p>
</blockquote>
<p>2.假设某个全节点收到了一个转账交易，有没有可能转账交易中接收者的收款地址是这个结点以前从来没有听说过的？</p>
<blockquote>
<p>可能，比特币系统在创建账户的时候是不需要通知其他人的，在本地产生一个公私钥对就可以了，只有在以后产生的收款地址收到钱的时候，其他结点才知道这个账户的存在。</p>
</blockquote>
<a id="more"></a>

<p>3.如果你账户的私钥丢失了该怎么办？</p>
<blockquote>
<p>其实是没有办法的，这个账户上的钱就变成了死钱，永远取不出来，去中心化的系统大家没有办法给你重置密码。</p>
</blockquote>
<p>有些加密货币的交易所，一般来说，这些交易所都是中心化的机构，那么在交易所办一个账户的时候一般来说是要提供身份证明的，这种情况下，你把你的交易货币保存在交易所里，那么私钥实际上是由交易所来保管的 ，你登陆这个交易所是按照登陆银行差不多的程序（有一个账户名，一个密码），登陆的时候，一般来说还需要二次验证（google 身份验证器），如果私钥丢失是可以在交易所查到的；</p>
<p>有些在线钱包也提供私钥保管的功能，但并不说这些机构为我们自己保管私钥更加安全，目前这些机构仍处于缺乏监管的状态，历史上出现过交易所被黑客攻击的情况，其中最著名的例子就是Mt.Gox的例子，Mt.Gox曾经是世界上最大的交易所，交易量占到了全球的交易量的70%。后来被攻击了，CEO被判刑。</p>
<p>相比来说，冷钱包或者硬钱包更加安全。</p>
<p>4.如果你的私钥泄漏了怎么办？（你发现你的账户上出现了一些可疑的交易）</p>
<blockquote>
<p>这个时候你应该把你账户上的钱，转到另一个安全账户上。（这个也和现实中银行的体验不太一样）</p>
<p>比特币账户创建之后，公私钥对都是没有办法修改的</p>
</blockquote>
<p>5.如果转账的账户地址填错了怎么办？</p>
<blockquote>
<p>没有办法取消以前发布的交易，比特币中转账的交易一旦发布在区块链上就没有办法取消了，它没有提供这种机制取消一个已经发布的交易，如果你知道是谁的地址，可以跟他联系一下</p>
<p>也可能转给不存在的地址（有些地址其实不是公钥的哈希得到的：digital commitment：你想证明某个时间你知道了某个知识，可能只是一个文件取了哈希）</p>
</blockquote>
<p>在Proof of Burn中提到的OP_RETURN后面可以写所有的去哈希的内容，上面的内容没有人管，这是推荐采用的方法，但是有的人不这么干：有人用内容取哈希之后得到的哈希值生成一个看上去像比特币地址的东西，这时候转账给这个假的地址，这样转账的钱就变成了死钱，这种做法，就是牺牲很少一点的比特币，换取往这个区块链里写入这个哈希值的一个机会。后者的做法是不提倡的，因为这样转账交易的输出会永久的保留在UTXO里，对全节点不友好</p>
<p>6.Proof of Burn的机制是怎么执行的，不是说OP_RETURN会无条件地返回错误吗？那这个交易是怎么通过验证的？</p>
<blockquote>
<p>验证时候：是把当前这个交易的输入脚本和这个交易（币的来源）的输出脚本拼接，这个过程是不可以发生错误的，关键在于，OP_RETURN是写在当前交易的输出脚本里的，所以验证当前交易的合法性的时候不会执行当前语句（因为他是输出脚本），有人想花这个钱的时候，才会执行这个输出脚本，因为OP_RETURN永远都返回错误，所以永远都不可能花出去。</p>
</blockquote>
<p>7.会不会有的矿工偷答案？（其他矿工发布了一个nonce，这个矿工没有找到这个nonce，他收到这个区块之后，查一下这个nonce是符合要求的，然后就把他当成自己的nonce发布出去）你怎么知道哪个nonce是属于哪个矿工的？</p>
<blockquote>
<p>发布的区块里，会发布一个coinBase tx，里面会填一个收款地址，谁挖到了矿，就填谁，如果你要抄答案，那么你要把收款人的地址换成自己的地址，而这个地址发生变化的话，coinBase tx的内容就会发生变化，这样会导致这个Merkle tree的根哈希值发生变化，而这个nonce在块头里，根哈希值也在块头，block header的哈希值发生变化之后，原来找到的nonce就作废了。所以你不可能偷答案，因为每个矿工挖到的nonce是和自己的收款地址绑定在一起的。</p>
</blockquote>
<p>8.交易费可以看作是发布区块的时候给矿工的一点小费，那么你怎么知道这个交易费该给那个矿工？事先你怎么知道哪个矿工会挖到矿？</p>
<blockquote>
<p>事先不需要知道哪个矿工得到这个交易费，只要total inputs &gt; total ouputs，这个差值就是交易费，给谁不需要事先知道，哪个矿工挖到矿了，就可以把这些差额收集起来，作为自己的交易费。</p>
</blockquote>
]]></content>
      <categories>
        <category>区块链</category>
      </categories>
      <tags>
        <tag>区块链</tag>
      </tags>
  </entry>
  <entry>
    <title>BTC四---实现</title>
    <url>/2020/08/30/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><h2 id="transaction-based-ledger"><a href="#transaction-based-ledger" class="headerlink" title="transaction-based ledger"></a>transaction-based ledger</h2><p>BTC(比特币):基于交易的账本模式（transaction-based ledger），每个区块记录交易信息，但是系统中没有统一的记录，比如需要知道某个账户有多少钱，这个还需要交易记录来推算</p>
<p>比特币的全节点要维护一个UTXO的数据结构</p>
<a id="more"></a>

<p>UTXO:Unspent Transaction Output,还没有被花出去的交易的输出，区块链中有很多交易，有些交易的输出可能被花掉了，有些还没有被花掉，没有被花掉的交易的输出的集合叫做UTXO</p>
<p>UTXO中的每个元素要给出产生这个输出的交易的hash值，以及他在这个交易里是第几个输出，就可以定位到这个UTXO中的输出，那么这个UTXO集合的作用是什么？为什么要维护这样一个数据结构</p>
<p>作用：防范double spending attack，所以全节点要在内存中维护UTXO数据结构，以便快速检测double spending attack，</p>
<p>随着交易的发布，每个交易要消耗UTXO中的输出，同时也会产生一些新的输出</p>
<p>每个交易所有输入的金额，要等于所有输出的金额：total inputs = total outputs</p>
<p>发布区块的那个结点为什么要把你的交易打包在区块里？这样做对她有什么好处吗？</p>
<p>如果只有出块奖励，那么自私的结点就只会打包他自己的交易，同时也节省带宽</p>
<p>所以比特币系统设定了第二个激励机制：交易费（transaction fee），你把我的交易打包在区块里，我给你点小费，所以就会出现total inputs &gt;= total outputs的情况，多的比特币充当了小费</p>
<p><img src="/2020/08/30/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%AE%9E%E7%8E%B0/QQ%E6%88%AA%E5%9B%BE20200817210059.png"></p>
<p>目前矿工去争取记账权，主要还是为了得到出块奖励，但是因为21个区块都会减少出块奖励</p>
<p>比特币系统中差不多10分钟会创建一个区块，计算下来差不多每四年就会减半（出块奖励）</p>
<h2 id="区块的例子"><a href="#区块的例子" class="headerlink" title="区块的例子"></a>区块的例子</h2><p>account-based ledger</p>
<p>以太坊就是这种模式，在这种模式总，系统显式的记录每个账户上有多少个币，比特币的隐私保护就比较好一些</p>
<p><img src="/2020/08/30/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%AE%9E%E7%8E%B0/image-20200817210819638.png"></p>
<p>Height:是区块的序号，Difficulty：挖矿的难度（每隔2016个区块要调整这个难度，保持出块时间在10分钟左右）</p>
<p><img src="/2020/08/30/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%AE%9E%E7%8E%B0/QQ%E6%88%AA%E5%9B%BE20200817211158.png"></p>
<p>注意：计算hash值都是计算block header的哈希值，不包含block body的哈希值</p>
<p>所谓的挖矿，就是不断地调整随机数nonce，使得整个block header的哈希值小于等于给定的目标阈值，这个目标阈值表示成16进制就是前面有一长串的0，所以凡是符合难度要求的区块，它的块头的哈希值，算出来都是要有一长串的0</p>
<p><img src="/2020/08/30/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%AE%9E%E7%8E%B0/QQ%E6%88%AA%E5%9B%BE20200817211615.png"></p>
<p><img src="/2020/08/30/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%AE%9E%E7%8E%B0/QQ%E6%88%AA%E5%9B%BE20200817211913.png"></p>
<p><img src="/2020/08/30/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%AE%9E%E7%8E%B0/QQ%E6%88%AA%E5%9B%BE20200817212243.png"></p>
<p>每个发布的区块里都包含一个特殊的铸币交易</p>
<p><img src="/2020/08/30/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%AE%9E%E7%8E%B0/QQ%E6%88%AA%E5%9B%BE20200817212744.png"></p>
<p>这个对Merkle tree的根哈希值有什么影响吗</p>
<p><img src="/2020/08/30/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%AE%9E%E7%8E%B0/QQ%E6%88%AA%E5%9B%BE20200817213102.png"></p>
<p>coinbase中的前八个字节当作extra nonce来用nonce从2^32-&gt;2^96</p>
<p>所以真正挖矿的时候是有两层循环的，外层循环调整coinbase域的extra nonce ，算出block header中的根哈希值之后，内层循环在调整header里的nonce</p>
<p><img src="/2020/08/30/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%AE%9E%E7%8E%B0/QQ%E6%88%AA%E5%9B%BE20200817213639.png"></p>
<p><img src="/2020/08/30/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%AE%9E%E7%8E%B0/QQ%E6%88%AA%E5%9B%BE20200817213948.png"></p>
<h2 id="概率分析"><a href="#概率分析" class="headerlink" title="概率分析"></a>概率分析</h2><p>每次尝试nonce可以看作是Bernoulli trial：a random experiment with binary outcome</p>
<p>挖矿，每次尝试nonce，成功的概率是微乎其微的，大概率是不行的，如果我们做很多的Bernoulli trial，每个实验都是随机的，这些Bernoulli trial就构成了Bernoulli process：a sequence of independent Bernoulli trials，Bernoulli trial的一个性质是无记忆性：memory less，你做大量的实验，前面的结果和后面的结果是没有关系的</p>
<p>实验很多，每次成功的概率很小，多重伯努利可以用Poisson process来近似，我们关心的是，系统中产生下一个区块的时间，这个在概率中可以推导出来出块时间是服从指数分布的exponential distribution</p>
<p>整个系统平均的出块时间是十分钟，这个时间是比特币协议设计出来的</p>
<p>具体到每个矿工，他能够挖到下一个区块的时间，取决于这个矿工的算力占系统算力的百分比，比如说，你的算力占到系统算力的1%，平均下来，系统里每产生一百个区块，其中有一个区块就是你挖矿挖到的，平均你要等1000分钟才能产生一个区块</p>
<p><img src="/2020/08/30/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%AE%9E%E7%8E%B0/QQ%E6%88%AA%E5%9B%BE20200817215856.png"></p>
<p>这个性质有时候也叫：process free，过去的process是不算数的</p>
<p>假设一下，如果有某个puzzle不满足process free，会出现什么情况：算力强的矿工具有不成比例的优势，因为算力强的矿工过去做的工作肯定是多的，比如有两个矿工，一个矿工的算力是另一个的十倍，那么他挖到矿的概率也是另一个的十倍，这样就满足process free，如果不满足，就会大于十倍！其实process free 恰恰是挖矿公平性的保证。</p>
<h2 id="比特币的总量"><a href="#比特币的总量" class="headerlink" title="比特币的总量"></a>比特币的总量</h2><p>挖矿获得的出矿奖励，是比特币长生的唯一途径，然而这个值每四年就会减半，比特币的总量呈现几何趋势</p>
<p>genmetric series</p>
<p><img src="/2020/08/30/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%AE%9E%E7%8E%B0/QQ%E6%88%AA%E5%9B%BE20200819203300.png"></p>
<p>挖矿对维护比特币系统的安全是至关重要的：Bitcoin is secured by mining，只要大部分算力在诚实的结点手里，系统的安全就可以得到保证。出矿奖励随着出块会减半，那么人们的动力是否会减少呢？从过去的几年来看，恰恰是相反的，比特币的价格是飙升的，如果趋于0之后，是不是就没有动力挖矿了呢？还有第二种激励机制：交易费</p>
<p>比特币的安全性的分析，①假设大部分算力是掌握在诚实的矿工手里，我们能得到什么样的安全保证，能不能保证写入区块里的交易都是合法的？如果落在了10%的不诚实的结点手里，这个节点能不能偷币？能不能把别人账上的钱转给自己？不能，因为他无法伪造别人的签名（需要知道别人的私钥）。如果把这个交易硬写道区块链里呢？</p>
<p><img src="/2020/08/30/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%AE%9E%E7%8E%B0/QQ%E6%88%AA%E5%9B%BE20200819204852.png"></p>
<p>②恶意的结点能不能double spending？</p>
<p>如果M-&gt;A存在某种不可逆的效果，那么M-&gt;M’就可以从中获得不当的利益，比如网上购物，M购买了一些商品，然后网站接受比特币支付，M把帐转给这个网站，网站监听到这个交易写入到区块链里了，以为， 支付成功了，所以把商品给了M，M拿到商品之后，又发起了一个交易M-&gt;M’把钱转给自己，然后按照下面这个区块扩展最长合法链，这样上面那个交易就作废了。</p>
<p><img src="/2020/08/30/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%AE%9E%E7%8E%B0/QQ%E6%88%AA%E5%9B%BE20200819205358.png"></p>
<p>如何防范double spending？类似上面这种攻击</p>
<p><img src="/2020/08/30/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%AE%9E%E7%8E%B0/QQ%E6%88%AA%E5%9B%BE20200819210210.png"></p>
<p><img src="/2020/08/30/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%AE%9E%E7%8E%B0/QQ%E6%88%AA%E5%9B%BE20200819210314.png"></p>
<p>区块链是不可篡改的账本：irrevocable ledger，那是不是说凡是写入区块链的内容，永远改不了呢？根据上面的分析可知，这种不可篡改性，只是一种概率上的保证</p>
<p>其实，还有一种zero confirmation，0个确认，这个意思是说，这个转账交易发布出去了，但是还没有被写入区块链里，商家就确认了这个交易，这种在现实生活中还是比较普遍的，</p>
<p>原因：</p>
<p>①比特币协议缺省的设置是：结点接收最先听到的那个交易，两个交易有冲突，最先听到哪个，接收哪个，所以发布一个M-&gt;A,最先听到这个，在zero confirmation的这个位置，诚实的结点有比较大的几率是不会接收M-&gt;M’这个交易的 </p>
<p>②很多购物网站，从你支付成功，到他把货品发给你，是有一定的时间间隔的，如果发现M-&gt;M’这个转账交易没有在最长合法链里，电商就可以选择取消发货。</p>
<p>假设某个有恶意的结点获得了记账权，他还能干什么坏事？</p>
<p> 能不能不把某些合法的交易写道区块链里？这是可以的，但是会少交易费，比特币规定某个区块的大小是有限制的，最多不能超过1M字节，某个节点交易太多，这些交易就只能等到下个区块在发布</p>
<p>selfish mining：在商家等待6个区块的时候，M-&gt;M’先不发布，在私下偷偷的挖矿，但是不发布，等挖矿创建的区块比6个区块多的时候，一下子全部发布，M-&gt;M’这条链就成了最长合法链；正常的情况是，挖到区块，立马发布，要不然就被别人抢了，所以selfish mining有一个前提，恶意的结点的算力要超过诚实的结点的算力，但是是不可能的</p>
<p>selfish mining还有什么目的，上述是分叉攻击的目的，假设我们能不是为了回滚以前的交易，就是为了正常的挖矿，赚取出块奖励，selfish mining有没有什么好处？减少竞争：别人挖了一个，我已经挖了两个，然后直接抛出去两个,让别人做一些无用功。</p>
]]></content>
      <categories>
        <category>区块链</category>
      </categories>
      <tags>
        <tag>区块链</tag>
      </tags>
  </entry>
  <entry>
    <title>BTC一---密码学基础</title>
    <url>/2020/08/29/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%AF%86%E7%A0%81%E5%AD%A6%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h1 id="密码学基础"><a href="#密码学基础" class="headerlink" title="密码学基础"></a>密码学基础</h1><h1 id="1-哈希"><a href="#1-哈希" class="headerlink" title="1.哈希"></a>1.哈希</h1><p>​    比特币属于加密货币，但是区块链上所有的交易都是公开的，包括账户的地址，转账的金额。</p>
<p>比特币用到了密码学的两个内容：哈希和签名</p>
<p>哈希在比特币中：<code>cryptographic hash function</code></p>
<p>它在密码学中要求的两个性质：</p>
<p>​    ①<code>collision</code>（哈希碰撞） 和<code> resistance</code>：没有什么高效的方法人为的制造哈希碰撞，</p>
<p>​        解释为对于一个x，没有什么高效的办法，找到另一个y，使<code>H(x) = H(y)</code>。</p>
<p>​        用法：对于一个m，哈希值为H(m),没有办法篡改内容，而又不被检测出来，因为找不到另外一个m’，使得<code>H(m) = H(m&#39;)</code>。</p>
<p>​        在理论上，这个性质是证明不出来的，只能依靠实际的经验 例如：md5，我们以前没有办法找到制造哈希碰撞的办法，然而现在却可以。</p>
<a id="more"></a>

<p><img src="/2020/08/29/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%AF%86%E7%A0%81%E5%AD%A6%E5%8E%9F%E7%90%86/QQ%E6%88%AA%E5%9B%BE20200730213309.png"></p>
<p>  如果我们有一个256位的哈希值，他的输出空间就为2^256，但是输入空间是无限的，根据鸽笼原理（抽屉原理），必然会导致哈希碰撞。</p>
<p>②<code>hiding</code>:哈希函数的计算过程是单向的，不可逆的,x可以计算得到H(x),但是H(x)计算不出x，也就是说，H(x)哈希值没有泄漏x的信息。</p>
<p>这个性质的前提是，x的输入范围要足够的大，使得蛮力，遍历破解的方法是不可行的，输入的分布还要比较均匀，各种取值的概率差不多。</p>
<p><img src="/2020/08/29/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%AF%86%E7%A0%81%E5%AD%A6%E5%8E%9F%E7%90%86/QQ%E6%88%AA%E5%9B%BE20200730215143.png"></p>
<p><img src="/2020/08/29/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%AF%86%E7%A0%81%E5%AD%A6%E5%8E%9F%E7%90%86/QQ%E6%88%AA%E5%9B%BE20200730215658.png"></p>
<p>将预测结果作为x,算出一个哈希值,将这个哈希值可以公布出去，因为有<code>hiding</code>的性质，只知道这个哈希值，是不能知道预测结果是什么的，在第二天收盘之后，再将预测值公布出去，因为存在<code>collision  resistance</code>的性质，这个预测结果是不可能的被篡改的，这就是一个<code>sealed envelope</code>的功能。</p>
<p>x—-&gt;H(x)</p>
<p><img src="/2020/08/29/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%AF%86%E7%A0%81%E5%AD%A6%E5%8E%9F%E7%90%86/QQ%E6%88%AA%E5%9B%BE20200730220318.png"></p>
<p>在实际操作中，不是直接对x取哈希值，而是再x后面加上一个<code>nonce</code>（随机数），保证x的随机性，和分布均匀</p>
<p>哈希函数除了在密码学中要求的这两个性质之外。</p>
<p>在比特币中还要求<code>puzzle friendly</code></p>
<p>哈希值的计算结果是不能被预测的，如果想要得到某个范围之间的哈希值，只能一个一个输入结果去试</p>
<p>那这个性质为什么叫<code>puzzle friendly</code>呢</p>
<blockquote>
<p>在比特币中的挖矿：实际上就是找一个nonce（随机数），这个nonce和区块的块头里的其他信息，合在一起，作为输入，取出一个哈希，这个哈希值要小于等于某个指定的目标阈值</p>
<p><img src="/2020/08/29/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%AF%86%E7%A0%81%E5%AD%A6%E5%8E%9F%E7%90%86/QQ%E6%88%AA%E5%9B%BE20200730221330.png"></p>
<p>比特币即区块链，区块链是一个一个区块组成的链表，每个区块有一个块头，块头中有很多的域，其中有一个域是我们可以设置的nonce，挖矿的过程就是不停地去试不同的随机数，使得整个块头取哈希值之后落在指定的范围之内（&lt;=target space）。</p>
<p>puzzle friendly 就是说挖矿的过程，没有捷径，只能靠不停地去试大量的nonce，才能找到符合要求的解，所以这个过程才可以被称为“<strong>工作量证明</strong>（proof of work）”，你找到了nonce，一定是你做了大量的工作，因为没有别的捷径。</p>
<p>虽然挖矿的过程需要大量的工作量，但是只要找到了符合要求的nonce，将这个nonce发布出去，其他人要验证这个nonce是很容易的，只要算一次哈希值就行了。这个就叫做“difficult to solve ，but easy to verify”。</p>
</blockquote>
<p>比特币中用到的哈希函数叫做SHA-256。</p>
<p>SHA:<code>secure Hash Algorithm</code> </p>
<p>我们上面所说的三个性质，他都是满足的</p>
<h1 id="2-签名"><a href="#2-签名" class="headerlink" title="2.签名"></a>2.签名</h1><p>  比特币账户中的账户管理，在日常生活中，可以去中心化的管理机构，比如银行办理手续，</p>
<p>但是在比特币中是去中心化的，那么怎么办理账户呢：每个用户自己决定开户 ，不需要任何人批准，</p>
<p>开户的过程很简单，就是创建一个公钥和私钥的对。</p>
<p><img src="/2020/08/29/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%AF%86%E7%A0%81%E5%AD%A6%E5%8E%9F%E7%90%86/QQ%E6%88%AA%E5%9B%BE20200730222824.png"></p>
<p>公私钥是来源于非对称加密体系：<code>asymmetric encryption algorithm</code>。</p>
<p>  最早的加密体系是对称的:<code>symmetric encryption algorithm</code>   —-&gt;两个人之间要进行通讯，但这个过程可能是被窃听的，所以我们两个人之间商量一个密钥，用来加密，发送信息，再用这个密钥来解密，因为这个加密和解密的密钥用的是同一个，所以被称为对称加密体系，这个前提是，有某种安全的渠道，可以把这个密钥分发给通讯的双方（这也是对称加密的一个弱点，密钥的分发不是很方便）</p>
<p><img src="/2020/08/29/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%AF%86%E7%A0%81%E5%AD%A6%E5%8E%9F%E7%90%86/QQ%E6%88%AA%E5%9B%BE20200730223101.png"></p>
<p>非对称加密：加密用公钥：<code>public key</code> ，解密用私钥:<code> private key</code>,我要把信息传给你，用你的公钥对信息加密，你收到信息，再用你的私钥解密，得到信息，需要注意的是，加密解密用的公钥私钥，都是接收方的，好处是什么？</p>
<blockquote>
<p>大家都可以知道我的公钥，都可以给我发消息，但是私钥是保存在本地的，不用传给对方，这就解决了对称加密过程，密钥分发带来的不方便的问题</p>
<p>所以比特币创建账户，就是在本地创建一个公钥私钥对，这个公钥就相当于银行账户，私钥相当于银行账户密码，知道私钥就可以把账户上的钱转走。</p>
</blockquote>
<p>  比特币虽然叫加密货币，但是其实他是不加密的，信息都是公开的，那我们要这个公钥私钥干嘛？</p>
<blockquote>
<p>实际上就是用来作签名，在我转比特币给另一个账户的时候，别人怎么知道是不是我转的，还是别人冒名顶替转的？</p>
<p>这个时候就需要我用私钥再这个信息上做一个签名，别人再用我的公钥验证我的私钥生成的签名</p>
<p>万一两个人创建的比特币账户的公私钥对相同怎么办？如果是256位的哈希，产生相同的公私钥对的概率是微乎其微的，</p>
<p>这个概率比地球爆炸的概率还要小！</p>
</blockquote>
<p>在生成比特币账户的公私钥的时候，假设前提是我们有一个好的随机源，如果随机源不好，那么这个时候还是有可能两个人的公私钥是相同的，其实不仅是生成账户的时候，在签名的时候也需要有好的随机源！</p>
<h1 id="3-总结"><a href="#3-总结" class="headerlink" title="3.总结"></a>3.总结</h1><p>  密码学中，两个功能，一个是哈希，一个是签名，这两个功能是可以结合起来使用的；</p>
<p>比特币系统中，一般是先对一个message取一个哈希，然后再对这个哈希值签名。</p>
]]></content>
      <categories>
        <category>区块链</category>
      </categories>
      <tags>
        <tag>区块链</tag>
      </tags>
  </entry>
  <entry>
    <title>BTC七---挖矿</title>
    <url>/2020/08/30/%E5%8C%BA%E5%9D%97%E9%93%BE/%E6%8C%96%E7%9F%BF/</url>
    <content><![CDATA[<h1 id="挖矿"><a href="#挖矿" class="headerlink" title="挖矿"></a>挖矿</h1><h2 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h2><p><img src="/2020/08/30/%E5%8C%BA%E5%9D%97%E9%93%BE/%E6%8C%96%E7%9F%BF/QQ%E6%88%AA%E5%9B%BE20200828210256.png"></p>
<a id="more"></a>

<p><img src="/2020/08/30/%E5%8C%BA%E5%9D%97%E9%93%BE/%E6%8C%96%E7%9F%BF/QQ%E6%88%AA%E5%9B%BE20200828210616.png"></p>
<p>比特币网络中大部分节点是轻结点，如果只需要转账，不需要挖矿的话，没必要运行一个全节点。</p>
<p>在挖矿过程中，如果你监听到别人发布了一个区块，这个区块是合法的，也是在延伸最长合法连，这个时候你应该停止已有的挖矿，然后重新在本地组装一个侯选区块，重新挖矿，因为你要沿着这个新发布的区块向下挖的话，那么你本地所组装的这个区块中，包含的交易就会发生变化，有些交易可能已经包含到已经被发布的这个区块里了，block header的内容也会发生变化，Merkle tree的根哈希值，以及指向前一个区块的指针，这样做是不是有些可惜？</p>
<p>其实是不可惜的，因为前面我们提到一个挖矿的性质：无记忆性memory less（process free），所以你是坚持挖原来的区块，还是改成挖一个新组装的区块，成功的机率是一样的。</p>
<p>即时挖到了合法的区块，发布到区块链上，也不是说就是胜利了，有可能你发布的这个区块，最终没有成为最长合法链，</p>
<p>可能存在一些risk condition，别人同时发布了一个合法的区块，或者是存在一些你不知道的double spending，使得你这个区块中某些交易最后是有冲突的。</p>
<p>比特币是怎么保证安全性的？两方面</p>
<p>一方面：密码学上的保证：别人没有你的私钥，就不能伪造你的签名，这个的前提是，系统中拥有大多数算力的矿工是好的，是遵守协议的；</p>
<p>另一方面：共识机制。</p>
<h2 id="挖矿相关"><a href="#挖矿相关" class="headerlink" title="挖矿相关"></a>挖矿相关</h2><p>挖矿的设备：越来越趋向于专业化，最早的时候大家都是用普通的cpu去挖矿。</p>
<p>如果现在，你专门买一台计算机用来挖矿，其实是不划算的，因为计算机中的大部分内存都是闲置的，挖矿只用到其中很小一部分内存，cpu中的大部分部件也是闲置的，因为挖矿的操作只用到了通用cpu中的很少的一部分指令，硬盘和其他很多资源也用不到。</p>
<p>第二代：GPU–&gt;比cpu挖矿的效率高得多，GPU用于大规模的并行计算（像深度学习就用到了GPU，其中有很多矩阵的乘法），但是GPU用来挖矿，其实还是有点浪费的，里面有很多部件仍然处于闲置状态，比如用于浮点数计算的部件（比特币的挖矿只用到了整数计算）</p>
<blockquote>
<p>最近几年，GPU价格上涨的很快，有些人把它归于深度学习的火热，其实有很多GPU是用来挖矿的，不过有个好消息，现在比特币挖矿难度的提升，用GPU挖矿已经划不来了，所以都不竞争去买GPU用于挖矿了。</p>
</blockquote>
<p>现在用什么挖矿？用ASIC（Application Specific Integrated Circuit）芯片，它上面没有多余的电路逻辑，整个芯片就是为了比特币挖矿计算哈希值的操作而设计的，性价比最高，而且，为某一种加密货币设计的ASIC芯片，只能用来挖这一种加密货币，除非这两个加密货币使用同一个mining puzzle，有些加密货币新发行的时候，为了解决能源启动问题，他故意用一个已有的加密货币的mining puzzle，可以吸引更多的人来挖矿，这样的mining puzzle叫做merge mining。</p>
<p>ASIC芯片的研发周期是很长的，比特币的ASIC的芯片需要使用一年的时间，已经算是很快了，创造了ASIC芯片史上的奇迹，在这么长的时间里面，如果比特币的价格发生了很大的变化的话，前期投入的研发费用有可能就打水漂了。</p>
<p>即时在比特币发展的黄金时期，比特币价格上涨，挖矿是有利可图的，但是竞争也是越来越激烈的，定制的ASIC芯片可能用不了几个月就过时了，相当于一个军备竞赛。</p>
<blockquote>
<p>有研究表明，大部分的ASIC矿机，利润是在他上市的前两个月获得的，这个时候的算力在同类产品中最强，所以购买ASIC矿机的时机很重要，现在一般都是提前预定，如果不能及时发货，对矿工就有损利益，有些不良厂商，生产出了矿机，不立即发售，而是自己先用他挖矿</p>
</blockquote>
<p>有些新的加密货币设计的是Alternative mining puzzle 设计的初衷是：ASIC resistance（能够抗ASIC芯片化，目的是为了让通用的计算机也能参与挖矿）</p>
<p>挖矿的另一个趋势是：大量矿池的出现，单个矿工，即使用了ASIC芯片，挖矿从平均收益上看，是有利可图的，但是收入是十分不稳定的：比特币的平均出块时间是10分钟，但是这是总的矿工的平均，从单个矿工来看，可能他要挖一两年才出一个区块，就有点买彩票的意味了；单矿工还要面临一个困难：他除了挖矿之外，还要承担全节点的责任。</p>
<hr>
<p>矿池：就是把矿工组织起来，作为一个整体，矿池的架构是：一个全节点，会驱动很多的矿机</p>
<p><code>miner</code>只负责计算哈希值，<code>pool manager</code>承担全节点的其他职责，<code>pool manager</code>负责监听网上的交易，把这些交易组织打包成一个候选区块，同时看有没有其他的节点抢先发布区块。</p>
<p>矿池还能解决矿工收入不稳定的问题，有了收入，一起分配。分配的问题：如果矿机和矿池是分布式的（不在同一个机构），矿工和矿主不在同一个地方，矿工要加入一个矿池，就是按照这个矿池规定的通信协议，跟矿主练习，矿主把要计算的哈希值的任务分配给他，矿工计算完之后，把结果返回，有出矿奖励大家一起分配，如何分配？</p>
<blockquote>
<p>平均分配？明显的问题是吃“大锅饭”，干好干坏一个样；因此要按照每个矿工的贡献大小进行分配：这个地方同时需要工作量证明，如何证明？</p>
<p>矿工的收入不稳定是因为挖矿太难了，如果降低难度，收入就能稳定，怎么降低难度？原来的要求，找到nonce，匹配target，和block header算哈希前面至少70个零，现在降低难度，前面只要有60个零就行，这样挖到的叫做一个</p>
<p><code>share</code>：<code>almost valid block</code>,矿工挖到这样一个share之后，把他提交给矿主。</p>
<p>矿主拿到share有什么用？这个除了证明矿工的工作量之外，没有其他的用处，不可能发不出去，因为这个区块不是合法的，所以矿主就记录每个矿工提交了多少个share，将来等到某个矿工真的挖到了某个区块之后，再把这个出块奖励，按照每个矿工提交的share的数目分配。</p>
</blockquote>
<p>每个矿工挖到矿的概率取决于他尝试的nonce的数目，尝试的nonce越多，share就越多，所以可以把share作为工作量的衡量。</p>
<p>有没有可能矿工挖到了区块之后，不把他提交给矿主，自己独享？</p>
<blockquote>
<p>每个矿工的任务是由矿主来决定的，矿主负责组装好区块，然后让矿工尝试nonce，而且，光是调整nonce是不够的，还要调整coinBase parameter，所以矿主可能就是把不同的coinbase parameter对应的nonce的范围交给不同的矿工去尝试，那么这个区块里面包含了什么？</p>
<p>coinbase transaction里面有个收款人的地址，这个地址填的是矿主的地主，如果矿工不提交给矿主，他是收不到钱的。</p>
</blockquote>
<p>他不可能偷出块奖励，但是她有没有可能捣乱？（平时挖到一个share，作为工作量证明，但是等他真正挖到一个合法的区块的之后，他把它扔掉）</p>
<blockquote>
<p>但是这样做对他来说并没有什么经济上的好处，矿池之间是存在竞争关系的，有可能为了打击竞争对手，故意派一些矿工到对手的矿池里挖矿，“卧底”！</p>
</blockquote>
<p><img src="/2020/08/30/%E5%8C%BA%E5%9D%97%E9%93%BE/%E6%8C%96%E7%9F%BF/QQ%E6%88%AA%E5%9B%BE20200831215109.png"></p>
<p>​                                                                                    矿池在各个国家的分配比例</p>
<p><img src="/2020/08/30/%E5%8C%BA%E5%9D%97%E9%93%BE/%E6%8C%96%E7%9F%BF/QQ%E6%88%AA%E5%9B%BE20200831215228.png"></p>
<p>​                                                            2014年 GHash.IO矿池总算力占到了全球的51%以上</p>
<p>已经可以发动51攻击了！（当时引起了恐慌）</p>
<p>GHash主动降低总算力，以免动摇大家对比特币的信心</p>
<p><img src="/2020/08/30/%E5%8C%BA%E5%9D%97%E9%93%BE/%E6%8C%96%E7%9F%BF/QQ%E6%88%AA%E5%9B%BE20200831215554.png"></p>
<p>​                                                                                            2018年算力分布</p>
<p>假设一个机构有了一半以上的算力，他不一定要把算力都集中在一个矿池里，它可以把算力分不到不同的矿池里，平时是隐藏的，真正需要发动攻击的时候就结合起来。</p>
<p>矿工转换矿池是很容易的，所以这就是矿池带来的一个危害，如果没有矿池要发动51攻击的话，攻击者要投入大量的硬件成本来购买到足够的矿机，能够达到系统中半数以上的算力。</p>
<p>一般来说，pool manager也要收取一部分的出块奖励作为管理费，有的有恶意的矿池在发动攻击前，故意把矿池的管理费降得特别低，甚至是赔本，吸引到足够多的矿工之后，就可以发动攻击了。</p>
<hr>
<p>假设有矿池达到了51%的算力，他具体能发动什么攻击呢？</p>
<blockquote>
<p>分叉攻击</p>
<p>Boycott：封锁禁域。所有有关某个节点的交易，他都不包含进去，而且这个攻击也不需要等待6个确认，仗着自己的算力强，公开抵制有关某个结点的交易。</p>
</blockquote>
<p>攻击者的矿池中事不明真相的矿工群众，因为每个矿工只是计算哈希值，他并不知道网上有什么样的交易，发布了什么区块，并不知道double spending的存在。</p>
<p>另外，不要把51%的阈值，当成一个门槛，这个其实都是概率，而且，每个矿池所占的算力比重，本身也是一种估计而已，而且实时变化</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>大型矿池的出现，有一定的好处：给矿工减轻了负担，收入分配也更加稳定。</p>
<p>也有一定的危害：发动51攻击更容易了 <code>on demand mining</code></p>
]]></content>
      <categories>
        <category>区块链</category>
      </categories>
      <tags>
        <tag>区块链</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/2020/08/30/%E5%8C%BA%E5%9D%97%E9%93%BE/%E6%8C%96%E7%9F%BF%E9%9A%BE%E5%BA%A6/</url>
    <content><![CDATA[<hr>
<p>title: BTC六—挖矿难度<br>date: 2020-08-30 10:40:19<br>categories: 区块链<br>tags: 区块链<br>type: 比特币<br>cover: img/bitcoin.png</p>
<hr>
<h1 id="挖矿难度"><a href="#挖矿难度" class="headerlink" title="挖矿难度"></a>挖矿难度</h1><h2 id="为什么要调整挖矿难度"><a href="#为什么要调整挖矿难度" class="headerlink" title="为什么要调整挖矿难度"></a>为什么要调整挖矿难度</h2><p>调整挖矿难度，就是调整目标空间在整个输出空间中所占的比例</p>
<p>比特币的哈希算法是SHA-256，256位的哈希值，所以输出空间位2^256个可能取值，调整目标空间占输出空间的比例，通俗的说，就是这个哈希值前面要多少个零，合法的哈希，算出来，前面至少要有70个零，但是严格的话还是按照定义来计算哈希值。</p>
<a id="more"></a>

<p>另外一种概念：挖矿难度，挖矿难度和目标阈值成反比</p>
<p><img src="/2020/08/30/%E5%8C%BA%E5%9D%97%E9%93%BE/%E6%8C%96%E7%9F%BF%E9%9A%BE%E5%BA%A6/QQ%E6%88%AA%E5%9B%BE20200826214434.png"></p>
<p>挖矿难度最小就是1，所以这时候target很大，那我们为什么要调整挖矿难度呢？如果不调，会有什么问题：系统中的总算力越来愈强，挖矿难度不变的话，出块时间就会越来越短，一开始没什么人，按照设计是十分钟出一个区块，后来一分钟就可以出一个区块，再到后来，用的设备越来越先进，不到一秒。</p>
<p>这么快不好吗？我每出现一个交易就可以及时的写入区块里，减少了系统的响应时间，这不是好事吗？其实不是件好事，这样会有什么问题吗？</p>
<p>如果两个结点同时发布了一个区块，那么这个时候可能会出现分叉，分叉就成了常态，可能不仅仅是二分叉，分叉如果过多，对于系统达成共识，是没有好处的，也危害到系统的安全性，比特币系统是假设，大部分算力都掌握在诚实的结点手里，系统当中的总算力越强，安全性就越好（发动51% attack的算力要求就更大）</p>
<p><img src="/2020/08/30/%E5%8C%BA%E5%9D%97%E9%93%BE/%E6%8C%96%E7%9F%BF%E9%9A%BE%E5%BA%A6/QQ%E6%88%AA%E5%9B%BE20200826220208.png"></p>
<p>这个时候，可能10%的算力就可以发动攻击了，所以出块时间，不是越短越好。比特币系统中设计的10分钟的出块原则是不是最优的呢？这个不一定，这个只是说，出块时间要有一个常熟的波动范围，不能无限的减少下去，这个对于支付系统来说，其实还是比较长了。</p>
<p>以太坊就将出块时间降低到了15秒，这样以太坊就要设计一个新的共识协议：ghost，这个之后会提到，以太坊同样也会调整挖矿难度，是出块时间保持稳定；所以，出块时间没有规定多长，但是不管多长，都要保持稳定，而不能无限地减少下去 </p>
<h2 id="如何调整挖矿难度"><a href="#如何调整挖矿难度" class="headerlink" title="如何调整挖矿难度"></a>如何调整挖矿难度</h2><p>比特币中规定了，每隔2016个区块要重新调整目标阈值，大概是每两个星期调整一下</p>
<p><img src="/2020/08/30/%E5%8C%BA%E5%9D%97%E9%93%BE/%E6%8C%96%E7%9F%BF%E9%9A%BE%E5%BA%A6/QQ%E6%88%AA%E5%9B%BE20200828203802.png"></p>
<p>调整的公式：</p>
<p><img src="/2020/08/30/%E5%8C%BA%E5%9D%97%E9%93%BE/%E6%8C%96%E7%9F%BF%E9%9A%BE%E5%BA%A6/QQ%E6%88%AA%E5%9B%BE20200828204035.png"></p>
<p>实际的代码中，上调和下调实际上都是有4倍的限制的，最多增大，下调4倍</p>
<p>那么如何让所有的矿工，都调整目标阈值呢？怎么能让大家都听话？如果恶意的区块不调整target，那么诚实的结点不会认可：检查的内容包括nBits（target的编码版本）域</p>
<p><code>比特币系统中总算力的变化情况</code></p>
<p><img src="/2020/08/30/%E5%8C%BA%E5%9D%97%E9%93%BE/%E6%8C%96%E7%9F%BF%E9%9A%BE%E5%BA%A6/QQ%E6%88%AA%E5%9B%BE20200828205244.png"></p>
<p><code>算力难度的增长情况</code></p>
<p><img src="/2020/08/30/%E5%8C%BA%E5%9D%97%E9%93%BE/%E6%8C%96%E7%9F%BF%E9%9A%BE%E5%BA%A6/QQ%E6%88%AA%E5%9B%BE20200828205539.png"></p>
<p>符合难度调整的设计目标</p>
<p><code>难度调整曲线</code></p>
<p><img src="/2020/08/30/%E5%8C%BA%E5%9D%97%E9%93%BE/%E6%8C%96%E7%9F%BF%E9%9A%BE%E5%BA%A6/QQ%E6%88%AA%E5%9B%BE20200828205648.png"></p>
<p>说明挖矿的人越来越多，设备越来越先进</p>
<p><code>每天的出块时间</code></p>
<p><img src="/2020/08/30/%E5%8C%BA%E5%9D%97%E9%93%BE/%E6%8C%96%E7%9F%BF%E9%9A%BE%E5%BA%A6/QQ%E6%88%AA%E5%9B%BE20200828205804.png"></p>
<p><code>最近半年的出块事件</code></p>
<p><img src="/2020/08/30/%E5%8C%BA%E5%9D%97%E9%93%BE/%E6%8C%96%E7%9F%BF%E9%9A%BE%E5%BA%A6/QQ%E6%88%AA%E5%9B%BE20200828205845.png"></p>
<p><img src="/2020/08/30/%E5%8C%BA%E5%9D%97%E9%93%BE/%E6%8C%96%E7%9F%BF%E9%9A%BE%E5%BA%A6/QQ%E6%88%AA%E5%9B%BE20200828210138.png"></p>
]]></content>
  </entry>
  <entry>
    <title>BTC二---比特币中的数据结构</title>
    <url>/2020/08/29/%E5%8C%BA%E5%9D%97%E9%93%BE/%E6%AF%94%E7%89%B9%E5%B8%81%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<h1 id="比特币中的数据结构"><a href="#比特币中的数据结构" class="headerlink" title="比特币中的数据结构"></a>比特币中的数据结构</h1><h2 id="1-区块链"><a href="#1-区块链" class="headerlink" title="1.区块链"></a>1.区块链</h2><p>这里要用到一个重要的概念叫做哈希指针。</p>
<p>hash pointers，哈希指针，除了要保存这个结构体的地址之外，还要保存这个结构的的哈希值（不仅可以知道这个结构体在内存中的位置，还可以知道这个结构体的内容有没有被篡改）</p>
<p>区块链相比较于普通的链表有何区别？</p>
<a id="more"></a>

<p>①用哈希指针替代了普通的指针</p>
<p><img src="/2020/08/29/%E5%8C%BA%E5%9D%97%E9%93%BE/%E6%AF%94%E7%89%B9%E5%B8%81%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/QQ%E6%88%AA%E5%9B%BE20200802193317.png"></p>
<p>区块链示例</p>
<p><img src="/2020/08/29/%E5%8C%BA%E5%9D%97%E9%93%BE/%E6%AF%94%E7%89%B9%E5%B8%81%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/QQ%E6%88%AA%E5%9B%BE20200802193910.png"></p>
<p><img src="/2020/08/29/%E5%8C%BA%E5%9D%97%E9%93%BE/%E6%AF%94%E7%89%B9%E5%B8%81%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/QQ%E6%88%AA%E5%9B%BE20200802194121.png"></p>
<p>这样做的好处是</p>
<p>tamper-evident log：篡改-证明 日志，当有人篡改了区块链中某一个区块的某个内容，则它的下一个区块的哈希值就对不上了，以此类推，直到最后一个保存在系统中的哈希值也对不上了，这样我们只需要记住保存在系统中的那最后一个哈希值，就可以检测出对任意区块的修改。这也是区块链和普通链表的一个区别。（多米诺骨牌效应）</p>
<p>有了这个性质，系统中就不需要保存整条区块链的内容，比如它可以只保存最近的几千个区块，如果要用到以前的区块怎么办？</p>
<blockquote>
<p>可以问系统中的其他节点，去要这个区块，有些节点可能是有恶意的（去中心化系统），那么如何知道别人给你的区块是不是正确的呢？就用到哈希指针的这个性质！别人给你的最后的那个区块，算一下哈希值，如果和系统中保存的与之对应的后一个区块的哈希值对比之后相同，则正确</p>
</blockquote>
<h2 id="2-Merkle-tree-默克尔树"><a href="#2-Merkle-tree-默克尔树" class="headerlink" title="2.Merkle tree(默克尔树)"></a>2.Merkle tree(默克尔树)</h2><p>和binary tree（二叉树）的区别是，用哈希指针代替了普通的指针</p>
<p><img src="/2020/08/29/%E5%8C%BA%E5%9D%97%E9%93%BE/%E6%AF%94%E7%89%B9%E5%B8%81%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/QQ%E6%88%AA%E5%9B%BE20200802200344.png"></p>
<p>和链式结构一样，“牵一发而动全身”。</p>
<p>各个区块由哈希指针连接在一起的，每个区块所包含的交易，是组织成一个Merkle tree的形式，最底层的数据块实际上是某个交易。</p>
<p>每个区块都是由block header和block body组成，block header 保存这个Merkle tree 的根哈希值，不保存这个区块的交易信息，而block body保存交易信息</p>
<p><img src="/2020/08/29/%E5%8C%BA%E5%9D%97%E9%93%BE/%E6%AF%94%E7%89%B9%E5%B8%81%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/QQ%E6%88%AA%E5%9B%BE20200802200930.png"></p>
<p>Merkle tree的作用？</p>
<p>①提供Merkle proof</p>
<p>比特币中的结点分为两类，一类时全节点，还有一类是轻结点</p>
<p>全节点：保存整个区块的内容，block header和block body都有</p>
<p>轻结点：比如手机上的比特币钱包的应用就属于轻结点，只有一个block header</p>
<p>这样就带来一个问题，如果你想向一个轻结点证明某个交易是写入到了区块链中的 ，该怎么证明？</p>
<p>​    比如我想买你的东西，我就需要向你转钱，我对你说，我对你转钱的交易，已经写到了区块链中了，支付已经完成了，</p>
<p>那么你怎么知道，这个交易已经被写入区块链里了呢？这里就需要用到Merkle proof</p>
<p>一个轻结点，向某个全节点发出请求，请求一个能够证明黄色结点这个交易，被包含在这棵Merkle tree里面的Merkle proof</p>
<p><img src="/2020/08/29/%E5%8C%BA%E5%9D%97%E9%93%BE/%E6%AF%94%E7%89%B9%E5%B8%81%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/QQ%E6%88%AA%E5%9B%BE20200802202232.png"></p>
<p>最后算出的根哈希值，和block header中存储的root hash比较，就可以证明出tx是否在区块链中</p>
<p>这种证明也叫做：</p>
<p>proof of membership</p>
<p>或</p>
<p>proof of inclusion</p>
<p>如果最底下有n个交易：时间复杂度为O(log(n))</p>
<p>那么可不可以证明，区块链中没有某个交易？也就是proof of non-membership</p>
<p>有一种比较笨的方法，就是把这一整颗Merkle tree都传给轻结点，如果hash值都正确，如果某个交易不在叶结点中，则证明了proof of non-membership，时间复杂度为O(n)，有没有比较高效的方法证明不存在？</p>
<p>如果我们对叶结点的排列顺序不了解，那么是没有办法证明交易不在里面的</p>
<p>如果我们对叶结点的排列顺序做一些要求：对每个交易取哈希值，按照这个哈希值从小到大排序，这个时候是有一个好的证明方法的：但是代价是需要排序</p>
<p><img src="/2020/08/29/%E5%8C%BA%E5%9D%97%E9%93%BE/%E6%AF%94%E7%89%B9%E5%B8%81%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/QQ%E6%88%AA%E5%9B%BE20200802204313.png"></p>
<p>sorted Merkle tree：排好序的Merkle tree</p>
<p>比特币中没有这种排好序的Merkle tree，因为比特币中根本不需要作这种不存在证明，没有硬性需求，所以比特币中的Merkle tree 不要求排序</p>
<h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3.总结"></a>3.总结</h2><p>比特币中的两种数据结构：区块链和Merkle tree</p>
<p>除了这两种数据结构，哈希指针还用在什么地方？</p>
<p>只要这个数据结构是无环的，都可以用哈希指针来代替普通指针，有环会带来一定的问题</p>
<p><img src="/2020/08/29/%E5%8C%BA%E5%9D%97%E9%93%BE/%E6%AF%94%E7%89%B9%E5%B8%81%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/QQ%E6%88%AA%E5%9B%BE20200802204834.png"></p>
<p>会出现循环依赖的问题，定不下来任何一个区块，找不到创世纪块</p>
]]></content>
      <categories>
        <category>区块链</category>
      </categories>
      <tags>
        <tag>区块链</tag>
      </tags>
  </entry>
  <entry>
    <title>BTC八---比特币脚本</title>
    <url>/2020/09/02/%E5%8C%BA%E5%9D%97%E9%93%BE/%E6%AF%94%E7%89%B9%E5%B8%81%E8%84%9A%E6%9C%AC/</url>
    <content><![CDATA[<h1 id="比特币脚本"><a href="#比特币脚本" class="headerlink" title="比特币脚本"></a>比特币脚本</h1><p>比特币脚本，十分简单，不像c++，java，有堆栈的概念，比特币脚本是基于栈的脚本语言</p>
<p>下面来看一个具体的交易：</p>
<a id="more"></a>

<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p><img src="/2020/09/02/%E5%8C%BA%E5%9D%97%E9%93%BE/%E6%AF%94%E7%89%B9%E5%B8%81%E8%84%9A%E6%9C%AC/QQ%E6%88%AA%E5%9B%BE20200902204839.png"></p>
<p><img src="/2020/09/02/%E5%8C%BA%E5%9D%97%E9%93%BE/%E6%AF%94%E7%89%B9%E5%B8%81%E8%84%9A%E6%9C%AC/QQ%E6%88%AA%E5%9B%BE20200902205012.png"></p>
<p>size:交易的大小</p>
<p>locktime：用来设定交易的生效时间，0表示立即生效，绝大多数情况下，这个locktime都是0</p>
<p>vin：输入部分</p>
<p>vout：输出部分</p>
<p>time：交易产生的时间</p>
<p>blocktime：区块产生的时间</p>
<p><img src="/2020/09/02/%E5%8C%BA%E5%9D%97%E9%93%BE/%E6%AF%94%E7%89%B9%E5%B8%81%E8%84%9A%E6%9C%AC/QQ%E6%88%AA%E5%9B%BE20200902205303.png"></p>
<p>交易的输入是一个数组，一个交易可以有多个输入，每个输入都要说明输入花的币都是来自之前那个交易的输出</p>
<p>txid：输出这个币的交易的哈希值，</p>
<p>vout：表示是当前交易里的第几个输出，相当于id</p>
<p>scriptSig：输入脚本，因为最简单的输入脚本就是给一个sianature就行了，证明你有权利花这个钱</p>
<p><img src="/2020/09/02/%E5%8C%BA%E5%9D%97%E9%93%BE/%E6%AF%94%E7%89%B9%E5%B8%81%E8%84%9A%E6%9C%AC/QQ%E6%88%AA%E5%9B%BE20200902205729.png"></p>
<p>同样是一个数组，</p>
<p>value：表示输出的金额(BTC)，有时候也用Satoshi表示（1Satoshi=0.00000001 BTC）</p>
<p>n：表示这个当前交易的第几个输出，相当于id</p>
<p>scriptPubKey：输出脚本，因为输出脚本最简单的形式就是给出一个public key，所以叫做scriptPubKey</p>
<p>asm：输出脚本的内容，里面包含一系列的操作</p>
<p>reqSigs：表示这个输出需要多少个签名才能兑现</p>
<p>type：输出类型</p>
<p>address：输出地址</p>
<h2 id="脚本执行"><a href="#脚本执行" class="headerlink" title="脚本执行"></a>脚本执行</h2><p><img src="/2020/09/02/%E5%8C%BA%E5%9D%97%E9%93%BE/%E6%AF%94%E7%89%B9%E5%B8%81%E8%84%9A%E6%9C%AC/QQ%E6%88%AA%E5%9B%BE20200902210638.png"></p>
<p>如果一个交易有多个输入，那么每个输入脚本都要和对应的输出脚本匹配之后再进行验证，如果全都验证通过，这个交易才是合法的</p>
<h4 id="比特币脚本的几种形式"><a href="#比特币脚本的几种形式" class="headerlink" title="比特币脚本的几种形式"></a>比特币脚本的几种形式</h4><p>一、ee</p>
<p><img src="/2020/09/02/%E5%8C%BA%E5%9D%97%E9%93%BE/%E6%AF%94%E7%89%B9%E5%B8%81%E8%84%9A%E6%9C%AC/QQ%E6%88%AA%E5%9B%BE20200902211305.png"> 这个签名是用私钥，对整个交易的签名，注意：input script实在我要花这个钱的时候的输出，所以签名是收款人的私钥的签名。（而不是付款人的私钥的签名）</p>
<p>①把输入脚本的签名压入栈</p>
<p><img src="/2020/09/02/%E5%8C%BA%E5%9D%97%E9%93%BE/%E6%AF%94%E7%89%B9%E5%B8%81%E8%84%9A%E6%9C%AC/QQ%E6%88%AA%E5%9B%BE20200902211520.png"></p>
<p>②把输出脚本的收款人的公钥压入栈</p>
<p><img src="/2020/09/02/%E5%8C%BA%E5%9D%97%E9%93%BE/%E6%AF%94%E7%89%B9%E5%B8%81%E8%84%9A%E6%9C%AC/QQ%E6%88%AA%E5%9B%BE20200902211603.png"></p>
<p>③执行CHECKSIG，用PubKey（那么这个）检查Sig是否正确，如果为true，则合法</p>
<p><img src="/2020/09/02/%E5%8C%BA%E5%9D%97%E9%93%BE/%E6%AF%94%E7%89%B9%E5%B8%81%E8%84%9A%E6%9C%AC/QQ%E6%88%AA%E5%9B%BE20200902211801.png"></p>
<p>二、</p>
<p><img src="/2020/09/02/%E5%8C%BA%E5%9D%97%E9%93%BE/%E6%AF%94%E7%89%B9%E5%B8%81%E8%84%9A%E6%9C%AC/QQ%E6%88%AA%E5%9B%BE20200902212706.png"></p>
<p><img src="/2020/09/02/%E5%8C%BA%E5%9D%97%E9%93%BE/%E6%AF%94%E7%89%B9%E5%B8%81%E8%84%9A%E6%9C%AC/QQ%E6%88%AA%E5%9B%BE20200902213056.png"></p>
<p><img src="/2020/09/02/%E5%8C%BA%E5%9D%97%E9%93%BE/%E6%AF%94%E7%89%B9%E5%B8%81%E8%84%9A%E6%9C%AC/QQ%E6%88%AA%E5%9B%BE20200902213129.png"></p>
<p><img src="/2020/09/02/%E5%8C%BA%E5%9D%97%E9%93%BE/%E6%AF%94%E7%89%B9%E5%B8%81%E8%84%9A%E6%9C%AC/QQ%E6%88%AA%E5%9B%BE20200902213225.png"></p>
<p><img src="/2020/09/02/%E5%8C%BA%E5%9D%97%E9%93%BE/%E6%AF%94%E7%89%B9%E5%B8%81%E8%84%9A%E6%9C%AC/QQ%E6%88%AA%E5%9B%BE20200902213253.png"></p>
<p><img src="/2020/09/02/%E5%8C%BA%E5%9D%97%E9%93%BE/%E6%AF%94%E7%89%B9%E5%B8%81%E8%84%9A%E6%9C%AC/QQ%E6%88%AA%E5%9B%BE20200902213338.png"></p>
<p>下面这个hash是你要花这个钱的时候，在输入脚本里给出的公钥</p>
<p><img src="/2020/09/02/%E5%8C%BA%E5%9D%97%E9%93%BE/%E6%AF%94%E7%89%B9%E5%B8%81%E8%84%9A%E6%9C%AC/QQ%E6%88%AA%E5%9B%BE20200902214127.png"></p>
<p><img src="/2020/09/02/%E5%8C%BA%E5%9D%97%E9%93%BE/%E6%AF%94%E7%89%B9%E5%B8%81%E8%84%9A%E6%9C%AC/QQ%E6%88%AA%E5%9B%BE20200902214623.png"></p>
<p>P2PK是最常用的脚本形式！</p>
<p>三、</p>
<p><img src="/2020/09/02/%E5%8C%BA%E5%9D%97%E9%93%BE/%E6%AF%94%E7%89%B9%E5%B8%81%E8%84%9A%E6%9C%AC/QQ%E6%88%AA%E5%9B%BE20200902214832.png"></p>
<p>输出脚本给出的不是收款人的公钥的哈希，而是收款人给出的一个脚本的哈希，redeemScript（赎回脚本），将来花这个钱的时候，输入脚本需要给出redeemScript的具体内容，同时还要给出让这个赎回脚本能够顺利运行所需要的签名</p>
<p><img src="/2020/09/02/%E5%8C%BA%E5%9D%97%E9%93%BE/%E6%AF%94%E7%89%B9%E5%B8%81%E8%84%9A%E6%9C%AC/QQ%E6%88%AA%E5%9B%BE20200902215249.png"></p>
<p>验证分为两步：</p>
<p>①验证输入脚本里给出的redeemScript（赎回脚本）是不是跟输出脚本里给出的哈希值匹配，如果不匹配的话，那么说明给出的赎回脚本是不对的，就类似于P2PKH给出的公钥不对一样，那么验证就失败了；</p>
<p>如果赎回脚本是正确的，那么第二步还要把赎回脚本的内容当作操作指令来执行一遍，看看最后能不能顺利执行，如果两部验证都通过了，那么这个交易才是合法的。</p>
<p><img src="/2020/09/02/%E5%8C%BA%E5%9D%97%E9%93%BE/%E6%AF%94%E7%89%B9%E5%B8%81%E8%84%9A%E6%9C%AC/QQ%E6%88%AA%E5%9B%BE20200902215724.png"></p>
<p>这里的输入脚本就是给出签名，再给出序列化的赎回脚本</p>
<p>赎回脚本的内容就是给出公钥之后，用CHECKSIG检查签名</p>
<p>下面这个输出脚本是用来验证输入脚本给出的赎回脚本是否正确</p>
<p>验证过程：</p>
<p>①②</p>
<p><img src="/2020/09/02/%E5%8C%BA%E5%9D%97%E9%93%BE/%E6%AF%94%E7%89%B9%E5%B8%81%E8%84%9A%E6%9C%AC/QQ%E6%88%AA%E5%9B%BE20200902220031.png"></p>
<p>③</p>
<p><img src="/2020/09/02/%E5%8C%BA%E5%9D%97%E9%93%BE/%E6%AF%94%E7%89%B9%E5%B8%81%E8%84%9A%E6%9C%AC/QQ%E6%88%AA%E5%9B%BE20200902220119.png"></p>
<p>④</p>
<p><img src="/2020/09/02/%E5%8C%BA%E5%9D%97%E9%93%BE/%E6%AF%94%E7%89%B9%E5%B8%81%E8%84%9A%E6%9C%AC/QQ%E6%88%AA%E5%9B%BE20200902220214.png"></p>
<p>⑤</p>
<p><img src="/2020/09/02/%E5%8C%BA%E5%9D%97%E9%93%BE/%E6%AF%94%E7%89%B9%E5%B8%81%E8%84%9A%E6%9C%AC/QQ%E6%88%AA%E5%9B%BE20200902220310.png"></p>
<p>至此，第一个阶段的验证就到这里结束了，现在进入第二阶段的验证。</p>
<p>第二个阶段首先要把输入脚本里提供的序列化的赎回脚本进行反序列化（序列化才能去哈希，我是这样理解的，如果有什么不对的地方，欢迎再下方评论给我留言！），反序列化的操作是每个结点自己要完成的，然后执行这个被反序列化之后的赎回脚本（反序列化之后就可以执行了，相当于解压）</p>
<p><img src="/2020/09/02/%E5%8C%BA%E5%9D%97%E9%93%BE/%E6%AF%94%E7%89%B9%E5%B8%81%E8%84%9A%E6%9C%AC/QQ%E6%88%AA%E5%9B%BE20200902220405.png"></p>
<p>将PubKey压入栈，之后CHECKSIG</p>
<p><img src="/2020/09/02/%E5%8C%BA%E5%9D%97%E9%93%BE/%E6%AF%94%E7%89%B9%E5%B8%81%E8%84%9A%E6%9C%AC/QQ%E6%88%AA%E5%9B%BE20200902220727.png"></p>
<p>那么这种P2SH的方式有什么好处呢？为什么要搞这么复杂？为什么要把这一部分功能嵌入到赎回脚本里面？</p>
<blockquote>
<p>确实，对这个简单的例子来讲，确实有点复杂了，P2SH在最初版本的比特币中是没有的，后来通过软分叉的形式加进去的，它的一个常见的应用场景就是对<strong>多重签名</strong>的支持。一个输出，可能需要多个签名，才能把钱取出来。</p>
<p>比如某个公司的账户，可能要求五个合伙人中，任意三个人的签名，才能把账上的钱取走，为私钥的泄露提供了一些安全的保护。同时也为私钥的丢失，提供了冗余。</p>
</blockquote>
<p>输出脚本给出的M，对应需要多少人的私钥才能匹配，CHECKMULTISIG操作对应匹配操作</p>
<p>输入脚本中第一行的×：比特币中CHECKMULTISIG的实现有一个bug（执行的时候会从堆栈上多弹出一个元素），这个bug现在已经没有办法改了，去中心化的系统，升级软件带来的代价是很大的，要改的话需要硬分叉，所以解决方案是，往栈上多压入一个没用的元素。</p>
<p>另外输入脚本的M个签名的顺序要对应N个公钥的顺序</p>
<p><img src="/2020/09/02/%E5%8C%BA%E5%9D%97%E9%93%BE/%E6%AF%94%E7%89%B9%E5%B8%81%E8%84%9A%E6%9C%AC/QQ%E6%88%AA%E5%9B%BE20200904192209.png"></p>
<p><img src="/2020/09/02/%E5%8C%BA%E5%9D%97%E9%93%BE/%E6%AF%94%E7%89%B9%E5%B8%81%E8%84%9A%E6%9C%AC/QQ%E6%88%AA%E5%9B%BE20200904192224.png"></p>
<p>一次压入栈，看看栈中是否有两个对应的签名，如果有的话，验证通过</p>
<p><img src="/2020/09/02/%E5%8C%BA%E5%9D%97%E9%93%BE/%E6%AF%94%E7%89%B9%E5%B8%81%E8%84%9A%E6%9C%AC/QQ%E6%88%AA%E5%9B%BE20200904192304.png"></p>
<p>注意，这个过程并没有使用P2SH(早期的多重签名只是使用CHECKMULTISTG的方式来实现)</p>
<p>如果是在网上购物的话，用户再转账的时候就需要传给电商公司对应的N个公钥和M的值，这个N个公钥的值和M会在电商网站上公布出来，用户可以相应地填入（每个电商网站可能都不太一样），这样就给用户交易带来了一些不方便的地方（因为这些复杂性都暴露给用户了）。</p>
<p>那么怎么办呢？</p>
<blockquote>
<p>就需要用到P2SH，它的本质是把复杂度从输出脚本转移到了输入脚本</p>
</blockquote>
<p><img src="/2020/09/02/%E5%8C%BA%E5%9D%97%E9%93%BE/%E6%AF%94%E7%89%B9%E5%B8%81%E8%84%9A%E6%9C%AC/QQ%E6%88%AA%E5%9B%BE20200904193001.png"></p>
<p>复杂度被转移到了redeemScript（赎回脚本由输入脚本提供），输出脚本只需要给出赎回脚本的哈希就可以了，用户只需要知道赎回脚本的哈希值</p>
<p>执行阶段一、</p>
<p><img src="/2020/09/02/%E5%8C%BA%E5%9D%97%E9%93%BE/%E6%AF%94%E7%89%B9%E5%B8%81%E8%84%9A%E6%9C%AC/QQ%E6%88%AA%E5%9B%BE20200904193524.png"></p>
<p><img src="/2020/09/02/%E5%8C%BA%E5%9D%97%E9%93%BE/%E6%AF%94%E7%89%B9%E5%B8%81%E8%84%9A%E6%9C%AC/QQ%E6%88%AA%E5%9B%BE20200904193544.png"></p>
<p><img src="/2020/09/02/%E5%8C%BA%E5%9D%97%E9%93%BE/%E6%AF%94%E7%89%B9%E5%B8%81%E8%84%9A%E6%9C%AC/QQ%E6%88%AA%E5%9B%BE20200904193708.png"></p>
<p><img src="/2020/09/02/%E5%8C%BA%E5%9D%97%E9%93%BE/%E6%AF%94%E7%89%B9%E5%B8%81%E8%84%9A%E6%9C%AC/QQ%E6%88%AA%E5%9B%BE20200904193739.png"></p>
<p><img src="/2020/09/02/%E5%8C%BA%E5%9D%97%E9%93%BE/%E6%AF%94%E7%89%B9%E5%B8%81%E8%84%9A%E6%9C%AC/QQ%E6%88%AA%E5%9B%BE20200904193844.png"></p>
<p>执行阶段二、</p>
<p>把赎回脚本展开后执行</p>
<p><img src="/2020/09/02/%E5%8C%BA%E5%9D%97%E9%93%BE/%E6%AF%94%E7%89%B9%E5%B8%81%E8%84%9A%E6%9C%AC/QQ%E6%88%AA%E5%9B%BE20200904193944.png"></p>
<p><img src="/2020/09/02/%E5%8C%BA%E5%9D%97%E9%93%BE/%E6%AF%94%E7%89%B9%E5%B8%81%E8%84%9A%E6%9C%AC/QQ%E6%88%AA%E5%9B%BE20200904194013.png"></p>
<p>第二阶段的验证和前面直接使用CHECKMULTISIG的情况是类似的</p>
<p><img src="/2020/09/02/%E5%8C%BA%E5%9D%97%E9%93%BE/%E6%AF%94%E7%89%B9%E5%B8%81%E8%84%9A%E6%9C%AC/QQ%E6%88%AA%E5%9B%BE20200904194115.png"></p>
<h4 id="Proof-of-Burn"><a href="#Proof-of-Burn" class="headerlink" title="Proof of Burn"></a>Proof of Burn</h4><p><img src="/2020/09/02/%E5%8C%BA%E5%9D%97%E9%93%BE/%E6%AF%94%E7%89%B9%E5%B8%81%E8%84%9A%E6%9C%AC/QQ%E6%88%AA%E5%9B%BE20200904194329.png"></p>
<p>比较特殊，输出脚本的开头是RETURN操作，后面可以跟任意的内容，RETURN这个操作的内容是无条件的返回错误，所以包含这个操作的脚本永远不可能通过验证，执行到RETURN这个语句就结束了，后面的内容根本没有机会执行</p>
<p>为什么要设置这样的输出脚本？</p>
<blockquote>
<p>这里的钱不是会永远花不出去？这个脚本是证明销毁比特币的一种方法，为什么要销毁？</p>
<p>这个一般是两种应用场景：</p>
<p>①一些小的币种，要求销毁一定数量的比特币才能够得到这个币种，有时候我们管这种小币种叫做AltCoin（Alternative Coin），有的小币种，可能要求你销毁一个比特币，可以得到1000个这样的小币，也就是说，你需要用Proof of Burn这种方法证明你付出了一定的代价，才能够得到这种小币种。</p>
<p>②往区块链里写入一些内容，我们说区块链是个不可篡改的账本，那么有人就利用这种特性，往里面添加一些需要永久保存的内容，你要证明在某个时间知道某些事情，比如说涉及到知识产权保护的，把某项知识产权的内容去哈希之后，把哈希值放在RETURN语句的后面，这个语句后面的内容反正是永远不会被执行的，写什么都没关系，不会占用太大的空间，也不会泄露知识产权的内容，将来如果出现了知识产权的纠纷，那么你再把这个记录的知识产权公布出去，证明你在某个时间点已经知道了某个知识了。</p>
</blockquote>
<p>注意：Proof of Burn这种方法所有节点都可以使用，而CoinBase 里的 coinbase transaction域只有获得记账权的节点才能使用，任何用户都可以销毁一点比特币，换取向这个区块链里写入内容的机会。甚至有点交易都没有销毁比特币，只是消耗了交易费。</p>
<p>有一点需要注意，图片中的交易为了简单起见，都没有写OP前缀，比如OP_CHECKSIG</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>比特币系统中使用的脚本语言是非常简单的（比特币的脚本语言不支持循环），甚至连专门的名字都没有。虽然在某些方法功能有限，但是在另外一些方面功能却很强大，就是和密码学相关的功能是很强大的，比如CHECKMULITSIG用一条语句就可以完成。</p>
]]></content>
      <categories>
        <category>区块链</category>
      </categories>
      <tags>
        <tag>区块链</tag>
      </tags>
  </entry>
  <entry>
    <title>BTC五---网络</title>
    <url>/2020/08/30/%E5%8C%BA%E5%9D%97%E9%93%BE/%E7%BD%91%E7%BB%9C/</url>
    <content><![CDATA[<h1 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h1><p>新发布的区块，新发布的交易，再区块链中是怎么传播的？</p>
<a id="more"></a>

<p>比特币网络的工作原理</p>
<p>The BitCoin Network，比特币工作在应用层，它的底层是一个P2P Overlay Network，所有结点都是对等的，他不想有些所谓的P2P网络有所谓的超结点(Super node | master node),你要加入比特币网络，你要至少知道一个种子结点（seed node），你和这个种子节点联系，他会告诉你他所知道的网络中的其他节点，节点之间是通过tcp通信的，这样有利于穿破防火墙，你离开的时候也不需要执行其他操作（比如通知其他结点，退出应用程序即可），别的节点没有听到你的消息，过了一段时间就会把你删掉。</p>
<p>比特币网络的设计原则是简单（simple，robust，but not efficient），每个结点维护一个邻居节点的集合，消息传播在网络中采取flooding（泛洪）的方式，结点第一次听到某个消息的时候，把他传播给所有的邻居结点，同时记录一下，这个消息我已经记录过了，下次再收到这个消息的时候，就不用转发给邻居节点了</p>
<p>邻居结点的选取是随机的，没有考虑底层的拓扑结构，和地区没有关系，这样的好处是增强鲁棒性，没有考虑实际的拓扑结构，但是牺牲的是效率，向身边的人转账和向美国的人转账速度其实是差不多的。</p>
<p>比特币系统中每个节点要维护一个等待上链的交易的集合。第二次听到同样的交易就不会传播给邻居结点，避免交易在网络中无限制的传播下去，转发的前提是这个交易得是合法的，这里有一个risk condition：有可能你有两个有冲突的交易，差不多同时被广播到网络上</p>
<p><img src="/2020/08/30/%E5%8C%BA%E5%9D%97%E9%93%BE/%E7%BD%91%E7%BB%9C/QQ%E6%88%AA%E5%9B%BE20200826201624.png"></p>
<p>新发布的区块在网络中的传播方式和新发布的交易在网络中传播是相似的，每个结点除了要检查区块的内容之外，还要检查一下是否在最长合法链上，越是大的区块，在网络中传播的速度就越慢，比特币协议对区块大小有一个限制，1M字节的限制，1M大小的区块在区块链中的传播时间就已经达到了50秒（传播完）</p>
<p>我们讲的比特币网络，它的传播是属于best effort，一个交易发布到网络上，不一定所有的节点都能收到，而且不同的节点收到这个交易的顺序也不一定是一样的，网络传播存在延迟，有的节点也不一定按照比特币协议的要求转发，比如有的该转发的它不转发，导致某些合法的交易收不到，有些节点也有可能转发一些不该转发的消息，比如有些不合法的交易，他也会转发，这是去中心化系统中所面临的问题</p>
]]></content>
      <categories>
        <category>区块链</category>
      </categories>
      <tags>
        <tag>区块链</tag>
      </tags>
  </entry>
  <entry>
    <title>ETH十二---美链</title>
    <url>/2020/12/04/%E5%8C%BA%E5%9D%97%E9%93%BE/%E7%BE%8E%E9%93%BE/</url>
    <content><![CDATA[<h1 id="美链"><a href="#美链" class="headerlink" title="美链"></a>美链</h1><p>​    上篇文章The DAO的例子是2016年发生的，美链这个例子是2018年四月才发生的，出问题的智能合约叫做美链—Beauty Chain。</p>
<a id="more"></a>

<p><img src="/2020/12/04/%E5%8C%BA%E5%9D%97%E9%93%BE/%E7%BE%8E%E9%93%BE/QQ%E6%88%AA%E5%9B%BE20201204203251.png"></p>
<blockquote>
<p>上图中的ERC是以太坊发行代币的一个标准，ERC：Ethereum Request for comments。</p>
</blockquote>
<p>​    以太坊上面发行着各种各样的代币，以太币的价格上涨的一个原因是因为ICO（Initial Coin offering），这些发行的代币没有自己的区块链，而是以智能合约的形式运行在以太坊的EVM平台上，发行这个代币的智能合约对应的是以太坊状态中的一个结点，这个结点有它自己的状态余额，相当于这个智能合约一共有多少个以太币，相当于这个发行代币的智能合约总的资产有多少个以太币，然后在这个合约里，每个账户上有多少个代币，这个是作为存储树中的变量存储在智能合约的账户里的，代币的发行、转账、销毁，都是通过调用智能合约中的函数来实现的，这个也是和以太坊中的以太币不太一样的地方，他不想以太坊那样，通过挖矿来维护一个底层的基础链。以太坊上每个账户有多少个以太币，这个是直接保存在状态数上的变量，然后转账的时候以太坊上两个账户之间转账，只通过发布一个交易到区块链上，这个交易会打包到发布的区块里，而代币要转账的话，是智能合约的两个账户之间通过调用智能合约的函数就可以完成。</p>
<p>​    每个代币可以指定自己的发行规则，比如说某一个代币是可以1个以太币兑换100个代币，比如说从你的外部账户给智能合约发进去一个以太币，那么这个智能合约就可以给你在这个合约里的代币账户上发送100个代币。每个账户上有多少个代币的这些信息都是维护在存储树中（发行这个代币的智能合约的存储树里面）。</p>
<p>​    以太坊平台的出现为各种代币的发行提供了很大的方便，包括EOS（使用DOPS协议形成的共识），这个在上线前，也是作为以太坊上的一个代币的形式发行的，这个EOS本身的目标是做成一个基础链，和以太坊要竞争的。</p>
<p>​    batchTransfer的实现：</p>
<p><img src="/2020/12/04/%E5%8C%BA%E5%9D%97%E9%93%BE/%E7%BE%8E%E9%93%BE/QQ%E6%88%AA%E5%9B%BE20201204204908.png"></p>
<blockquote>
<p>上图的函数有两个参数，第一个参数是接受代币的接收者的数组的地址，在函数体里，要检查一下接受者的个数要小于等于20个，第二个参数中的value是转账的金额（给每个人转多少），函数体里先算一下总的金额，每人发送value个代币，一共要amount个代币，然后检查一下发起调用的这个账户确实是有这么多代币，然后把发起调用的账户上的代币数目减去amount，之后用一个循环给每一个接收者接受value的代币。会有什么问题？这和上一个例子不是同一个问题，否则就没必要再举例了……</p>
<p>问题出在计算总数amount上，如果value的值非常大，就是给每个receiver发送的value都很大的话，这个乘法可能溢出，发生溢出之后，amount可能是一个很小的值，所以从调用的账户上去减的时候，减的是很小的一部分代币，但是底下给每个receiver增加的代币数目仍然是value，这样做的结果相当于系统当中凭空多发行了很多的代币。</p>
</blockquote>
<p><img src="/2020/12/04/%E5%8C%BA%E5%9D%97%E9%93%BE/%E7%BE%8E%E9%93%BE/QQ%E6%88%AA%E5%9B%BE20201204210103.png"></p>
<p><img src="/2020/12/04/%E5%8C%BA%E5%9D%97%E9%93%BE/%E7%BE%8E%E9%93%BE/QQ%E6%88%AA%E5%9B%BE20201204210229.png"></p>
<blockquote>
<p>上图中红框中都是接受了很大数量的代币。</p>
</blockquote>
<p><img src="/2020/12/04/%E5%8C%BA%E5%9D%97%E9%93%BE/%E7%BE%8E%E9%93%BE/QQ%E6%88%AA%E5%9B%BE20201204210316.png"></p>
<p><img src="/2020/12/04/%E5%8C%BA%E5%9D%97%E9%93%BE/%E7%BE%8E%E9%93%BE/QQ%E6%88%AA%E5%9B%BE20201204210357.png"></p>
<p>这个事情应该给我们一个什么样的反思？在写代码的时候一定要检查数值溢出的问题。</p>
<p><img src="/2020/12/04/%E5%8C%BA%E5%9D%97%E9%93%BE/%E7%BE%8E%E9%93%BE/QQ%E6%88%AA%E5%9B%BE20201204210524.png"></p>
<blockquote>
<p>首先用a<em>b得到c，然后用c/a看能不能得到b，如果发生溢出的话，assert会抛出异常。a</em>b会不会精度丢失，c再除a得到的c是否还是ab的结果？但是这个问题在solidity里面是不存在的，因为ab都是整数。</p>
</blockquote>
<p><img src="/2020/12/04/%E5%8C%BA%E5%9D%97%E9%93%BE/%E7%BE%8E%E9%93%BE/QQ%E6%88%AA%E5%9B%BE20201204210954.png"></p>
]]></content>
      <categories>
        <category>区块链</category>
      </categories>
      <tags>
        <tag>区块链</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM二---类加载器</title>
    <url>/2020/10/13/Java/JVM/jvm%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/</url>
    <content><![CDATA[<h2 id="1-类加载子系统"><a href="#1-类加载子系统" class="headerlink" title="1.类加载子系统"></a>1.类加载子系统</h2><p>​    如果要手写一个java虚拟机，主要考虑两部分：类加载系统和执行引擎。</p>
<blockquote>
<p>​    类加载系统：加载.class文件</p>
<p>​    执行引擎：逐条解释执行指令</p>
</blockquote>
<a id="more"></a>

<p>内存结构概述:</p>
<p><img src="/2020/10/13/Java/JVM/jvm%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/QQ%E6%88%AA%E5%9B%BE20200719215652.png"></p>
<p>作用：</p>
<p><img src="/2020/10/13/Java/JVM/jvm%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/QQ%E6%88%AA%E5%9B%BE20200719220754.png"></p>
<p>这个里特定的文件标识是coffee baby 魔术</p>
<blockquote>
<p>虚拟机借助魔数，用来识别.class 文件，虚拟机在加载类文件之前会先检查魔数，如果不是 0xCAFEBABE 则拒绝加载该文件。</p>
</blockquote>
<p>运行时常量池，是Class文件中的常量池：Class文件中的常量，加载到内存里面，就变成了运行时常量池</p>
<p><img src="/2020/10/13/Java/JVM/jvm%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/QQ%E6%88%AA%E5%9B%BE20200719221835.png"></p>
<h3 id="类的加载过程"><a href="#类的加载过程" class="headerlink" title="类的加载过程"></a>类的加载过程</h3><p><img src="/2020/10/13/Java/JVM/jvm%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/QQ%E6%88%AA%E5%9B%BE20200719222115.png"></p>
<p>类的加载过程：<strong>加载</strong>、链接（验证、准备、解析）、初始化</p>
<h3 id="加载、链接、初始化"><a href="#加载、链接、初始化" class="headerlink" title="加载、链接、初始化"></a>加载、链接、初始化</h3><h4 id="1-加载"><a href="#1-加载" class="headerlink" title="1.加载"></a>1.加载</h4><p><img src="/2020/10/13/Java/JVM/jvm%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/QQ%E6%88%AA%E5%9B%BE20200719222648.png"></p>
<p>生成大的class对象是在加载的过程中实现的</p>
<p><img src="/2020/10/13/Java/JVM/jvm%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/QQ%E6%88%AA%E5%9B%BE20200719222843.png"></p>
<h4 id="2-链接"><a href="#2-链接" class="headerlink" title="2.链接"></a>2.链接</h4><p><img src="/2020/10/13/Java/JVM/jvm%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/QQ%E6%88%AA%E5%9B%BE20200719223330.png"></p>
<h4 id="3-初始化"><a href="#3-初始化" class="headerlink" title="3.初始化"></a>3.初始化</h4><p><img src="/2020/10/13/Java/JVM/jvm%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/QQ%E6%88%AA%E5%9B%BE20200723210417.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> num = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><img src="/2020/10/13/Java/JVM/jvm%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/QQ%E6%88%AA%E5%9B%BE20200723211232.png"></p>
<p>这里需要注意的是，clinit方法，不是我们定义的，而是jvm自己定义的方法</p>
<p><img src="/2020/10/13/Java/JVM/jvm%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/QQ%E6%88%AA%E5%9B%BE20200723212202.png"></p>
<p><strong>如果程序里没有类变量或者静态代码块，就不会有clinit方法</strong></p>
<p><img src="/2020/10/13/Java/JVM/jvm%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/QQ%E6%88%AA%E5%9B%BE20200723213023.png"></p>
<p><img src="/2020/10/13/Java/JVM/jvm%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/QQ%E6%88%AA%E5%9B%BE20200723213339.png"></p>
<p>虚拟机必须保证一个类的clinit方法在多线程下被同步加锁</p>
<p>因为，类的类型信息在jdk8之后是存放在元空间（本地直接内存中），一个类只能被加载一次，所以一个线程在clinit的时候，别的线程是不能clinit这个类的，也就是同步加锁</p>
<h2 id="2-类加载器"><a href="#2-类加载器" class="headerlink" title="2.类加载器"></a>2.类加载器</h2><h3 id="简要介绍"><a href="#简要介绍" class="headerlink" title="简要介绍"></a>简要介绍</h3><p><img src="/2020/10/13/Java/JVM/jvm%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/QQ%E6%88%AA%E5%9B%BE20200724220728.png"></p>
<p><img src="/2020/10/13/Java/JVM/jvm%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/QQ%E6%88%AA%E5%9B%BE20200724221056.png"></p>
<p><img src="/2020/10/13/Java/JVM/jvm%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/QQ%E6%88%AA%E5%9B%BE20200724220823.png">    <img src="/2020/10/13/Java/JVM/jvm%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/QQ%E6%88%AA%E5%9B%BE20200724221713.png"></p>
<p>ext扩展类加载器获取它的上层，Bootstrap加载器，获取不到，结果为null</p>
<p><img src="/2020/10/13/Java/JVM/jvm%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/QQ%E6%88%AA%E5%9B%BE20200724222217.png"></p>
<h3 id="启动类加载器"><a href="#启动类加载器" class="headerlink" title="启动类加载器"></a>启动类加载器</h3><p><img src="/2020/10/13/Java/JVM/jvm%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/QQ%E6%88%AA%E5%9B%BE20200724222611.png"></p>
<h3 id="扩展类加载器"><a href="#扩展类加载器" class="headerlink" title="扩展类加载器"></a>扩展类加载器</h3><p><img src="/2020/10/13/Java/JVM/jvm%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/QQ%E6%88%AA%E5%9B%BE20200724223046.png"></p>
<h3 id="系统类加载器"><a href="#系统类加载器" class="headerlink" title="系统类加载器"></a>系统类加载器</h3><p><img src="/2020/10/13/Java/JVM/jvm%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/QQ%E6%88%AA%E5%9B%BE20200724223323.png"></p>
<p><img src="/2020/10/13/Java/JVM/jvm%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/QQ%E6%88%AA%E5%9B%BE20200724223712.png"></p>
<p><img src="/2020/10/13/Java/JVM/jvm%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/QQ%E6%88%AA%E5%9B%BE20200724223918.png"></p>
<h3 id="为什么要有用户自定义类加载器"><a href="#为什么要有用户自定义类加载器" class="headerlink" title="为什么要有用户自定义类加载器"></a>为什么要有用户自定义类加载器</h3><p><img src="/2020/10/13/Java/JVM/jvm%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/QQ%E6%88%AA%E5%9B%BE20200727210010.png"></p>
<p><img src="/2020/10/13/Java/JVM/jvm%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/QQ%E6%88%AA%E5%9B%BE20200727210239.png"></p>
<p><img src="/2020/10/13/Java/JVM/jvm%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/QQ%E6%88%AA%E5%9B%BE20200727210525.png"></p>
<h3 id="关于ClassLoader"><a href="#关于ClassLoader" class="headerlink" title="关于ClassLoader"></a>关于ClassLoader</h3><p><img src="/2020/10/13/Java/JVM/jvm%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/QQ%E6%88%AA%E5%9B%BE20200727210930.png"></p>
<h2 id="3-双亲委派机制"><a href="#3-双亲委派机制" class="headerlink" title="3.双亲委派机制"></a>3.双亲委派机制</h2><p><img src="/2020/10/13/Java/JVM/jvm%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/QQ%E6%88%AA%E5%9B%BE20200727211440.png"></p>
<p><img src="/2020/10/13/Java/JVM/jvm%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/QQ%E6%88%AA%E5%9B%BE20200727213603.png"></p>
<p>看包名，是否归某一类加载器管辖</p>
<p><img src="/2020/10/13/Java/JVM/jvm%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/QQ%E6%88%AA%E5%9B%BE20200727214557.png"></p>
<p><img src="/2020/10/13/Java/JVM/jvm%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/QQ%E6%88%AA%E5%9B%BE20200727214925.png"></p>
<h3 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h3><p><img src="/2020/10/13/Java/JVM/jvm%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/QQ%E6%88%AA%E5%9B%BE20200727214955.png"></p>
<p><img src="/2020/10/13/Java/JVM/jvm%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/QQ%E6%88%AA%E5%9B%BE20200727215358.png"></p>
<h3 id="沙箱安全机制"><a href="#沙箱安全机制" class="headerlink" title="沙箱安全机制"></a>沙箱安全机制</h3><p><img src="/2020/10/13/Java/JVM/jvm%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/QQ%E6%88%AA%E5%9B%BE20200727215527.png"></p>
<h2 id="4-其他"><a href="#4-其他" class="headerlink" title="4.其他"></a>4.其他</h2><h3 id="类的主动使用和被动使用"><a href="#类的主动使用和被动使用" class="headerlink" title="类的主动使用和被动使用"></a>类的主动使用和被动使用</h3><p><img src="/2020/10/13/Java/JVM/jvm%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/QQ%E6%88%AA%E5%9B%BE20200728205914.png"></p>
<p><img src="/2020/10/13/Java/JVM/jvm%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/QQ%E6%88%AA%E5%9B%BE20200728210104.png"></p>
<p>一个类型到另一个类型，这里在后面的动态链接的部分会有所提及，所以我们需要知道这个信息</p>
<p><img src="/2020/10/13/Java/JVM/jvm%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/QQ%E6%88%AA%E5%9B%BE20200728210242.png"></p>
<p>类的主动使用和被动使用的区别：会不会导致类的初始化，主动使用回导致类的初始化</p>
<h2 id="5-小总结（类加载子系统）"><a href="#5-小总结（类加载子系统）" class="headerlink" title="5.小总结（类加载子系统）"></a>5.小总结（类加载子系统）</h2><p><img src="/2020/10/13/Java/JVM/jvm%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/QQ%E6%88%AA%E5%9B%BE20200728210635.png"></p>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>peanutMallFollowCoderwhy工程日志</title>
    <url>/2020/09/11/Java/peanutMallFollowCoderwhy%E5%B7%A5%E7%A8%8B%E6%97%A5%E5%BF%97/</url>
    <content><![CDATA[<h1 id="项目工程概述"><a href="#项目工程概述" class="headerlink" title="项目工程概述"></a>项目工程概述</h1><p>项目github仓库地址：<a href="https://github.com/JustinPeanut/peanutMallFollowCoderwhy">peanutMallFollowCoderwhy</a></p>
<p><code>talk is cheap, show me your code</code></p>
<p>一下记录我跟随coderwhy老师开发mall商城应用中碰到的一些问题和需要注意的点。</p>
<a id="more"></a>

<h1 id="碰到的问题"><a href="#碰到的问题" class="headerlink" title="碰到的问题"></a>碰到的问题</h1><h2 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h2><p>在创建项目的时候，不能使用大写或者一些其他特殊字符</p>
<p><code>git remove add origin respostity url</code>:将远程仓库和本地仓库联系起来</p>
<p>划分目录结构：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">assets				<span class="comment">// 资源</span></span><br><span class="line"> --img</span><br><span class="line"> --css</span><br><span class="line">    --normalize.css	<span class="comment">// 对不同浏览器的标签样式统一(在github下载)</span></span><br><span class="line">    --base.css		<span class="comment">// 初始化css设置</span></span><br><span class="line">views				<span class="comment">// 视图</span></span><br><span class="line">componets			<span class="comment">// 公共组件</span></span><br><span class="line"> --common			<span class="comment">// 完全公共的组件，可以给别的项目使用</span></span><br><span class="line"> --content			<span class="comment">// 和当前组件业务相关的组件</span></span><br><span class="line">router				<span class="comment">// 路由相关</span></span><br><span class="line">store				<span class="comment">// vuex公共状态管理</span></span><br><span class="line">network				<span class="comment">// 网络相关封装</span></span><br><span class="line">common				<span class="comment">// 公共的一些常量，或者工具类</span></span><br></pre></td></tr></table></figure>

<p>在根目录下创建vue.config.js配置别名。</p>
<p>在根目录下创建代码规范文件<code>.editorConfig</code>。</p>
<h2 id="开发"><a href="#开发" class="headerlink" title="开发"></a>开发</h2><h3 id="tabBar"><a href="#tabBar" class="headerlink" title="tabBar"></a>tabBar</h3><p>如果你配置了别名，那么dom中引用url的时候，一定要加上~</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;~assets/img/tabbar/home.svg&quot;</span> <span class="attr">slot</span>=<span class="string">&quot;img-common-slot&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>要不然就获取不到相应的图片。</p>
<p>设置点击之后active的样式</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;tab-item&quot;</span> @click=<span class="string">&quot;itemClick&quot;</span>&gt;</span><br><span class="line">        &lt;slot v-<span class="keyword">if</span>=<span class="string">&quot;!isActive&quot;</span> name=<span class="string">&quot;img-common-slot&quot;</span>&gt;&lt;/slot&gt;</span><br><span class="line">        &lt;slot v-<span class="keyword">else</span> name=<span class="string">&quot;img-active-slot&quot;</span>&gt;&lt;/slot&gt;</span><br><span class="line">    &lt;div :style=<span class="string">&quot;isTextActive&quot;</span>&gt;</span><br><span class="line">        &lt;slot name=<span class="string">&quot;textSlot&quot;</span>&gt;&lt;/slot&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    name: <span class="string">&quot;TabBarItem&quot;</span>,</span><br><span class="line">    props: &#123;</span><br><span class="line">      path: &#123;</span><br><span class="line">        type: <span class="built_in">String</span></span><br><span class="line">        &#125;,</span><br><span class="line">      <span class="comment">// 父组件给子组件传值</span></span><br><span class="line">      textColor: &#123;</span><br><span class="line">        type: <span class="built_in">String</span>,</span><br><span class="line">        <span class="keyword">default</span>: <span class="string">&quot;red&quot;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">      itemClick()&#123;</span><br><span class="line">        <span class="built_in">this</span>.$router.replace(<span class="built_in">this</span>.path);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    computed: &#123;</span><br><span class="line">      isActive()&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.$route.path.indexOf(<span class="built_in">this</span>.path) != <span class="number">-1</span>;</span><br><span class="line">      &#125;,</span><br><span class="line">      isTextActive()&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.isActive ? &#123;<span class="attr">color</span>: <span class="built_in">this</span>.textColor&#125;: &#123;&#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line">  .tab-item&#123;</span><br><span class="line">    height: <span class="number">49</span>px;</span><br><span class="line">    text-align: center;</span><br><span class="line">    flex: <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  .tab-item img&#123;</span><br><span class="line">    width: <span class="number">24</span>px;</span><br><span class="line">    height: <span class="number">24</span>px;</span><br><span class="line">    vertical-align: middle;</span><br><span class="line">    margin: <span class="number">4</span>px <span class="number">0</span> <span class="number">2</span>px <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  .active&#123;</span><br><span class="line">    color: red</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="navBar"><a href="#navBar" class="headerlink" title="navBar"></a>navBar</h3><p>注意：插槽如果有多个，要使用具名插槽，在使用的时候也要指定替换哪一个插槽，效果图如下</p>
<p><img src="/2020/09/11/Java/peanutMallFollowCoderwhy%E5%B7%A5%E7%A8%8B%E6%97%A5%E5%BF%97/QQ%E6%88%AA%E5%9B%BE20200911105742.png"></p>
<h3 id="封装网络请求"><a href="#封装网络请求" class="headerlink" title="封装网络请求"></a>封装网络请求</h3><p>我们知道axios是第三方框架，如果有那一天这个第三方框架不更新的话，我们如果在项目中多处使用了axios，代码的重构就会带来很多不必要的麻烦。</p>
<p>①下载axios插件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install axios</span><br></pre></td></tr></table></figure>

<p>②使用的时候不需要Vue.use命令install</p>
<p>直接导入axios即可使用，详情课参照官方文档            <a href="http://www.axios-js.com/zh-cn/docs/">axios官方文档</a></p>
<p>github xowen</p>
<p>出现的问题：在传回axios实例之后，发现调用then方法失败，原因是：应当返回axiosInstance(config)配置过后的axiosInstance</p>
<p>错误代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Axios <span class="keyword">from</span> <span class="string">&quot;axios&quot;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">request</span>(<span class="params">config</span>)</span>&#123;</span><br><span class="line">  <span class="comment">// 创建axios实例，设置baseConfig</span></span><br><span class="line">  <span class="keyword">const</span> axiosInstance = Axios.create(&#123;</span><br><span class="line">    baseURL: <span class="string">&quot;http://123.207.32.32:8000&quot;</span>,</span><br><span class="line">    timeout: <span class="number">5000</span></span><br><span class="line">  &#125;);</span><br><span class="line">  axiosInstance(config);</span><br><span class="line">  <span class="keyword">return</span> axiosInstance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    原因是因为axios实例配置过后的实例返回的是一个promise，所以可以调用then方法</p>
<p>正确代码:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Axios <span class="keyword">from</span> <span class="string">&quot;axios&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">request</span>(<span class="params">config</span>)</span>&#123;</span><br><span class="line">  <span class="comment">// 创建axios实例，设置baseConfig</span></span><br><span class="line">  <span class="keyword">const</span> axiosInstance = Axios.create(&#123;</span><br><span class="line">    baseURL: <span class="string">&quot;http://123.207.32.32:8000&quot;</span>,</span><br><span class="line">    timeout: <span class="number">5000</span></span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="comment">// 拦截器</span></span><br><span class="line">  axiosInstance.interceptors.request.use(<span class="function"><span class="params">config</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(config);</span><br><span class="line">    <span class="keyword">return</span> config;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> axiosInstance(config);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="封装轮播图"><a href="#封装轮播图" class="headerlink" title="封装轮播图"></a>封装轮播图</h3><p>注意：在每次滚动之后，都要验证位置，如果位置超过了图片的长度</p>
<h3 id="开发FeatureView"><a href="#开发FeatureView" class="headerlink" title="开发FeatureView"></a>开发FeatureView</h3><p>点击FeatureView图片之后跳转的超链接</p>
<p><a href="https://act.mogujie.com/zzlx67">https://act.mogujie.com/zzlx67</a></p>
<h3 id="TabControl"><a href="#TabControl" class="headerlink" title="TabControl"></a>TabControl</h3><p><img src="/2020/09/11/Java/peanutMallFollowCoderwhy%E5%B7%A5%E7%A8%8B%E6%97%A5%E5%BF%97/QQ%E6%88%AA%E5%9B%BE20200921105012.png"></p>
<p>如果只是文字不一样的话，就没有必要用插槽</p>
<p>取而代之：</p>
<p><img src="/2020/09/11/Java/peanutMallFollowCoderwhy%E5%B7%A5%E7%A8%8B%E6%97%A5%E5%BF%97/QQ%E6%88%AA%E5%9B%BE20200921105558.png"></p>
<p>当需要设置点击active的样式，使用currentIndex标记当前所处于的标签，使用循环中的index和currentIndex判断是不是相等，如果相等，就是处于活跃的标签</p>
<p>其中定义的变量</p>
<p><code>--color-high-text</code>:文字高亮颜色</p>
<p><code>--color-tint</code>:下划线高亮</p>
<p>如果希望滚动的时候，停留在页面的顶端，可以设置css</p>
<p>在没有达到top：xxpx之前，position的属性默认是一个static，当达到xxpx时，浏览器会自动将posiotion的属性改成fixed</p>
<p>（如果需要适配ie浏览器，这个属性就不能随便用了）</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attribute">position</span>: sticky;</span><br><span class="line">    <span class="attribute">top</span>: xxpx; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="商品列表页"><a href="#商品列表页" class="headerlink" title="商品列表页"></a>商品列表页</h3><p><img src="/2020/09/11/Java/peanutMallFollowCoderwhy%E5%B7%A5%E7%A8%8B%E6%97%A5%E5%BF%97/QQ%E6%88%AA%E5%9B%BE20200921112812.png"></p>
<p>create函数中些主要逻辑，主要是实现的方法在methods中执行</p>
<p><img src="/2020/09/11/Java/peanutMallFollowCoderwhy%E5%B7%A5%E7%A8%8B%E6%97%A5%E5%BF%97/QQ%E6%88%AA%E5%9B%BE20200922150027.png"></p>
<p>push方法可以传入可变参数，如果希望把一个数组push到另一个数组中，可以使用数组1.push(…数组2)</p>
<p>关于样式调整：</p>
<p><code>flex-wrap：wrap</code>根据子元素的宽度适配每一行占多少个子元素。</p>
<p><code>justify-content:space-around</code>：子元素占据每一行并均等分，但是中间的宽度是左右宽度的2倍</p>
<p><img src="/2020/09/11/Java/peanutMallFollowCoderwhy%E5%B7%A5%E7%A8%8B%E6%97%A5%E5%BF%97/QQ%E6%88%AA%E5%9B%BE20200922154540.png"></p>
<h3 id="切换点击的类型对应现实的商品"><a href="#切换点击的类型对应现实的商品" class="headerlink" title="切换点击的类型对应现实的商品"></a>切换点击的类型对应现实的商品</h3><p>注意的问题是，子组件向父组件传递参数的方法：</p>
<p>子组件：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">setActive(index)&#123;</span><br><span class="line">        <span class="built_in">this</span>.currentIndex = index;</span><br><span class="line">        <span class="comment">// 传回父组件，监听当前index的点击，对应修改展示的商品信息</span></span><br><span class="line">        <span class="built_in">this</span>.$emit(<span class="string">&#x27;tabClick&#x27;</span>,index);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>父组件(其中，父组件用来接收子组件传递的方法的那个方法中不需要携带index形参)：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;tab-control <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;tab-control&quot;</span> :titles=<span class="string">&quot;[&#x27;流行&#x27;,&#x27;新款&#x27;,&#x27;精选&#x27;]&quot;</span> @tabClick=<span class="string">&quot;tabClick&quot;</span>/&gt;</span><br></pre></td></tr></table></figure>

<h3 id="better-scoll的安装和使用"><a href="#better-scoll的安装和使用" class="headerlink" title="better-scoll的安装和使用"></a>better-scoll的安装和使用</h3><p>使用原生的滚动（内容多余整个屏幕的时候），在移动端滚动的时候会非常的卡顿，以前为了适配移动端滚动的问题，使用了<code>iscoll</code>框架，但是现在他没有更新了，所以我们使用国内开发的一个<code>better-scoll</code></p>
<p>安装</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">npm install better-scroll --save</span><br></pre></td></tr></table></figure>

<p>如果想实现原生的局部js滚动，可以使用如下方式，但是前提是必须给父标签一个固定的高度才行。</p>
<p><img src="/2020/09/11/Java/peanutMallFollowCoderwhy%E5%B7%A5%E7%A8%8B%E6%97%A5%E5%BF%97/QQ%E6%88%AA%E5%9B%BE20200928104118.png"></p>
<p>第三方的框架， 要注意封装，万一他不更新，就凉凉了，下次如果项目中有很多地方使用到了这个框架，改起来很要命的</p>
<p>使用</p>
<p><img src="/2020/09/11/Java/peanutMallFollowCoderwhy%E5%B7%A5%E7%A8%8B%E6%97%A5%E5%BF%97/QQ%E6%88%AA%E5%9B%BE20200928104759.png"></p>
<p>上述使用是错误的，因为这个方法会在创建组建的时候被调用，这时候还没有挂载template，所以一直拿不到content。</p>
<p>在使用的时候，根据官方文档的说明，必须在管理的标签外面加一层<code>wrapper</code>,并且管理的内容必须是一个标签</p>
<p>如果向监听用户滚动到哪一个位置了：并对当前状态添加一些业务功能</p>
<p>但是默认情况下，Bscroll是不能实时监听滚动的位置的，如果想要实时监听滚动的化，必须给他传参数</p>
<p>参数：</p>
<p>①probeType：是否侦测。0，1都是不侦测；2表示在手指滚动的过程中侦测，手指离开后的惯性滚动过程不侦测；3表示只要是滚动都侦测。（配合<code>scroll</code>事件使用）</p>
<p>②click：默认值位false，在<code>wrapper</code>中管理的<code>content</code>如果有监听click事件，默认是不会生效的，如果将click属性改为true，才会传派事件。</p>
<p>③pullUpload：上拉加载更多(配合<code>pullingUp</code>使用)，但是当前页面只能调用一次上拉加载的回调函数，需要在最后调用一个<code>finishPullUp</code>方法，结束当前上拉加载，才能监听下一次上拉加载。</p>
<p><img src="/2020/09/11/Java/peanutMallFollowCoderwhy%E5%B7%A5%E7%A8%8B%E6%97%A5%E5%BF%97/QQ%E6%88%AA%E5%9B%BE20200928152425.png"></p>
<p>封装better-scroll：封装一个vue文件，这个vue文件对better-scroll有依赖，其他的vue文件只要引用这个vue文件就可以了。</p>
<p>使用document.query获取<code>wrapper</code>的方式不是特别好，如果在其他组件中也有class为<code>wrapper</code>的标签，那么获取的时候就会有一些问题（query获取的是同一个页面上的第一个查询到的元素），在vue开发的时候经常出现类似的这种问题，值得注意，推荐的方法：</p>
<blockquote>
<p>在vue中给标签绑定一个ref属性</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">ref</span>=<span class="string">&quot;aaa&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>之后再下面就可以通过this.$refs.aaa拿到上述标记的标签，但是在前面所讲的ref是在父组件中给子组件标记，然后拿到相应的子组件的方法。这里标记普通的标签也是可行的。</p>
</blockquote>
<p>在给组件中的元素添加样式的时候，如果style标签中没有加上scoped属性，那么这个style中设置的样式就是全局的，例如</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">scoped</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>为某个div设置高度</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    其中vh是 视口的高度100vh == 100 %</span><br><span class="line">    <span class="selector-tag">height</span>: 100<span class="selector-tag">vh</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2020/09/11/Java/peanutMallFollowCoderwhy%E5%B7%A5%E7%A8%8B%E6%97%A5%E5%BF%97/QQ%E6%88%AA%E5%9B%BE20200929173815.png"></p>
<p>可以动态计算高度，也可以使用定位</p>
<p><img src="/2020/09/11/Java/peanutMallFollowCoderwhy%E5%B7%A5%E7%A8%8B%E6%97%A5%E5%BF%97/QQ%E6%88%AA%E5%9B%BE20200929173937.png"></p>
<h4 id="出现的问题"><a href="#出现的问题" class="headerlink" title="出现的问题"></a>出现的问题</h4><p>然而在我加入better-scroll之后，页面上的元素都动不了了，就好像里面没有东西一样，这就很奇怪了，我封装的scroll应该没有问题（因为我在分类中测试了），问题应该处在home页的css上面，但是并不知道哪里的问题。</p>
<p>上百度看了，滚动不了的问题无非是<code>wrapper</code>的高度要比<code>content</code>的低，<code>content</code>下只能有一个子标签，这些问题我都注意了，但是还是不管用，无能为力。</p>
<p>但是反复测试，在pc端换设备测试的时候发现，换来换去怎么又好使了？这也太玄学了吧。看来better-scroll插件还不是很稳定。</p>
<p>想到可能是版本太高？所以就换了个低版本，1.15.2（和coderwhy一样的版本测试），果然，换了版本之后就好用了。</p>
<h3 id="backtop"><a href="#backtop" class="headerlink" title="backtop"></a>backtop</h3><p>如果想要监听组件的点击，需要添加修饰符<code>native</code></p>
<p>给子组件添加ref属性，可以直接访问子组件中的内容。</p>
<p><img src="/2020/09/11/Java/peanutMallFollowCoderwhy%E5%B7%A5%E7%A8%8B%E6%97%A5%E5%BF%97/QQ%E6%88%AA%E5%9B%BE20201006155249.png"></p>
<h3 id="上拉加载更多"><a href="#上拉加载更多" class="headerlink" title="上拉加载更多"></a>上拉加载更多</h3><p>在完成上拉加载更多之前，还需要解决滚动的bug，在滚动的时候，因为图片是动态加载的，所以vue的template会先计算出一个高度，这时候因为图片还没有加载，所以高度没有加载了图片的时候那么高，所以当图片加载完成之后，可滚动的区域就比之前的更小，所以滚动到某个区域发现会滚动不了了，所以这里先解决一些这个问题（有时候能滚动到底部，有时候不能，用户不友好，这是因为图片加载的是异步的）</p>
<blockquote>
<p>better-scroll对象中有一个属性记录了可滚动的高度有多高，这个计算出来的高度就放在这个属性中</p>
<p><img src="/2020/09/11/Java/peanutMallFollowCoderwhy%E5%B7%A5%E7%A8%8B%E6%97%A5%E5%BF%97/QQ%E6%88%AA%E5%9B%BE20201009102007.png"></p>
</blockquote>
<p>解决：当加载完所有的图片之后，最后在调用scroll对象的refresh方法，但是问题就在于，我怎么知道什么时候加载完了图片？</p>
<blockquote>
<p>监听每一张图片是否加载完成。只要有一张图片加载完了，就更新scroll（refresh方法）</p>
<p>原生的监听图片时候加载完成使用的是</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">img.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>但是vue已经帮我们封装了，只要给出一个imageLoad方法并实现就可以了</p>
<p><img src="/2020/09/11/Java/peanutMallFollowCoderwhy%E5%B7%A5%E7%A8%8B%E6%97%A5%E5%BF%97/QQ%E6%88%AA%E5%9B%BE20201009103256.png"></p>
<p>注意的是：我们这个img标签是在goodItem中的，这里我们不能直接拿到scroll对象：</p>
<p>①可以添加一个Vuex对象，在goodListItem中监听某个状态，如果这个状态改变，就在主页中执行refresh方法</p>
<p>②事件总线：和Vuex很像，但是他不是管理状态的，而是管理事件的：通过this.$bus.$emit(“funName”)发送一个事件给事件总线，然后再别的组件中通过this.$bus.$on(“funName”,function(){})监听别的组件中是否发射了一个叫funName的事件，但是默认情况下，程序中是没有$bus的，这个需要自己添加进来，使用vue原型添加进来</p>
<p><img src="/2020/09/11/Java/peanutMallFollowCoderwhy%E5%B7%A5%E7%A8%8B%E6%97%A5%E5%BF%97/QQ%E6%88%AA%E5%9B%BE20201009104628.png"></p>
<p>这样的话，就可以通过这个Vue实例发射事件</p>
</blockquote>
<p>注意：</p>
<p>做完一次上拉加载更多，加载数据之后，不要忘了调用scroll对象中的finishPullUp方法。</p>
<p>有时候会出现报错的情况，调用refresh的方法的时候出错，原因可能是请求图片数据的方法在home.vue中的created中执行的，这时候可能请求太快了，但是goodListItem中的scroll没有创建出来，可能goodListItem中的组件还没有挂载，解决方法：在使用scroll之前，先判断scroll是不是为null，如果不为null才执行后面的代码</p>
<p><img src="/2020/09/11/Java/peanutMallFollowCoderwhy%E5%B7%A5%E7%A8%8B%E6%97%A5%E5%BF%97/QQ%E6%88%AA%E5%9B%BE20201009162951.png"></p>
<p>当然,改了之后还是有问题,之后又把this.$bus.$on方法放在了mounted中监听,但是发现,在分类和首页快速切换的时候还是会有问题.解决</p>
<blockquote>
<p>每次在首页使用scroll的时候,在前面加上this.$refs.scroll的判断</p>
</blockquote>
<h4 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h4><p>因为图片加载几乎是同时的，所以scroll.refresh方法执行的频率特别高,一秒钟之内如果你多次调用的话,执行一次就可以了.</p>
<p>防抖动(debounce):比如输入框,根据你每次输入的文字展示相应的内容,如果每次输入一个单词就向服务器发送一次请求,对服务器的压力就太大了,比如在输入一个字符之后,等待500ms,如果有下一次输入,那么就取消上一次的请求,将下一次输入和上一次输入加在一起……依次类推.这里就可以使用防抖动。</p>
<p><img src="/2020/09/11/Java/peanutMallFollowCoderwhy%E5%B7%A5%E7%A8%8B%E6%97%A5%E5%BF%97/QQ%E6%88%AA%E5%9B%BE20201009170229.png"></p>
<p>当不传入delay参数的时候，函数也没有执行三十次，这是为什么？</p>
<blockquote>
<p>setTimeout函数在下一次事件循环的时候才执行，所以setTimeout中的函数永远是放在后面执行的</p>
<p><img src="/2020/09/11/Java/peanutMallFollowCoderwhy%E5%B7%A5%E7%A8%8B%E6%97%A5%E5%BF%97/QQ%E6%88%AA%E5%9B%BE20201010080834.png"></p>
</blockquote>
<p><img src="/2020/09/11/Java/peanutMallFollowCoderwhy%E5%B7%A5%E7%A8%8B%E6%97%A5%E5%BF%97/QQ%E6%88%AA%E5%9B%BE20201010081216.png"></p>
<p>并且，防抖动的功能性函数，不要写在某一个组件里面，单独放在某个位置</p>
<p>增加防抖动之后，发现在内部调用apply方法的时候，浏览器报错apply未定义？</p>
<h3 id="tabControl"><a href="#tabControl" class="headerlink" title="tabControl"></a>tabControl</h3><p>加入better-scroll之后，原来tabControl的吸顶效果就不起作用了</p>
<p>首先获取tabControl的offsetTop，之后根据这个offsetTop来实现滚动到什么位置之后，开始吸顶（改变样式为fixed）</p>
<blockquote>
<p>但是组件本身没有offsetTop属性，所以需要拿到template里面的标签才能获取 ，所有的组件都有一个$el属性，用来获取组件中的元素</p>
<p>通过这样的方式，发现它的高度远远小于我们想要的offsetTop，原因是图片还没有加载，获取的这个高度，是图片还没有撑起来的高度，所以就非常的矮，所以需要等图片全部加载完之后，在计算出来一个最终的offsetTop才是正确的。</p>
</blockquote>
<p>在better-scroll中设置tabControl的样式是行不通的，所以使用了第二种方法：</p>
<blockquote>
<p>增加一个一摸一样的better-scroll在顶部，实时监听滚动，如果滚动到了某个位置，就将顶部的tabControl显示，并且要注意的是，两个tabControl是独立的，所以在监听tabControl点击的时候，还要同步他们的currentIndex</p>
</blockquote>
<h3 id="路由状态保持"><a href="#路由状态保持" class="headerlink" title="路由状态保持"></a>路由状态保持</h3><p>在跳转到其他页面的时候，首页的组件会销毁，这时候我们不希望他销毁。</p>
<p>在路由的<router-view>上面设置<keep-alive></keep-alive>标签</router-view></p>
<h2 id="详情页开发"><a href="#详情页开发" class="headerlink" title="详情页开发"></a>详情页开发</h2><h3 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h3><p>标题因为已经封装了组件，所以直接使用就可以，点击标签为active，使用currentIndex</p>
<h3 id="轮播图"><a href="#轮播图" class="headerlink" title="轮播图"></a>轮播图</h3><p>因为轮播图中使用了query方法，所以组件外部的class不能和swiper里面的相同</p>
<p>在跳转的时候，关于keep-alive的问题，需要排除Detail页面，需要注意的是，exculde和include两个属性都是vue2.1+添加进来的属性，所以需要保证vue的版本符合要求。并且在exculde中设置的值要和各个组件中的name保持一致，要不然会找不到组件</p>
<h3 id="商品信息"><a href="#商品信息" class="headerlink" title="商品信息"></a>商品信息</h3><p>v-for() ：可以遍历数字n，从1遍历到10</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-for</span>=<span class="string">&quot;n in 10&quot;</span>&gt;</span></span><br><span class="line">    &#123;&#123;n&#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>如何判断对象是空的？</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.keys(obj).length === <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>​    如果两个组件中有相同代码，想做抽取的话，需要用到mixin</p>
<p><strong>因为接口问题，所以这里只以商品的详情和参数为例</strong></p>
<h3 id="标题和内容的联动"><a href="#标题和内容的联动" class="headerlink" title="标题和内容的联动"></a>标题和内容的联动</h3><p>父组件给子组件传值的时候，不是值到了，就渲染，而是会等一下执行一个update生命周期函数，如果想在数组到了之后就拿到组件中的offsetTop是不可能的，可以使用</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">this</span>.$nextTick(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>this.$nextTick传进去的回调函数会在子组件被渲染完成之后被回调</p>
<p>但是在这个回调函数回调的时候，当前的DOM中是不包含图片的，所以就会出现高度不正确的问题（一般offsetTop值不对的时候，都是因为图片没有加载完）</p>
<p>可以在图片一加载就设置最新的值，但是调用的太频繁了，所以使用防抖</p>
<p>最终解决：</p>
<p><img src="/2020/09/11/Java/peanutMallFollowCoderwhy%E5%B7%A5%E7%A8%8B%E6%97%A5%E5%BF%97/QQ%E6%88%AA%E5%9B%BE20201015074846.png"></p>
<p>但是这里的话，我只有商品的参数信息和goods信息，对于上述所说的防抖函数都用不上，因为图片在goods的下面加载，然而我又没有添加goods的titleNavtext</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">this</span>.$nextTick(<span class="function">() =&gt;</span>&#123;</span><br><span class="line">          <span class="built_in">this</span>.detailOffsetY.push(<span class="built_in">this</span>.$refs.detailParam.$el.offsetTop - <span class="number">44</span>)</span><br><span class="line">          <span class="comment">// 插入一个最大值，使之能够在区间内判断</span></span><br><span class="line">          <span class="built_in">this</span>.detailOffsetY.push(<span class="built_in">Number</span>.MAX_VALUE)</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;)</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 根据滚动改变标题的active</span></span><br><span class="line">    detalScroll(position)&#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span> ; i &lt; <span class="built_in">this</span>.detailOffsetY.length <span class="number">-1</span> ; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">this</span>.currentIndex != i &amp;&amp; -position.y &gt;= <span class="built_in">this</span>.detailOffsetY[i] &amp;&amp; -position.y &lt; <span class="built_in">this</span>.detailOffsetY[i+<span class="number">1</span>])&#123;</span><br><span class="line">          <span class="built_in">this</span>.currentIndex = i</span><br><span class="line">          <span class="built_in">this</span>.$refs.nav.currentIndex = <span class="built_in">this</span>.currentIndex</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="底部工具栏"><a href="#底部工具栏" class="headerlink" title="底部工具栏"></a>底部工具栏</h3><p>​    封装组件</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div id=<span class="string">&quot;detail_bottom_bar&quot;</span>&gt;</span><br><span class="line">    &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;bottom_left&quot;</span>&gt;</span><br><span class="line">      &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;service&quot;</span>&gt;</span><br><span class="line">        &lt;i <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;icon&quot;</span>&gt;&lt;/i&gt;</span><br><span class="line">        &lt;span&gt;客服&lt;/span&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">      &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;shop&quot;</span>&gt;</span><br><span class="line">        &lt;i <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;icon&quot;</span>&gt;&lt;/i&gt;</span><br><span class="line">        &lt;span&gt;店铺&lt;/span&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">      &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;collect&quot;</span>&gt;</span><br><span class="line">        &lt;i <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;icon&quot;</span>&gt;&lt;/i&gt;</span><br><span class="line">        &lt;span&gt;收藏&lt;/span&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;bottom_right&quot;</span>&gt;</span><br><span class="line">      &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;cart&quot;</span> @click=<span class="string">&quot;addToCart&quot;</span>&gt;</span><br><span class="line">        加入购物车</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">      &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;buy&quot;</span>&gt;</span><br><span class="line">        购买</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    methods: &#123;</span><br><span class="line">      addToCart() &#123;</span><br><span class="line">        <span class="built_in">this</span>.$emit(<span class="string">&quot;addEvent&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line">  #detail_bottom_bar &#123;</span><br><span class="line">    font-size: <span class="number">0.65</span>rem;</span><br><span class="line">    display: flex;</span><br><span class="line">    position: fixed;</span><br><span class="line">    background-color: #fff;</span><br><span class="line">    bottom: <span class="number">0</span>px;</span><br><span class="line">    left: <span class="number">0</span>;</span><br><span class="line">    right: <span class="number">0</span>;</span><br><span class="line">    height: <span class="number">2.09</span>rem;</span><br><span class="line">    text-align: center;</span><br><span class="line">    box-shadow: <span class="number">0</span> <span class="number">-0.04</span>rem <span class="number">0.4</span>rem gray;</span><br><span class="line">  &#125;</span><br><span class="line">  .bottom_left &#123;</span><br><span class="line">    display: flex;</span><br><span class="line">    flex: <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  .bottom_left &gt; div &#123;</span><br><span class="line">    flex: <span class="number">1</span>;</span><br><span class="line">    border-right: <span class="number">0.04</span>rem solid rgba(<span class="number">128</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">0.2</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  .bottom_left .icon &#123;</span><br><span class="line">    display: block;</span><br><span class="line">    background: url(<span class="string">&quot;~assets/img/detail/detail_bottom.png&quot;</span>) <span class="number">0</span> <span class="number">0</span>/<span class="number">100</span>%;</span><br><span class="line">    width: <span class="number">1</span>rem;</span><br><span class="line">    height: <span class="number">1</span>rem;</span><br><span class="line">    margin: <span class="number">0.12</span>rem auto;</span><br><span class="line">  &#125;</span><br><span class="line">  .service .icon &#123;</span><br><span class="line">    background-position: <span class="number">0</span> <span class="number">-2.4</span>rem;</span><br><span class="line">  &#125;</span><br><span class="line">  .shop .icon &#123;</span><br><span class="line">    background-position: <span class="number">0</span> <span class="number">-4.5</span>rem;</span><br><span class="line">  &#125;</span><br><span class="line">  .bottom_right &#123;</span><br><span class="line">    display: flex;</span><br><span class="line">    flex: <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  .bottom_right &gt; div &#123;</span><br><span class="line">    flex: <span class="number">1</span>;</span><br><span class="line">    line-height: <span class="number">2.09</span>rem;</span><br><span class="line">  &#125;</span><br><span class="line">  .cart &#123;</span><br><span class="line">    background-color: rgb(<span class="number">255</span>, <span class="number">174</span>, <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  .buy &#123;</span><br><span class="line">    background-color: <span class="keyword">var</span>(--color-tint);</span><br><span class="line">    color: white;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="backTop混入封装"><a href="#backTop混入封装" class="headerlink" title="backTop混入封装"></a>backTop混入封装</h3><p>​    使用mixins，直接默认导出文件，到时候在某个组件中使用就可以了</p>
<h2 id="购物车"><a href="#购物车" class="headerlink" title="购物车"></a>购物车</h2><p>这里使用到了vuex插件，如果点击的是同一个商品，这时候不希望添加多次，只需要增加这个商品在cartList中的数量即可</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  state: &#123;</span><br><span class="line">    cartList: []</span><br><span class="line">  &#125;,</span><br><span class="line">  mutations: &#123;</span><br><span class="line">    addCart(state,payload)&#123;</span><br><span class="line">      <span class="keyword">let</span> product = state.cartList.find(<span class="function"><span class="params">item</span> =&gt;</span> item.iid === payload.iid);</span><br><span class="line">      <span class="keyword">if</span>(product)&#123;</span><br><span class="line">        product.count++;</span><br><span class="line">      &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        payload.count = <span class="number">1</span>;</span><br><span class="line">        state.cartList.push(payload)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>mutations的作用就是为了修改state状态，尽可能实现的功能单一一点，上面的解决方案没有达到单一的实现原则，上述又判断逻辑的东西，最好放在actions中完成（不止是异步操作可以放在action中）</p>
<p>注意：在封装mutations中的常量出去的时候，不能使用对象的形式，应该使用下面的形式</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> ADD_COUNTER = <span class="string">&#x27;add_counter&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> ADD_TO_PUSH = <span class="string">&#x27;add_to_push&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="导航栏"><a href="#导航栏" class="headerlink" title="导航栏"></a>导航栏</h3><p>mapGetters的使用：</p>
<p><img src="/2020/09/11/Java/peanutMallFollowCoderwhy%E5%B7%A5%E7%A8%8B%E6%97%A5%E5%BF%97/QQ%E6%88%AA%E5%9B%BE20201019145959.png"></p>
<p>购物车页面滚动的问题，在添加完新的商品信息之后，回到商品信息页面应该对scroll刷新一遍，要不然scroll计算出来的高度仍然是添加之前的高度</p>
<h3 id="修改item的状态"><a href="#修改item的状态" class="headerlink" title="修改item的状态"></a>修改item的状态</h3><p>item的checked属性应该默认是放在对象模型中实现的，一旦用户点击按钮，取消选中状态（默认是选中的）</p>
<p><img src="/2020/09/11/Java/peanutMallFollowCoderwhy%E5%B7%A5%E7%A8%8B%E6%97%A5%E5%BF%97/QQ%E6%88%AA%E5%9B%BE20201019164640.png"></p>
<p><img src="/2020/09/11/Java/peanutMallFollowCoderwhy%E5%B7%A5%E7%A8%8B%E6%97%A5%E5%BF%97/QQ%E6%88%AA%E5%9B%BE20201019164755.png"></p>
<h3 id="toast的封装"><a href="#toast的封装" class="headerlink" title="toast的封装"></a>toast的封装</h3><p>将封装的toast组件封装到一个插件中，然后通过安装插件的方式来使用toast</p>
<p><img src="/2020/09/11/Java/peanutMallFollowCoderwhy%E5%B7%A5%E7%A8%8B%E6%97%A5%E5%BF%97/peanutMallFollowCoderwhy%E5%B7%A5%E7%A8%8B%E6%97%A5%E5%BF%97%5CQQ%E6%88%AA%E5%9B%BE20201020194242.png"></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Toast <span class="keyword">from</span> <span class="string">&quot;./Toast&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = &#123;&#125;</span><br><span class="line"></span><br><span class="line">obj.install = <span class="function"><span class="keyword">function</span> (<span class="params">Vue</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(Vue)</span><br><span class="line"><span class="comment">//1.创建组件构造器</span></span><br><span class="line">  <span class="keyword">const</span> con = Vue.extend(Toast)</span><br><span class="line">  <span class="keyword">const</span> toast = <span class="keyword">new</span> con()</span><br><span class="line">  toast.$mount(<span class="built_in">document</span>.createElement(<span class="string">&#x27;div&#x27;</span>))</span><br><span class="line">  <span class="built_in">document</span>.body.appendChild(toast.$el)</span><br><span class="line">  Vue.prototype.$toast = Toast</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> obj</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="补充细节"><a href="#补充细节" class="headerlink" title="补充细节"></a>补充细节</h2><h3 id="300ms延迟"><a href="#300ms延迟" class="headerlink" title="300ms延迟"></a>300ms延迟</h3><p>移动端点击事件的300ms延迟，使用fastClick插件减少延迟</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">   <span class="comment">// 安装</span></span><br><span class="line">    npm install fastclick -S</span><br><span class="line">    <span class="comment">// 引入</span></span><br><span class="line">    <span class="keyword">import</span> FastClick <span class="keyword">from</span> <span class="string">&#x27;fastclick&#x27;</span></span><br><span class="line">    <span class="comment">// 使用</span></span><br><span class="line">    FastClick.attach(<span class="built_in">document</span>.body);</span><br><span class="line"></span><br><span class="line">作者：有田春雪</span><br><span class="line">链接：https:<span class="comment">//www.jianshu.com/p/67bae6dfca90</span></span><br><span class="line">来源：简书</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>

<h3 id="图片懒加载"><a href="#图片懒加载" class="headerlink" title="图片懒加载"></a>图片懒加载</h3><p>github地址: <a href="https://github.com/hilongjw/vue-lazyload">vue-lazyload </a></p>
<h3 id="px2vw-css单位转换插件"><a href="#px2vw-css单位转换插件" class="headerlink" title="px2vw-css单位转换插件"></a>px2vw-css单位转换插件</h3><p>为了适配某些设备，需要做到固定的效果，这时候就可以使用别的单位，但是项目中往往会有很多地方需要调整单位，这时候就可以使用插件</p>
<p>安装插件：postcss-px-to-viewport，并且在vue.config中并不需要做额外的配置（其中px2rem也有相关的插件）</p>
<p>一般项目的设计稿都是基于iPhone6(750*1334)，并且一个retina 1个点，相当于两个像素，适配的话，就是相对于iPhone6做适配</p>
<p><img src="/2020/09/11/Java/peanutMallFollowCoderwhy%E5%B7%A5%E7%A8%8B%E6%97%A5%E5%BF%97/QQ%E6%88%AA%E5%9B%BE20201021093402.png"></p>
]]></content>
      <categories>
        <category>项目</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>ETH九---智能合约</title>
    <url>/2020/11/17/%E5%8C%BA%E5%9D%97%E9%93%BE/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/</url>
    <content><![CDATA[<h1 id="智能合约"><a href="#智能合约" class="headerlink" title="智能合约"></a>智能合约</h1><p>​    智能合约是比特币和以太坊的一个重要的区别，智能合约的本质是运行在区块链上的一个代码，代码的逻辑定义智能合约的内容，智能合约的账户里保存了合约当前的运行状态。</p>
<a id="more"></a>

<p><img src="/2020/11/17/%E5%8C%BA%E5%9D%97%E9%93%BE/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/QQ%E6%88%AA%E5%9B%BE20201117190920.png"></p>
<blockquote>
<p>​    上图是智能合约的代码结构，第一行首先声明所使用的solidity的版本号，不同版本的solidity语言在语法上有一些小的差别，contract类似于java中的类，address类型是solidity语言钟所特有的地址类型的变量。</p>
<p>接下来来个事件，是用来记录日志的，代码的例子是网上拍卖的例子，如果出现某个出现了一个新的最高价，我们就记录一下这个参数。接下来的事件叫Pay2Beneficiary，参数是赢得拍卖的这个人的地址，以及他最后的出价，solidity语言和其他的语言有很多特别之处，比如这个’mapping（address =&gt; uint） bids’，这是一个哈希表，保存了从地址到uint的一个映射，solidity语言中的哈希表中的一个奇怪的地方是，它不支持遍历，这里使用bidders数组来记录哈希表中的数据，以便于遍历。</p>
<p>然后就是三个成员函数，都是public的，说明其他账户都可以调用这些函数，bid函数上的标识payable后面会解释。</p>
</blockquote>
<p>​    外部账户如何调用智能合约？</p>
<blockquote>
<p>如果A-&gt;B，B如果是普通账户，那就和比特币中的转账没有什么区别，如果B是一个合约账户，那么这个转账实际上就发起了对B合约的调用，具体调用的是合约中的哪个函数，是在data域中决定的。</p>
<p><img src="/2020/11/17/%E5%8C%BA%E5%9D%97%E9%93%BE/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/QQ%E6%88%AA%E5%9B%BE20201117192445.png"></p>
<p>sender address是发起调用的账户的地址，to contract address是被调用的合约的地址，调用的函数就是tx data（左下角），如果这个函数是由参数的话，参数的取值，也是在这个data域中说明的。</p>
<p>中间一行是调用合约的参数：</p>
<p>value：发起调用时，转过去多少钱，这里是0（这个调用的目的仅仅是为了调用这个函数，不是真的要转账），gas used是这个交易花了多少汽油费，gas price是单位汽油的价格，gas limit是这个交易我最多愿意支付的汽油。</p>
</blockquote>
<p>​    一个合约如果调用另外一个合约函数？</p>
<p>①</p>
<p><img src="/2020/11/17/%E5%8C%BA%E5%9D%97%E9%93%BE/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/QQ%E6%88%AA%E5%9B%BE20201117192944.png"></p>
<p>LogCallFoo方法只是写log；</p>
<p>callAFooDirectly这个函数，是传给他一个A的地址，在其中创建A的实例，并调用foo方法。</p>
<p>以太坊中规定，一个交易只有外部交易才能够发起，合约账户不能自己主动发起一个交易，所以这个例子当中需要有一个外部账户，调用合约B中的函数，这个函数在调用A当中的foo函数。</p>
<p>②</p>
<p><img src="/2020/11/17/%E5%8C%BA%E5%9D%97%E9%93%BE/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/QQ%E6%88%AA%E5%9B%BE20201117193254.png"></p>
<p>这个调用和上一个调用相比的区别是：错误处理的不同，上种方法，如果你调用的哪个合约在执行过程中出现错误，会导致发起调用的这个合约，也跟着一起回滚（A抛出异常，B也会跟着出错），而这种方法，在调用过程中，被调用的合约抛出异常，call函数会返回false，表明调用失败，但是发起调用的函数，并不会抛出异常，可以继续执行。</p>
<p>③</p>
<p><img src="/2020/11/17/%E5%8C%BA%E5%9D%97%E9%93%BE/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/QQ%E6%88%AA%E5%9B%BE20201117193836.png"></p>
<p>delegatecall不需要切换到被调用的合约的环境中执行，而是在当前调用的合约的环境中执行，比如就用当前账户的账户余额，存储之类的。</p>
<hr>
<p><img src="/2020/11/17/%E5%8C%BA%E5%9D%97%E9%93%BE/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/QQ%E6%88%AA%E5%9B%BE20201117193930.png"></p>
<p>这里的payable，只有第一个函数中有，其他两个没有，解释：</p>
<blockquote>
<p>以太坊中规定，如果这个合约账户要能接收外部转账的话，那么必须标注成payable，bid函数的功能：使用来进行竞拍，出价的，比如你要参与拍卖，你说你出100个以太币，那么你就调用这个合约中的这个bid函数，所以拍卖的规则是，你调用这个bid函数时，要把你拍卖的出价（100个以太币）也发送过去，存储在这个合约里，锁定在那一直到拍卖结束，避免有的人凭空出价，所以bid函数要有能力接受外部转账的能力。</p>
<p>withdraw函数是拍卖结束了，出价最高的那个人赢得了拍卖，其他人没有得到想要的东西，可以调用withdraw函数，把自己当初出的价钱（锁定在以太坊中的以太币取回来），因为不涉及对智能合约的转账，而仅仅是通过withdraw，取回锁定的钱。</p>
</blockquote>
<p>**注意:**以太坊中凡是要接受外部转账的函数,都要标注为payable,否则的话,如果你给这个函数转出去钱的话,回引出错误处理(抛出异常).如果你不需要接受外部转账，这个函数就不用写上payable。</p>
<hr>
<p><img src="/2020/11/17/%E5%8C%BA%E5%9D%97%E9%93%BE/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/QQ%E6%88%AA%E5%9B%BE20201117195655.png"></p>
<blockquote>
<p>上图中的函数既没有参数也没有返回值，而且也没有函数名（匿名函数）。</p>
<p>A调用B合约的时候，然后要在交易中的data域说明你调用的是B合约中的哪个函数，如果A给合约B转了一笔钱，没有说明调用的是哪个函数，怎么办？（data域是空的）这时候缺省的就是调用fallback函数（没有什么函数好调了，所以就调它），还有一种情况就是你调用的函数不存在，也是调用的这个fallback函数，这就是为什么这个函数没有参数和返回值。（这个fallback函数一般情况下都是写成payable）。</p>
</blockquote>
<p>​    我们说转账金额可以是0，但是汽油费是必须给的，这是两码事，转账金额是给收款人的，汽油费是给发布这个区块的矿工的。（汽油费不给的话，矿工不会把你这个交易打包发布到区块链上）。</p>
<h2 id="智能合约的创建和运行"><a href="#智能合约的创建和运行" class="headerlink" title="智能合约的创建和运行"></a>智能合约的创建和运行</h2><p>​    智能合约是由某一个外部账户发起一个转账交易，转给0x0这个地址，然后把要发布的合约的代码，放在data域里。</p>
<p><img src="/2020/11/17/%E5%8C%BA%E5%9D%97%E9%93%BE/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/QQ%E6%88%AA%E5%9B%BE20201118203237.png"></p>
<p>EVM和JVM是类似的思想，通过加一层虚拟机，对智能合约的运行提供一个一致性的平台，所以EVM有时候叫做world wide computer，EVM的寻址空间非常大，有256位，我们的个人电脑一般是64位的，和这个没法比。</p>
<p>​    如果比较以太坊和比特币两种区块链的编程模型，他们的设计理念有很大的差别，比特币的设计理念是简单，脚本语言的功能很有限，比如说不支持循环，而以太坊是要提供一个图灵完备的编程模型，很多功能在比特币平台实现起来很困难，甚至是根本实现不了，而到以太坊平台实现起来就很容易，当然，这样也出现一个问题，出现死循环怎么办？当一个全节点，收到一个对智能合约的调用，怎么知道这个调用执行起来会不会导致死循环？</p>
<blockquote>
<p>没有办法。这实际上是个‘停机问题’（Halting Problem），‘停机问题’是不可解的，这个问题不是NPC的（NPC问题是可解的），只不过他没有多项式时间的解法，很多NPC问题，有很自然的指数时间的解法。比如哈密顿回路，他是可能有解的，只不过这个解的复杂度可能是指数级的，而Halting Problem是不可解的，从理论上可以证明，不存在这样一个算法，能够对任意给定的输入程序判断出是否会停机。</p>
<p>有没有哈密顿回路，如果你不考虑复杂度的话，这个其实是很好解的：把所有的可能性枚举一遍，比如说你有n个顶点，n个顶点的排列有n!，把每个组合检查一下，是不是构成合法回路，就知道有没有哈密顿回路，只不过这个解的复杂度是指数级的。</p>
</blockquote>
<p><img src="/2020/11/17/%E5%8C%BA%E5%9D%97%E9%93%BE/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/QQ%E6%88%AA%E5%9B%BE20201118203918.png"></p>
<p>​    担心出现死循环怎么办？</p>
<blockquote>
<p>把这个问题推给发起交易的哪个账户，你发起一个对智能合约的调用，你要支付相应的汽油费</p>
<p>上图中的AccountNonce就是交易的序号，用于防止前面所说的replay attack；</p>
<p>Price和GasLimit和汽油费相关的，GasLimit是这个交易愿意支付的最大汽油量，Price是单位汽油的价格，乘积就是这个交易可能支付的最大汽油费；</p>
<p>Recipient是收款人的地址；</p>
<p>Amount：转账金额，把Amount的金额装给Recipient，所以我们可以看到，交易中的汽油费和转账金额是分开的；</p>
<p>Payload：前面说的data域，用于存放调用的是合约中的哪一个函数，参数之类</p>
</blockquote>
<p>​    当一个全节点收到一个对智能合约的调用的时候，先按照这个调用中给出的GasLimit，算出可能花掉的最大汽油费，然后一次性地把汽油费从发起调用的这个账户上扣掉，然后再根据实际执行的情况，算出实际花了多少汽油费，多退少补（其实如果汽油费不够的话，会引起回滚，就会一次性把这个汽油费全退回），一些简单的指令，比如加法、减法，消耗的汽油费是很少的，复杂的指令如取哈希，消耗的汽油费就很多，尽管这个运算一条指令就可以运行，除了计算量之外，需要存储状态的指令，消耗的汽油费也是比较大的，相比之下，如果你仅仅是为了读取公共数据，那些指令可以是免费的。</p>
<h2 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h2><p>​    以太坊中的交易执行起来具有原子性，一个交易要么全部执行，要么全不执行，不会只执行一部分。这个交易既包含转账交易，也包含对智能合约的调用，所以如果在执行智能合约调用的过程当中，出现任何错误，会导致整个交易的执行回滚，退回到开始执行之前的状态，就好像这个交易从来没有执行过。</p>
<p>​    出现错误的情况：</p>
<blockquote>
<p>①汽油费，如果这个交易执行完之后，没有达到当初的GasLimit，那么多余的汽油费会被退回到这个账户里，相反的，如果执行到一半，GasLimit已经都用完了，这个合约的执行要退回到开始执行之前的状态，这就是一种错误处理，而且这时候已经消耗的汽油费是不退的，要不然的话，就会有恶意结点可能会发动<strong>Denial-of-service attack</strong>，可能他发布一个计算量很大的合约，然后不停的调用，每次调用的时候给的汽油费都不够，反正汽油费还会退回来，这对恶意节点没有什么损失，但对矿工来说，是白白浪费很多资源。</p>
</blockquote>
<p><img src="/2020/11/17/%E5%8C%BA%E5%9D%97%E9%93%BE/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/QQ%E6%88%AA%E5%9B%BE20201119190332.png"></p>
<blockquote>
<p>require通常用来处理外部的错误，比如说判断函数的输入是否符合要求，这里的例子是一个bid函数，判断当前时间now是否是小于等于拍卖结束的时间，如果不符合，这个时候就会抛出异常。</p>
<p>revert是无条件会抛出异常，如果你执行到revert语句，他自动就会回滚，早期的版本里他用的是throw语句。</p>
</blockquote>
<p>​    智能合约出现错误会导致回滚，那么如果是嵌套调用，一个智能合约调用另外一个智能合约，那么被调用的哪个智能合约出现错误，是不是会导致发起调用的智能合约也一起回滚呢？</p>
<blockquote>
<p>不一定，取决于调用智能合约的方式，如果这个智能合约，直接调用的话，那么会触发连锁式的回滚，整个交易都会回滚，如果调用的方式是call方式，就不会引起连锁式回滚，只会使当前的调用失败，返回一个false的返回值，有些情况下，从表面上看，你并没有调用任何一个函数，比如只是往一个账户里转账，但是如果这个账户是一个合约账户的话，转账的本身就有可能触发对函数的调用。（因为会调用fallback函数）</p>
</blockquote>
<hr>
<p><img src="/2020/11/17/%E5%8C%BA%E5%9D%97%E9%93%BE/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/QQ%E6%88%AA%E5%9B%BE20201003191125.png"></p>
<blockquote>
<p>区块的块头中也有GasLimit，发布区块需要消耗一定的资源，那么我们要不要对这个区块发布消耗的资源有一个限制，比特币当中对发布的区块也是有一个限制的（大小，最多不能超过1M），以太坊中这么规定是不行的，智能合约的调用是非常复杂的，有的交易可能从字节数上来看可能是很小的，但是消耗的资源可能很大（可能调用别的合约之类的），所以要根据这个交易的具体操作来收费（这就是汽油费），GasLimit是这个区块里所有的交易能消耗汽油的一个上限（这个不是说把这个区块中所有交易的GasLimit加在一起，如果这样的话，就没有限制了）。</p>
<p>每个矿工可以对这个GasLimit进行微调，可以再上一个区块的GasLimit基础上上调或者下调1/1024，1/1024看起来很小，以太坊的出块速度很快，所以如果大家都觉得现在的GasLimit太小，那么很快就会翻一番，下调一样，所以这种机制下求出的GasLimit，是所有矿工认为比较合理的GasLimit的平均值。</p>
</blockquote>
<p>​    假设某个全节点要打包一些交易到区块链里面，这些交易里有一些是对智能合约的调用，那么这个全节点是应该先把这些智能合约都执行完之后，再去挖矿呢？还是应该先挖矿，获得记账权，然后再去执行智能合约？</p>
<blockquote>
<p>区块链里有一笔转账交易发布上去的话，本来就是需要全节点都去执行的，这个不是浪费，也不是一种问题，所有的全节点都要同步状态，在本地执行交易，如果要有一个全节点不执行，就会出问题，它的状态和别的全节点不同步，比特币也是一样。</p>
<p>但是执行智能合约，就要从发起交易的账户收取汽油费，那么如果有多个人都执行这个智能合约，会把这个汽油费收很多份。</p>
<p>我们说全节点收到一个对合约的调用的时候，要一次性的先把这个调用可能花掉的最大汽油费，从发起这个调用的账户上扣掉，这个具体是怎么操作的？</p>
</blockquote>
<h2 id="Receipt数据结构"><a href="#Receipt数据结构" class="headerlink" title="Receipt数据结构"></a>Receipt数据结构</h2><p>​    状态树，交易树，收据树三棵树都是全节点在本地维护的数据结构，状态树记录了每个账户的状态，包括账户余额，所以扣除汽油费是怎么扣的？全节点收到这个调用之后，从我本地的数据结构里把他账户里的余额减掉就行了，如果余额不够的话，这个交易就不能执行。执行完了如果有剩的，再把它的余额再加回来，多个人执行带智能合约的调用，只是在本地将要扣除的汽油费扣除而已。任何状态的修改都是修改本地的数据结构，只有在合约执行完了，发布到区块链上之后，在本地的修改才会变成外部可见的，才会变成共识。如果某个全节点发布了一个区块，我收到这个区块之后，在本地执行的代码就扔掉了，再按照区块里的交易再执行一遍，更新本地的三棵树。</p>
<p>​    以太坊挖矿，也是尝试nonce，计算哈希的时候要用到什么？</p>
<blockquote>
<p>用到block header的内容，Root，TXHash，ReceiptHash是三棵树的根哈希值，所以应该先执行完这个区块中的所有交易，包括智能合约的交易，这样才能够更新这三棵树，这样才能知道这三棵树的根哈希值，block header的内容才能确定，然后才能尝试各个nonce。</p>
</blockquote>
<p><img src="/2020/11/17/%E5%8C%BA%E5%9D%97%E9%93%BE/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/QQ%E6%88%AA%E5%9B%BE20201003191125.png">    </p>
<p>​    假设我是一个矿工，费了半天劲执行这些智能合约，消耗了我本地的好多资源，最后我挖矿没有挖到怎么办？能得到什么补偿</p>
<blockquote>
<p>首先汽油费是没有的，因为汽油费是给获得记账权发布区块的哪个矿工。</p>
<p>①因为有ghost协议，所以我可以继续挖矿，当一个叔父区块，一般不这么干，如果都这么干，共识机制就比较难达成了，等于你故意造成分叉，这么干对自己也没有什么好处，挖到叔父区块还是得切换到最长合法链上，所以代价没有省下来，为什么不先切换到最长合法链上继续挖呢？挖矿是无记忆的，前面挖了多少和后面是没有关系的，不如切换到最长合法链，然后继续挖。</p>
<p>以太坊中没有任何补偿，不仅如此，还要把别人发布的区块里的交易在本地执行一遍，以太坊中规定要验证发布区块的正确性，每个全节点要独立验证。</p>
</blockquote>
<p>​    所以，这种机制下，挖矿慢的矿工，就比较吃亏，本来汽油费的设置是出于对矿工执行这些智能合约消耗的资源得一种补偿的目的，但是这种补偿，只有挖到矿的矿工才能得到，其他的矿工相当于“陪挖”。</p>
<p>​    会不会有的矿工，觉得不给我汽油费，那我就不验证了？</p>
<blockquote>
<p>按照协议，我要验证一下获得记账权的矿工发布区块的正确性，我验证他能得什么好处？又不给汽油费，我认为你是正确的不就行了吗，接着往下挖，会不会有矿工“想不开”？</p>
<p>出现这种情况会导致什么后果？最直接的后果是，危害区块链的安全，区块链的安全要求所有的全结点要独立验证发布的区块的合法性，这样少数有恶意的结点才没有办法篡改区块链上的内容，如果某个矿工想不通，不给钱就不验证了，那么这样的风气蔓延开，就会危害区块链的安全。</p>
<p>如果他跳过验证的这个步骤，就没法在挖矿了，因为验证的时候是把交易都执行一遍，更新本地的三棵树，如果不验证的话，三棵树的内容，没有办法更新，以后就没有办法发布新的区块了，本地的状态就不对了，算出的根哈希值别人认为是错的。（这三棵树的内容是不会出现的发布的区块中的，只有在本地验证之后才有），这就对应了前面所说的，不能把状态树的全部内容都发布到区块链上，太多了而且很多是重复的</p>
</blockquote>
<p>​    矿池的有些做法是，很多矿工合在一起，矿工本身不验证，矿池中有个pool manager全节点是负责统一验证，矿工就都相信这个全节点验证完之后的正确性。</p>
<p>​    发布到区块链上的交易是不是都成功执行的？如果智能合约执行过程中出现了错误，要不要也发布到区块链上去？</p>
<blockquote>
<p>执行发生错误的交易，也要发布到区块链上去，否则的话，汽油费扣不掉，光是在本地的数据结构上扣除汽油费是没用的，拿不到钱，你得把他发布到区块链上之后，形成共识，扣掉的汽油费才能形成你账户上的钱，所以发布到区块链上的交易不一定都是成功执行的，要告诉大家为什么扣汽油费，别人也要验证一遍，把这个交易执行一遍，看你这个交易执行的是不是对的</p>
</blockquote>
<p>​    怎么知道一个交易是不是执行成功了呢？</p>
<blockquote>
<p>我们前面说的那三棵树，每个交易执行完之后，形成一个交易，Status域就是交易执行的情况</p>
</blockquote>
<p><img src="/2020/11/17/%E5%8C%BA%E5%9D%97%E9%93%BE/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/QQ%E6%88%AA%E5%9B%BE20201123194058.png"></p>
<p>​    智能合约是不是支持多线程？多核处理器很普遍，智能合约支不支持多核并行处理？</p>
<blockquote>
<p>solidity不支持多线程，他根本没有支持多线程的语句，以太坊是一个交易驱动的状态机，必须是完全确定性的，给定一个智能合约，面对同一组输入，产生的输出，或者转移到下一个状态必须是完全确定的，所有的全节点都得执行同一组操作，到达同一个状态，如果状态不确定，三棵树的根哈希值完全对不上，必须完全确定才行，多线程的问题在于：多个核对内存访问顺序不同的话，执行结果有可能是不确定的。<a href="http://zhenxiao.com/papers">http://zhenxiao.com/papers</a></p>
</blockquote>
<p>​    除了多线程之外，造成执行结果不确定的操作，也都不支持。</p>
<blockquote>
<p>产生随机数，这个操作必须是不确定性的，如果不同的机器产生的随机数都一样，那不叫随机数了，所以以太坊中的智能合约没有办法产生真正意义上的随机数，可以用一些伪随机数，不能是真的随机数，否则的话，会出现前面的问题。每个全节点执行的结果都不一致。</p>
</blockquote>
<p>​    智能合约的执行必须是确定性的，这就导致了智能合约不能像通用的编程语言那样通过系统调用得到system call的一些信息（环境信息），每个全节点执行的环境不是完全一样的，所以只有通过一些固定的一些变量的值，能够得到一些状态信息。</p>
<p>​    <img src="/2020/11/17/%E5%8C%BA%E5%9D%97%E9%93%BE/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/QQ%E6%88%AA%E5%9B%BE20201124184056.png"></p>
<p>​    <img src="/2020/11/17/%E5%8C%BA%E5%9D%97%E9%93%BE/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/QQ%E6%88%AA%E5%9B%BE20201124184206.png"></p>
<blockquote>
<p>上图中的msg.sender消息发送者和下面tx.origin交易发起者不是一个东西，有个外部账户A调用了一个合约C1，C1中有个函数f1，函数f1调用了另外一个合约账户C2里面的函数f2，对于函数f2来说msg.sender是C1合约，因为当前这个msg call是C1这个合约发起的；tx.origin是A账户，整个交易最初的发起者是A账户。</p>
<p>msg.gas指的是当前交易还剩下多少汽油费，决定了我还能够做什么操作，包括像调用别的合约，前提是还有别的汽油费剩下来。</p>
<p>msg.data就是所谓的数据域，在里面写了调用了哪个函数，和这个函数所使用到的参数取值。</p>
<p>now和上一个图中的timestamp是一个意思，智能合约里没有精确的时间，只能获得和当前区块相关的时间</p>
</blockquote>
<p><img src="/2020/11/17/%E5%8C%BA%E5%9D%97%E9%93%BE/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/QQ%E6%88%AA%E5%9B%BE20201124185036.png"></p>
<blockquote>
<p>balance是一个成员变量，其他的都是成员函数，uint256是成员变量的类型，不是函数调用（不是参数）。addr.balance是这个地址上这个账户的余额，addr.transfer(12345)感觉是addr这个账户向外转了12345个wei，但是问题来了，这个函数只有一个参数，没有说转给谁，所以addr.transfer指的是当前这个合约往addr这个地址里转入多少钱，addr是转入的地址，不是转出的地址，那么哪个是转入的地址？C这个智能合约里面有个函数f，f包含addr.transfer，意思是从C这个账上，往这个addr账户中转入xx钱，其他的函数也类似（比如addr.call，是当前合约，调用addr这个合约，而不是addr这个账户调用别的账户）。</p>
<p>transfer和send都是用来转账的函数，区别是transfer会导致连锁性回滚，而send不会导致连锁回滚，call其实也可以转账，addr.call.value(amount)。call也不会引起连锁式回滚，另外一个区别是transfer和send只给了2300的汽油费（这是非常少的），转账的合约基本上干不了其他的事，只是写个log的费用，而call是把当前这个调用剩下的所有汽油都发过去，比如说call所在的这个合约本身被调用的时候还剩8000个汽油，然后去调别的合约的时候用call转账，就把8000个汽油都转过去了。call之后，如果当前合约还有别的操作，call调用的别的合约，如果有剩余的汽油，会返回，然后可以再执行相应的其他操作。</p>
</blockquote>
<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p><img src="/2020/11/17/%E5%8C%BA%E5%9D%97%E9%93%BE/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/QQ%E6%88%AA%E5%9B%BE20201124191414.png"></p>
<blockquote>
<p>比如说你有一个古董要拍卖，拍卖的受益人就是你 。</p>
<p>在拍卖结束之前，每个人都可以去出价竞拍，竞拍的时候为了保证诚信，要把你竞拍的价格的相应的以太币发过去，比如说你出价100个以太币，竞拍的时候把这100个以太币发到智能合约里，而且会锁在这里面，知道竞拍结束，这个拍卖的规则不允许中途退出。拍卖结束出价最高的人他投出去的钱会给受益人，当然，你应该把古董给最高出价人，那么其他没有竞拍成功的人，可以把当初投进去的钱取回来，（也就是withdraw函数）。竞拍可以多次出价。出价有效的话，要比当前最高出价还要高。</p>
</blockquote>
<p><img src="/2020/11/17/%E5%8C%BA%E5%9D%97%E9%93%BE/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/QQ%E6%88%AA%E5%9B%BE20201124192045.png"></p>
<blockquote>
<p>bid函数没有参数，感觉好像你出价的时候不需要告诉对方你出价多少？他在里面有个msg.value：这是发起这个调用的时候转账转过去的以太币的数目，以wei为单位的转账金额，这个逻辑是，查一下当前拍卖还没结束，如果结束了，还出价会抛出异常，然后查一下你上次出价，加上当前这个调用发出去的以太币，大于最高出价，如果你以前没有出价过？solidity中的哈希表，如果键值不存在，那么返回的默认值就是0，之后将拍卖者的信息放到bid数组里，之后记录一下最高价</p>
</blockquote>
<p><img src="/2020/11/17/%E5%8C%BA%E5%9D%97%E9%93%BE/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/QQ%E6%88%AA%E5%9B%BE20201124192101.png"></p>
<blockquote>
<p>拍卖结束的函数，查一下拍卖是否已经结束了，如果有人调用，是非法的，会抛出异常，require(!ended)判断一下当前函数是否已经被调用过了，如果已经被调用过了，就不用再调用。beneficiary.transfer指的是当前这个合约，把bids[highestBidder]金额给beneficiary转过去，对于没有竞拍成功的人，进行循环，把这个金额退回给这个bidder。然后标注一下ended=true，表示这个函数已经被执行了。</p>
</blockquote>
<p>​    有什么问题么？</p>
<blockquote>
<p>如果你写完一个拍卖程序，然后你要先把他发布到区块链上：往0地址发一笔转账交易，转账的金额是0，但是汽油费是要交的，把这个智能合约的代码放在data域里面，矿工将这个智能合约发布到区块链上之后，会返回给你一个合约的地址，然后这个合约就在区块链上了，所有人都可以调用它。</p>
<p>智能合约本身有一个合约账户，里面有它的状态信息。拍卖的时候要调用bid函数，当前账户调用的bid函数正是矿工写在区块链里的。</p>
<p>写智能合约一定要小心，因为智能合约是不可篡改的，说得不好听点就是有bug没有办法改。</p>
</blockquote>
<p>​    auctionEnd函数必须要某个人调用才能执行，这个也是solidity语言和其他语言不同的地方，就是没有办法把它设置成拍卖结束了自动执行auctionEnd，可能是拍卖的受益人调用，也可能是某个参与竞拍没有成功的人，总之得有一个人去调用，如果两个人都去调用auctionEnd，矿工在执行的时候，把第一个调用执行完了，然后第二个调用就执行不了了（没有并发执行！）</p>
<p>​    <img src="/2020/11/17/%E5%8C%BA%E5%9D%97%E9%93%BE/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/QQ%E6%88%AA%E5%9B%BE20201124194924.png"></p>
<blockquote>
<p>这个合约实际上就一个函数，参数就是拍卖合约的地址，把它转成拍卖合约的一个实例，然后调用拍卖合约中的bid函数，把这个钱发送过去，这是一个合约账户，合约账户不能自己发起交易，所以实际上是有一个黑客，从他自己的外部账户，发起一个交易，调用这个合约账户的hack_bid函数，然后hack_bid函数再去调用拍卖合约中的bid函数，把他收到的自己外部账户转过来的钱，再转给拍卖合约中的bid函数，参与拍卖，看似没有什么问题；但是在退款的时候，在一个合约账户收到转账，没有调用任何函数的时候的时候，应该调用fallback函数，而hackV1没有定义fallback函数，所以会调用失败，抛出异常，transfer函数会引起连锁式地回滚，所以导致转账操作是失败的，收不到钱，对黑客有什么好处？</p>
<p>有可能是故意捣乱，也有可能是这个人不懂，忘了写fallback函数。</p>
<p>退款只是改本地的数据结构，没有形成交易，如果都执行完了，发布出去之后，别的矿工也把这个auctionEnd从头到尾执行一遍，也改他本地地数据结构，这就叫形成共识，不管排在黑客前面的拍卖者还是后面的拍卖者，只不过后面的bidder根本不能执行，然后整个都回滚了，就好像这个智能合约没有被执行过一样，排在前面的对bidder转账并没有执行，所以都收不到钱。</p>
</blockquote>
<p><img src="/2020/11/17/%E5%8C%BA%E5%9D%97%E9%93%BE/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/QQ%E6%88%AA%E5%9B%BE20201124200856.png"></p>
<p>​    出现上面的情况怎么办？你已经把钱投在里面了，怎么把钱拿出来的问题</p>
<blockquote>
<p>没有办法。Code is law，智能合约的规则是由代码逻辑决定的，而代码一旦发布到区块链上，就改不了了，就是所谓的区块链的不可篡改性，这样的好处是，没有人可以篡改规则，坏处是，规则中有漏洞，你也改不了了，智能合约如果设计的不好的话，有可能把收到的以太币永久的锁起来，谁也取不出来。以前还有人用智能合约锁仓的，就比如要开发一个新的加密货币，像前面的pre mining，预留一些币给开发者，然后这些币都打在一个智能合约账户上，锁仓三年，三年之后，这些币才能卖，这样做才能为了让大家在一开始的时候都集中精力开发这个加密货币，智能合约锁仓是个常用操作，万一要是写错了，多写一个0，这些币就会锁上三十年，这个有点像irrevocable trust（不可撤销的信托），美国有一些有钱人用这种信托以达到财产保护，或者是减税的目的，就是一个法律上的合同，如果制定这种不可撤销的信托的时候，法律条款有问题，也可能会导致存进去的钱取不出来。所以在你发布一个智能合约之前，一定要测试！</p>
</blockquote>
<p>​    我能不能在智能合约里留个后门？给合约的创建者一个超级用户的权力？</p>
<blockquote>
<p>在智能合约的构造函数中加一个owner，这个owner可以做一些系统管理员的操作，可以任意转账，把钱转给哪个账户都行，出现上面的bug，owner就可以起到作用。</p>
<p>这样做的前提是，所有人都要新人owner，这个和去中心化的理念是背道而驰的，也是绝大多数区块链的用户不能接受的</p>
</blockquote>
<hr>
<p>​    第二版：由投标者自己取回出价</p>
<p><img src="/2020/11/17/%E5%8C%BA%E5%9D%97%E9%93%BE/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/QQ%E6%88%AA%E5%9B%BE20201124221310.png"></p>
<blockquote>
<p>这里就不用循环了，每个竞拍没有成功的人，自己调用withdraw函数，把钱取回来，先判断是不是最高出价者，如果是的话，不能把钱给他，因为要留着给受益人，再判断这个人的账户余额是不是正的，amount是账户余额，将账户余额转给sender，然后将bids清零，免得下次再来取钱</p>
</blockquote>
<p><img src="/2020/11/17/%E5%8C%BA%E5%9D%97%E9%93%BE/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/QQ%E6%88%AA%E5%9B%BE20201124221321.png"></p>
<p>​    这样可以了么？</p>
<p><img src="/2020/11/17/%E5%8C%BA%E5%9D%97%E9%93%BE/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/QQ%E6%88%AA%E5%9B%BE20201124221948.png"></p>
<p><img src="/2020/11/17/%E5%8C%BA%E5%9D%97%E9%93%BE/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/QQ%E6%88%AA%E5%9B%BE20201124222014.png"></p>
<blockquote>
<p>hack_bid和前面的hack_bid相同</p>
<p>hack_withdraw在拍卖结束的时候把钱取回来，这样看上去好像没问题，问题在于fallback函数又把钱取了一遍，fallback中的msg.sender是拍卖合约，拍卖合约又会给他转一次钱，账户清零的操作只有在转账成功之后才会执行，但是现在已经陷入到了和黑客合约中的递归调用当中，根本执行不到，所以最后的结果是，黑客不停地从拍卖合约中取钱，第一次取得是自己的出价，后面取得就是别人的钱了。</p>
<p>这个递归取钱持续到什么时候结束？</p>
<p>①拍卖合约上的余额不够了，不足以在支持转账的语句</p>
<p>②汽油费不够了</p>
<p>③调用栈溢出了</p>
<p>所以黑客合约会先判断，之后在进行攻击。</p>
</blockquote>
<p>​    解决办法：可以先清零，再转账。</p>
<p>在区块链上，任何未知的合约，都可能是有恶意的，所以每次你向对方转账，或者是调用对方的某个函数，都要提醒一下自己，这个合约这个函数，有可能反过来调用你当前这个合约，并且修改状态，除了上述方法，还有下面的一种解决方法：</p>
<p><img src="/2020/11/17/%E5%8C%BA%E5%9D%97%E9%93%BE/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/QQ%E6%88%AA%E5%9B%BE20201124223111.png"></p>
<p><img src="/2020/11/17/%E5%8C%BA%E5%9D%97%E9%93%BE/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/QQ%E6%88%AA%E5%9B%BE20201124223124.png"></p>
<blockquote>
<p>首先将清零的位置提前了，而且转账的时候用的是send，send和transfer的一个共同特点是转账的时候发送的汽油费只有2300个单位，这个不足以让接收的合约再发起一个新的调用，只够写一个log而已。</p>
</blockquote>
]]></content>
      <categories>
        <category>区块链</category>
      </categories>
      <tags>
        <tag>区块链</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM一---运行时数据区</title>
    <url>/2020/10/13/Java/JVM/jvm%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/</url>
    <content><![CDATA[<h1 id="运行时数据区"><a href="#运行时数据区" class="headerlink" title="运行时数据区"></a>运行时数据区</h1><p>写在前面，感谢尚硅谷宋红康老师的讲解，本文根据宋红康老师的ppt完成，仅供个人学习参考，更多的JVM相关的知识请访问Oracle官网</p>
<a id="more"></a>

<h2 id="1-内部结构"><a href="#1-内部结构" class="headerlink" title="1.内部结构"></a>1.内部结构</h2><p><img src="/2020/10/13/Java/JVM/jvm%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/QQ%E6%88%AA%E5%9B%BE20200728210959.png"></p>
<p><img src="/2020/10/13/Java/JVM/jvm%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/QQ%E6%88%AA%E5%9B%BE20200728211336.png"></p>
<p><img src="/2020/10/13/Java/JVM/jvm%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/QQ%E6%88%AA%E5%9B%BE20200728211523.png"></p>
<p><img src="/2020/10/13/Java/JVM/jvm%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/QQ%E6%88%AA%E5%9B%BE20200728211756.png"></p>
<p><img src="/2020/10/13/Java/JVM/jvm%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/QQ%E6%88%AA%E5%9B%BE20200728212041.png"></p>
<p><img src="/2020/10/13/Java/JVM/jvm%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/QQ%E6%88%AA%E5%9B%BE20200728212559.png"></p>
<h2 id="2-线程"><a href="#2-线程" class="headerlink" title="2.线程"></a>2.线程</h2><p><img src="/2020/10/13/Java/JVM/jvm%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/QQ%E6%88%AA%E5%9B%BE20200728212937.png"></p>
<p>1.说的一个线程准备好之后，那这个准备是什么意思：</p>
<p>每个java线程都有自己的程序计数器，虚拟机栈，本地方法栈等，都需要准备</p>
<p>2.如果在run方法中碰到了未捕获的异常，java线程就会终止，但是操作系统本地线程不会立即终止，由它来决定jvm进程要不要终止，jvm要不要终止，又取决于当前的java线程是不是最后一个非守护线程</p>
<p><img src="/2020/10/13/Java/JVM/jvm%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/QQ%E6%88%AA%E5%9B%BE20200728213604.png"></p>
<h2 id="3-pc寄存器（程序计数器）"><a href="#3-pc寄存器（程序计数器）" class="headerlink" title="3.pc寄存器（程序计数器）"></a>3.pc寄存器（程序计数器）</h2><p><img src="/2020/10/13/Java/JVM/jvm%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/QQ%E6%88%AA%E5%9B%BE20200728214231.png"></p>
<p><img src="/2020/10/13/Java/JVM/jvm%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/QQ%E6%88%AA%E5%9B%BE20200728214447.png"></p>
<p><img src="/2020/10/13/Java/JVM/jvm%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/QQ%E6%88%AA%E5%9B%BE20200728214622.png"></p>
<p><img src="/2020/10/13/Java/JVM/jvm%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/QQ%E6%88%AA%E5%9B%BE20200728215104.png"></p>
<p><img src="/2020/10/13/Java/JVM/jvm%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/QQ%E6%88%AA%E5%9B%BE20200731211604.png"></p>
<p><img src="/2020/10/13/Java/JVM/jvm%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/QQ%E6%88%AA%E5%9B%BE20200731211933.png"></p>
<p><img src="/2020/10/13/Java/JVM/jvm%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/QQ%E6%88%AA%E5%9B%BE20200731212357.png"></p>
<p>两个常见的问题</p>
<p>①<img src="/2020/10/13/Java/JVM/jvm%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/QQ%E6%88%AA%E5%9B%BE20200731212559.png"></p>
<p>②<img src="/2020/10/13/Java/JVM/jvm%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/QQ%E6%88%AA%E5%9B%BE20200731212742.png"></p>
<h2 id="4-虚拟机栈"><a href="#4-虚拟机栈" class="headerlink" title="4.虚拟机栈"></a>4.虚拟机栈</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p><img src="/2020/10/13/Java/JVM/jvm%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/QQ%E6%88%AA%E5%9B%BE20200731214026.png"></p>
<p><img src="/2020/10/13/Java/JVM/jvm%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/QQ%E6%88%AA%E5%9B%BE20200731214229.png"></p>
<p><img src="/2020/10/13/Java/JVM/jvm%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/QQ%E6%88%AA%E5%9B%BE20200731214810.png"></p>
<p>一个线程，对应一个java虚拟机栈</p>
<p><img src="/2020/10/13/Java/JVM/jvm%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/QQ%E6%88%AA%E5%9B%BE20200731215443.png"></p>
<p><img src="/2020/10/13/Java/JVM/jvm%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/QQ%E6%88%AA%E5%9B%BE20200731215746.png"></p>
<h3 id="java虚拟机栈常见的异常"><a href="#java虚拟机栈常见的异常" class="headerlink" title="java虚拟机栈常见的异常"></a>java虚拟机栈常见的异常</h3><p><img src="/2020/10/13/Java/JVM/jvm%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/QQ%E6%88%AA%E5%9B%BE20200731220315.png"></p>
<p><img src="/2020/10/13/Java/JVM/jvm%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/QQ%E6%88%AA%E5%9B%BE20200731220810.png"></p>
<h3 id="栈的存储结构和运行原理"><a href="#栈的存储结构和运行原理" class="headerlink" title="栈的存储结构和运行原理"></a>栈的存储结构和运行原理</h3><p><img src="/2020/10/13/Java/JVM/jvm%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/QQ%E6%88%AA%E5%9B%BE20200804215450.png"></p>
<p><img src="/2020/10/13/Java/JVM/jvm%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/QQ%E6%88%AA%E5%9B%BE20200804215851.png"></p>
<p><img src="/2020/10/13/Java/JVM/jvm%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/QQ%E6%88%AA%E5%9B%BE20200804220030.png"></p>
<p><img src="/2020/10/13/Java/JVM/jvm%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/QQ%E6%88%AA%E5%9B%BE20200804221220.png"></p>
<p>遇到异常如果在当前栈帧中没有处理，则会向上抛，如果还没有，在向上抛，直到main方法，main方法如果还没有处理，当前线程就结束了</p>
<h3 id="栈帧的内部结构"><a href="#栈帧的内部结构" class="headerlink" title="栈帧的内部结构"></a>栈帧的内部结构</h3><p><img src="/2020/10/13/Java/JVM/jvm%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/QQ%E6%88%AA%E5%9B%BE20200804222347.png"></p>
<h3 id="局部变量表的结构的认识"><a href="#局部变量表的结构的认识" class="headerlink" title="局部变量表的结构的认识"></a>局部变量表的结构的认识</h3><p><img src="/2020/10/13/Java/JVM/jvm%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/QQ%E6%88%AA%E5%9B%BE20200811204445.png"></p>
<p><img src="/2020/10/13/Java/JVM/jvm%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/QQ%E6%88%AA%E5%9B%BE20200811205919.png"></p>
<p>局部变量表是一个<strong>数字数组</strong>：里面的变量都可以用数值来表示</p>
<p>这里的这个Maximum local variables是在编译的时候就已经确定了长度了</p>
<p><img src="/2020/10/13/Java/JVM/jvm%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/QQ%E6%88%AA%E5%9B%BE20200811205442.png"></p>
<p><img src="/2020/10/13/Java/JVM/jvm%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/QQ%E6%88%AA%E5%9B%BE20200811210833.png"></p>
<p><img src="/2020/10/13/Java/JVM/jvm%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/QQ%E6%88%AA%E5%9B%BE20200811210900.png"></p>
<h3 id="字节码中方法内部结构"><a href="#字节码中方法内部结构" class="headerlink" title="字节码中方法内部结构"></a>字节码中方法内部结构</h3><p><img src="/2020/10/13/Java/JVM/jvm%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/QQ%E6%88%AA%E5%9B%BE20200811211636.png"></p>
<p>上图中的L指的是引用类型的变量</p>
<p>Access flags：访问标识</p>
<p><img src="/2020/10/13/Java/JVM/jvm%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/QQ%E6%88%AA%E5%9B%BE20200811211919.png"></p>
<p><img src="/2020/10/13/Java/JVM/jvm%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/QQ%E6%88%AA%E5%9B%BE20200811212043.png"></p>
<p><img src="/2020/10/13/Java/JVM/jvm%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/QQ%E6%88%AA%E5%9B%BE20200811212846.png"></p>
<h3 id="slot理解"><a href="#slot理解" class="headerlink" title="slot理解"></a>slot理解</h3><p><img src="/2020/10/13/Java/JVM/jvm%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/QQ%E6%88%AA%E5%9B%BE20200811213336.png"></p>
<p><img src="/2020/10/13/Java/JVM/jvm%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/QQ%E6%88%AA%E5%9B%BE20200811213640.png"></p>
<p><strong>注意，如果是非静态的方法，该对象引用this将会存放在index为0的slot处</strong>，静态方法中不可以引用this，所以在静态方法中没有</p>
<p><img src="/2020/10/13/Java/JVM/jvm%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/QQ%E6%88%AA%E5%9B%BE20200811214212.png"></p>
<p><img src="/2020/10/13/Java/JVM/jvm%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/QQ%E6%88%AA%E5%9B%BE20200811214713.png"></p>
<p><img src="/2020/10/13/Java/JVM/jvm%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/QQ%E6%88%AA%E5%9B%BE20200811214825.png"></p>
<p><img src="/2020/10/13/Java/JVM/jvm%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/QQ%E6%88%AA%E5%9B%BE20200811215035.png"></p>
<h3 id="静态变量和局部变量的对比"><a href="#静态变量和局部变量的对比" class="headerlink" title="静态变量和局部变量的对比"></a>静态变量和局部变量的对比</h3><p><img src="/2020/10/13/Java/JVM/jvm%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/QQ%E6%88%AA%E5%9B%BE20200818204321.png"></p>
<p><img src="/2020/10/13/Java/JVM/jvm%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/QQ%E6%88%AA%E5%9B%BE20200818204555.png"></p>
<h3 id="操作数栈的特点"><a href="#操作数栈的特点" class="headerlink" title="操作数栈的特点"></a>操作数栈的特点</h3><p><img src="/2020/10/13/Java/JVM/jvm%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/QQ%E6%88%AA%E5%9B%BE20200818205205.png"></p>
<p><img src="/2020/10/13/Java/JVM/jvm%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/QQ%E6%88%AA%E5%9B%BE20200818205543.png"></p>
<p><img src="/2020/10/13/Java/JVM/jvm%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/QQ%E6%88%AA%E5%9B%BE20200818205727.png"></p>
<h3 id="操作数栈的字节码指令分析"><a href="#操作数栈的字节码指令分析" class="headerlink" title="操作数栈的字节码指令分析"></a>操作数栈的字节码指令分析</h3><p><img src="/2020/10/13/Java/JVM/jvm%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/QQ%E6%88%AA%E5%9B%BE20200818210902.png"></p>
<p><img src="/2020/10/13/Java/JVM/jvm%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/QQ%E6%88%AA%E5%9B%BE20200818210951.png"></p>
<p><img src="/2020/10/13/Java/JVM/jvm%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/QQ%E6%88%AA%E5%9B%BE20200818211019.png"></p>
<p><img src="/2020/10/13/Java/JVM/jvm%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/QQ%E6%88%AA%E5%9B%BE20200818211327.png"></p>
<p><img src="/2020/10/13/Java/JVM/jvm%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/QQ%E6%88%AA%E5%9B%BE20200818211758.png"></p>
<p><img src="/2020/10/13/Java/JVM/jvm%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/QQ%E6%88%AA%E5%9B%BE20200818212259.png"></p>
<p><img src="/2020/10/13/Java/JVM/jvm%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/QQ%E6%88%AA%E5%9B%BE20200818212725.png"></p>
<h3 id="栈顶缓存技术Top-of-Stack-Cashing"><a href="#栈顶缓存技术Top-of-Stack-Cashing" class="headerlink" title="栈顶缓存技术Top of  Stack Cashing"></a>栈顶缓存技术Top of  Stack Cashing</h3><p><img src="/2020/10/13/Java/JVM/jvm%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/QQ%E6%88%AA%E5%9B%BE20200818213110.png"></p>
<h3 id="动态链接"><a href="#动态链接" class="headerlink" title="动态链接"></a>动态链接</h3><p><img src="/2020/10/13/Java/JVM/jvm%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/QQ%E6%88%AA%E5%9B%BE20200827215750.png"></p>
<p>大部分字节码指令在执行的时候，都需要进行常量池的访问，帧数据区中，就保存着可以访问常量池中的一个指针，方便程序访问常量池，这里就是我们所说的动态链接</p>
<p><img src="/2020/10/13/Java/JVM/jvm%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/QQ%E6%88%AA%E5%9B%BE20200827220007.png"></p>
<p><img src="/2020/10/13/Java/JVM/jvm%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/QQ%E6%88%AA%E5%9B%BE20200827220843.png"></p>
<p>以上这些符号就是所谓的动态链接，常量池在运行的时候被放到方法区，所以叫做运行时常量池。</p>
<p><img src="/2020/10/13/Java/JVM/jvm%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/QQ%E6%88%AA%E5%9B%BE20200827221440.png"></p>
<p>那为什么不把“方法”直接放在栈帧中呢？java对象中有很多的方法，所以，总不可能每个栈帧，都放一个符号方法吧</p>
<p><img src="/2020/10/13/Java/JVM/jvm%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/QQ%E6%88%AA%E5%9B%BE20200827221934.png"></p>
<h3 id="方法的调用–静态绑定与动态绑定"><a href="#方法的调用–静态绑定与动态绑定" class="headerlink" title="方法的调用–静态绑定与动态绑定"></a>方法的调用–静态绑定与动态绑定</h3><p><img src="/2020/10/13/Java/JVM/jvm%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/QQ%E6%88%AA%E5%9B%BE20200827222502.png"></p>
<p>如果在编译器就知道符号引用对应方法的直接引用，就称为静态链接</p>
<p><img src="/2020/10/13/Java/JVM/jvm%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/QQ%E6%88%AA%E5%9B%BE20200827222815.png"></p>
<p>在多态中可以体现</p>
<p><img src="/2020/10/13/Java/JVM/jvm%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/QQ%E6%88%AA%E5%9B%BE20200827223851.png"></p>
<p>虚函数 == 具备晚期绑定的特点的方法</p>
<h3 id="虚方法和非虚方法"><a href="#虚方法和非虚方法" class="headerlink" title="虚方法和非虚方法"></a>虚方法和非虚方法</h3><p><img src="/2020/10/13/Java/JVM/jvm%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/QQ%E6%88%AA%E5%9B%BE20200827224404.png"></p>
<p>非虚方法，不涉及方法的重写</p>
<p><img src="/2020/10/13/Java/JVM/jvm%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/QQ%E6%88%AA%E5%9B%BE20200827224834.png"></p>
<p>注意：子类自己声明的普通方法也叫做invokevirtual，父类中子类没有重写的方法，在子类中没有super.显示调用也叫做invokevirtual</p>
<h3 id="invokedynamic指令的使用"><a href="#invokedynamic指令的使用" class="headerlink" title="invokedynamic指令的使用"></a>invokedynamic指令的使用</h3><p><img src="/2020/10/13/Java/JVM/jvm%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/QQ%E6%88%AA%E5%9B%BE20200901211432.png"></p>
<p><img src="/2020/10/13/Java/JVM/jvm%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/QQ%E6%88%AA%E5%9B%BE20200901211522.png"></p>
<p><img src="/2020/10/13/Java/JVM/jvm%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/QQ%E6%88%AA%E5%9B%BE20200901212213.png"></p>
<h3 id="方法重写的本质"><a href="#方法重写的本质" class="headerlink" title="方法重写的本质"></a>方法重写的本质</h3><p><img src="/2020/10/13/Java/JVM/jvm%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/QQ%E6%88%AA%E5%9B%BE20200901212555.png"></p>
<p>IllegalAccessException在maven管理jar包的时候经常会出现，因为jar包冲突，或者没有部署到服务器上，都有可能会出现这个异常，但是具体情况具体分析。</p>
<p><img src="/2020/10/13/Java/JVM/jvm%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/QQ%E6%88%AA%E5%9B%BE20200901213325.png"></p>
<p>虚方法表在链接的解析阶段创建：将常量池内的符号引用（类、属性、方法的符号等）转换为直接引用的过程</p>
<p><img src="/2020/10/13/Java/JVM/jvm%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/QQ%E6%88%AA%E5%9B%BE20200901214008.png"></p>
<p><img src="/2020/10/13/Java/JVM/jvm%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/QQ%E6%88%AA%E5%9B%BE20200901214246.png"></p>
<p><img src="/2020/10/13/Java/JVM/jvm%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/QQ%E6%88%AA%E5%9B%BE20200901214339.png"></p>
<h3 id="方法返回地址"><a href="#方法返回地址" class="headerlink" title="方法返回地址"></a>方法返回地址</h3><p><img src="/2020/10/13/Java/JVM/jvm%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/QQ%E6%88%AA%E5%9B%BE20200901214828.png"></p>
<p>在一个A方法中调用了B方法，当B返回的时候，pc寄存器的值当作方法返回地址返回给A，A就按照下一条指令的地址执行B方法之后的代码，此处又分为异常退出和正常退出。</p>
<p><img src="/2020/10/13/Java/JVM/jvm%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/QQ%E6%88%AA%E5%9B%BE20200901215248.png"></p>
<p><img src="/2020/10/13/Java/JVM/jvm%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/QQ%E6%88%AA%E5%9B%BE20200901215555.png"></p>
<p><strong>引用类型时areturn</strong></p>
<p><img src="/2020/10/13/Java/JVM/jvm%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/QQ%E6%88%AA%E5%9B%BE20200901220306.png"></p>
<p><img src="/2020/10/13/Java/JVM/jvm%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/QQ%E6%88%AA%E5%9B%BE20200901220543.png"></p>
<h3 id="虚拟机栈的五道面试题"><a href="#虚拟机栈的五道面试题" class="headerlink" title="虚拟机栈的五道面试题"></a>虚拟机栈的五道面试题</h3><p><img src="/2020/10/13/Java/JVM/jvm%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/QQ%E6%88%AA%E5%9B%BE20200901222057.png"></p>
<h2 id="5-本地方法栈"><a href="#5-本地方法栈" class="headerlink" title="5.本地方法栈"></a>5.本地方法栈</h2><p><img src="/2020/10/13/Java/JVM/jvm%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/QQ%E6%88%AA%E5%9B%BE20200903210234.png"></p>
<p><img src="/2020/10/13/Java/JVM/jvm%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/QQ%E6%88%AA%E5%9B%BE20200903210521.png"></p>
<h2 id="6-本地方法接口"><a href="#6-本地方法接口" class="headerlink" title="6.本地方法接口"></a>6.本地方法接口</h2><p><img src="/2020/10/13/Java/JVM/jvm%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/QQ%E6%88%AA%E5%9B%BE20200903204113.png"></p>
<p><img src="/2020/10/13/Java/JVM/jvm%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/QQ%E6%88%AA%E5%9B%BE20200903204248.png"></p>
<p>native不意味着是抽象方法，和abstract关键字不能共用</p>
<p><img src="/2020/10/13/Java/JVM/jvm%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/QQ%E6%88%AA%E5%9B%BE20200903204917.png"></p>
<p><img src="/2020/10/13/Java/JVM/jvm%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/QQ%E6%88%AA%E5%9B%BE20200903205402.png"></p>
<p><img src="/2020/10/13/Java/JVM/jvm%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/QQ%E6%88%AA%E5%9B%BE20200903210042.png"></p>
<p><img src="/2020/10/13/Java/JVM/jvm%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/QQ%E6%88%AA%E5%9B%BE20200903211630.png"></p>
<h1 id="堆空间"><a href="#堆空间" class="headerlink" title="堆空间"></a>堆空间</h1><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h2><p>堆和方法区对一个进程来说，都是唯一的，一个进程就对应一个JVM的实例，一个JVM实例中就会有一个运行时数据区，一个进程有多个线程，所以线程共享一个堆空间和方法区</p>
<p><img src="/2020/10/13/Java/JVM/jvm%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/QQ%E6%88%AA%E5%9B%BE20200908193652.png"></p>
<p>-Xms 初始的堆内存空间；-Xmx最大允许的堆内存空间</p>
<p>在jdk自带的工具包中可以使用jvisualvm，可以查看运行的java进程</p>
<p><img src="/2020/10/13/Java/JVM/jvm%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/QQ%E6%88%AA%E5%9B%BE20200908194304.png"></p>
<p><img src="/2020/10/13/Java/JVM/jvm%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/QQ%E6%88%AA%E5%9B%BE20200908194454.png"></p>
<p>每个进程都各自有一份堆内存</p>
<p>堆内存逻辑上连续（实现比较简单，存储也比较高效），但是硬盘上不一定连续，物理内存和虚拟内存可以建立一张映射表，这张表，可以将物理上不连续的内存在虚拟内存中看作是连续的，方便存储数据。</p>
<p>上面所说的所有的线程都共享堆空间，那么这肯定会带来线程安全的问题，如果用同步的方式处理，堆空间的并发性就会变得非常差，如何处理？</p>
<blockquote>
<p>在堆空间中分配出一些小块，每个线程一人一份，每个小块就称为TLAB，在这里就体现了另外一点，就是并发性更好一些</p>
</blockquote>
<p><img src="/2020/10/13/Java/JVM/jvm%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/QQ%E6%88%AA%E5%9B%BE20200908195505.png"></p>
<p><strong>注意：</strong></p>
<p>①这里所说的是“几乎”所有的对象都会在堆内存中分配内存，表示还有一部份对象可能不会在堆内存中分配（还有可能在栈上分配）。</p>
<p>②堆中的对象不会在方法结束以后马上被移除，而是在垃圾回收的时候才会被移除。（在方法执行结束后对象依次弹出栈，但是是在GC中判断是否这两个对象当前是不是垃圾，等到相应的空间内存不足时JVM会主动的调用GC），如果是像我们所理解的方法执行结束就进行垃圾回收，那这样的话，垃圾回收的频率就会特别高，会影响用户线程去执行（在《深入java虚拟机》中提到的“stop the world”的问题就出现了）</p>
<p><img src="/2020/10/13/Java/JVM/jvm%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/QQ%E6%88%AA%E5%9B%BE20200908200119.png"></p>
<p>堆空间中的实例，所属的类类型信息，以及类中的方法都存放于方法区中</p>
<p><img src="/2020/10/13/Java/JVM/jvm%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/QQ%E6%88%AA%E5%9B%BE20200908201147.png"></p>
<p>一旦执行了new这个字节码指令的时候，就会在堆空间中创建对象，开辟空间，之后JVM为堆空间的实例变量初始化。</p>
<h2 id="2-内存细分"><a href="#2-内存细分" class="headerlink" title="2.内存细分"></a>2.内存细分</h2><p>分代垃圾回收算法就是针对于堆的分代来讲的</p>
<p><img src="/2020/10/13/Java/JVM/jvm%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/QQ%E6%88%AA%E5%9B%BE20200908201845.png"></p>
<p>现在所说的堆空间，主要就分为了新生区和养老区，这里所说的永久区是在方法区中的实现。</p>
<p>上文所看的对的内存分配的图可以看出</p>
<p><img src="/2020/10/13/Java/JVM/jvm%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/QQ%E6%88%AA%E5%9B%BE20200908194454.png"></p>
<p>堆内存中只有新生代和老年代，并没有所谓的永久区。</p>
<p><img src="/2020/10/13/Java/JVM/jvm%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/QQ%E6%88%AA%E5%9B%BE20200908202845.png"></p>
<p>运行java程序时指定：-XX: +PrintGCDetails，即可打印垃圾回收器的执行细节</p>
<p><img src="/2020/10/13/Java/JVM/jvm%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/QQ%E6%88%AA%E5%9B%BE20200908203214.png"></p>
<p><img src="/2020/10/13/Java/JVM/jvm%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/QQ%E6%88%AA%E5%9B%BE20200908203402.png"></p>
<h2 id="3-堆空间的大小的设置和查看"><a href="#3-堆空间的大小的设置和查看" class="headerlink" title="3.堆空间的大小的设置和查看"></a>3.堆空间的大小的设置和查看</h2><p><img src="/2020/10/13/Java/JVM/jvm%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/QQ%E6%88%AA%E5%9B%BE20200908203548.png"></p>
<p>这里所说的指令，也可以使用等价于后面的哪个指令，他们的效果是一样的。</p>
<p><img src="/2020/10/13/Java/JVM/jvm%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/QQ%E6%88%AA%E5%9B%BE20200908204058.png"></p>
<p>默认情况下，对内存的初始化大小是……最大内存大小是……</p>
<p>但是，一般情况而言，这里的内存总是会比电脑的实际内存要小一点：原因之一是实际上使用的时候，有很多必须要加载的数据，他要占用一点内存。</p>
<p>再手动设置堆内存的大小的时候，通常将最大值和最小值设置成一样大小的值：初始的时候要设置的一个值之后，如果堆空间不够会进行扩容，后续如果内存用不到，他也会往下降，我们如果在服务器中不设置成一样大小的值，就会出现频繁的扩容和释放的情况，会造成不必要的系统的压力。</p>
<p>出现的一个问题？这个数怎么算出来的？</p>
<p><img src="/2020/10/13/Java/JVM/jvm%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/QQ%E6%88%AA%E5%9B%BE20200908205429.png"></p>
<p>查看设置的参数，方式一、<code>JPS</code>        <code>jstat -gc 进程ID</code></p>
<p><img src="/2020/10/13/Java/JVM/jvm%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/QQ%E6%88%AA%E5%9B%BE20200908205803.png"></p>
<p>老年代：OC(其中C是总量)     OU(U是use)</p>
<p>伊甸园区：EC    EU</p>
<p>幸存者区：S0C    S1C    S0U    S1U</p>
<p>将各个区域的总量加起来（S0C+S1C+EC+OC/1024），发现正好是600M，那为什么在上面的程序中是575呢？</p>
<blockquote>
<p>伊甸园区能放对象，S0C或者S1C他们只能二选一的去用，所以如果少加一个S区，会发现，正好是575，主要用到的是垃圾回收，新生代使用的复制算法，S0C、S1C他俩始终有一个区域是空的</p>
</blockquote>
<p>方式二、运行java程序的时候加上<code>-XX: +PrintGCDetails </code></p>
<p><img src="/2020/10/13/Java/JVM/jvm%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/QQ%E6%88%AA%E5%9B%BE20200908211214.png"></p>
<p>其中PSYoungGen中的total是通过eden总量加上from/to其中一个得出。</p>
<h2 id="4-oom的说明和举例"><a href="#4-oom的说明和举例" class="headerlink" title="4.oom的说明和举例"></a>4.oom的说明和举例</h2><p>关于异常相关的类叫做Throwable</p>
<p><img src="/2020/10/13/Java/JVM/jvm%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/QQ%E6%88%AA%E5%9B%BE20200910192655.png"></p>
<p>我们这里所说的oom指的是 error，在面试中我们讲到的异常，实际上就是Throwable（包括Error或者Exception）</p>
<p><img src="/2020/10/13/Java/JVM/jvm%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/QQ%E6%88%AA%E5%9B%BE20200910193856.png"></p>
<h2 id="5-年轻代与老年代中相关参数的设置"><a href="#5-年轻代与老年代中相关参数的设置" class="headerlink" title="5.年轻代与老年代中相关参数的设置"></a>5.年轻代与老年代中相关参数的设置</h2><p><img src="/2020/10/13/Java/JVM/jvm%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/QQ%E6%88%AA%E5%9B%BE20200910194125.png"></p>
<p>注意：幸存者0区不一定是from 1区也不一定就是to</p>
<p>前面我们讲到了设置堆空间的大小，那么如何控制新生代和老年代的大小呢？</p>
<p><img src="/2020/10/13/Java/JVM/jvm%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/QQ%E6%88%AA%E5%9B%BE20200910194801.png"></p>
<p>-XX：NewRatio   设置新生代和老年代的比例。默认值是2，一般情况下不会去修改这个空间的。</p>
<p>如果你知道有很多对象声明周期比较长，这个时候你就可以把老年代的空间调大一点</p>
<p><img src="/2020/10/13/Java/JVM/jvm%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/QQ%E6%88%AA%E5%9B%BE20200910195546.png"></p>
<p>伊甸园区和幸存者0、1区的比例在官方给出的默认值是8：1：1，但是我们在jvisualvm中看到的却是下图所示的结果</p>
<p><img src="/2020/10/13/Java/JVM/jvm%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/QQ%E6%88%AA%E5%9B%BE20200910195925.png"></p>
<p>这是为什么？</p>
<blockquote>
<p>所以我们想到jvm底层有一个自适应的机制，可以使用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">-XX:-UseAdaptiveSizePolicy <span class="comment">// 减号代表关闭自适应</span></span><br></pre></td></tr></table></figure>

<p>但是我们操作了之后，发现还是不起效果。</p>
<p>要想比例是原来默认的8：1：1，我们仍需要显示地指定一下才行。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">-XX:SurvivorRatio=<span class="number">8</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p><img src="/2020/10/13/Java/JVM/jvm%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/QQ%E6%88%AA%E5%9B%BE20200910200827.png"></p>
<p>注意：设置了NewRatio制定了新生代和老年代的比例，又设置了-Xmn参数，这时候就会有矛盾，以-Xmn为准（-Xmn一般不设置）</p>
<p><img src="/2020/10/13/Java/JVM/jvm%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/QQ%E6%88%AA%E5%9B%BE20200910201007.png"></p>
<h2 id="6-对象分配的过程"><a href="#6-对象分配的过程" class="headerlink" title="6.对象分配的过程"></a>6.对象分配的过程</h2><p><img src="/2020/10/13/Java/JVM/jvm%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/QQ%E6%88%AA%E5%9B%BE20200910201513.png"></p>
<p><img src="/2020/10/13/Java/JVM/jvm%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/QQ%E6%88%AA%E5%9B%BE20200910204209.png"></p>
<p>对象刚开始放在伊甸园区，如果伊甸园区放满了，这时候会进行垃圾回收（YGC/Minor GC）,那谁是垃圾，谁不是垃圾，怎么进行判断，（涉及到引用计数算法、可达性分析算法，在java中我们使用后者）</p>
<p>  垃圾回收完成之后，如果还有对象被引用，这时候就把存活的对象放进幸存者区（s0、s1都是空的，这时候先把他放在0区，为幸存的对象的年龄计数器赋值为1）</p>
<p><img src="/2020/10/13/Java/JVM/jvm%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/QQ%E6%88%AA%E5%9B%BE20200910202357.png"></p>
<p><img src="/2020/10/13/Java/JVM/jvm%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/QQ%E6%88%AA%E5%9B%BE20200910202834.png"></p>
<p>这个to表示，下一次YGC的时候，一点远去的对象要往哪里放</p>
<p><img src="/2020/10/13/Java/JVM/jvm%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/QQ%E6%88%AA%E5%9B%BE20200910203220.png"></p>
<p>这里有个问题，伊甸园区空间放满了的时候，触发YGC，我们知道伊甸园区和幸存者区的比利时8：1：1，那万一幸存者区满了怎么办？会触发YGC吗？</p>
<blockquote>
<p>不会触发，这不意味着幸存者区不会有垃圾回收（当伊甸园区发生YGC的时候，伊甸园区和幸存者区都会发生垃圾回收），幸存者区满了，这里会存在特殊的规则（会直接晋升到老年代）</p>
</blockquote>
<p>有没有可能对象一上来就被分配到老年代？</p>
<blockquote>
<p>有可能的，对象所占用的内存比较大的情况</p>
</blockquote>
<p><img src="/2020/10/13/Java/JVM/jvm%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/QQ%E6%88%AA%E5%9B%BE20200910204331.png"></p>
<h2 id="7-对象分配的特殊过程"><a href="#7-对象分配的特殊过程" class="headerlink" title="7.对象分配的特殊过程"></a>7.对象分配的特殊过程</h2><p>注意，YGC之后，Eden区一定是空的，如果这个时候Eden区还是放不下的话，那只有可能对象是超大对象，这时候会考虑直接一步到老年区是不是能够放下这个对象，如果这个时候放不下，会Full GC（Major GC），如果还是放不下那么就OOM。</p>
<p><img src="/2020/10/13/Java/JVM/jvm%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/QQ%E6%88%AA%E5%9B%BE20200915192906.png"></p>
<h2 id="8-常用的调优工具"><a href="#8-常用的调优工具" class="headerlink" title="8.常用的调优工具"></a>8.常用的调优工具</h2><p><img src="/2020/10/13/Java/JVM/jvm%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/QQ%E6%88%AA%E5%9B%BE20200915193544.png"></p>
<p>电脑上安装Jprofiler</p>
<p>idea下载Jprofiler插件</p>
<p><img src="/2020/10/13/Java/JVM/jvm%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/QQ%E6%88%AA%E5%9B%BE20200915194015.png"></p>
<h2 id="9-Minor-GC-，Full-GC和Major-Gc的对比"><a href="#9-Minor-GC-，Full-GC和Major-Gc的对比" class="headerlink" title="9.Minor GC ，Full GC和Major Gc的对比"></a>9.Minor GC ，Full GC和Major Gc的对比</h2><p>YGC == Minor GC</p>
<p>调优的目的就是希望垃圾回收的次数少一些，注意的是，Major GC和Full GC所占用时间比Minor GC占用的时间多十倍以上（出现“Stop The World”）。</p>
<p><img src="/2020/10/13/Java/JVM/jvm%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/QQ%E6%88%AA%E5%9B%BE20200915194554.png"></p>
<p>上图中所说的三个内存区域分别指的是：新生代、老年代；方法区。</p>
<p><img src="/2020/10/13/Java/JVM/jvm%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/QQ%E6%88%AA%E5%9B%BE20200915195436.png"></p>
<p>但是因为新生代比较小的原因，“STW”的时间也不会很长，虽然频率特别高，但是执行的速度特别快。</p>
<p>为什么会有STW:</p>
<p>如果出现，垃圾回收的线程和制造垃圾的线程同时运行，在垃圾回收线程判断完那个是垃圾，准备回收垃圾的时候，制造垃圾的线程这时候又制造了几个对象， 不知道是不是垃圾，这个时候就不合适了。</p>
<p><img src="/2020/10/13/Java/JVM/jvm%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/QQ%E6%88%AA%E5%9B%BE20200915200107.png"></p>
<p><img src="/2020/10/13/Java/JVM/jvm%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/QQ%E6%88%AA%E5%9B%BE20200915200311.png"></p>
<p>Full GC覆盖了整个堆空间，包括我们所讲的方法区。</p>
<h2 id="10-GC举例和日志分析"><a href="#10-GC举例和日志分析" class="headerlink" title="10.GC举例和日志分析"></a>10.GC举例和日志分析</h2><p>字符串常量池是存放在堆空间的，在jdk8之后修改成了存放在堆空间，以前是在方法区。</p>
<p>堆空间报OOM之前通常会进行一次Full GC，垃圾回收之后仍然发现空间不足，才会报这个OOM</p>
<p><img src="/2020/10/13/Java/JVM/jvm%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/QQ%E6%88%AA%E5%9B%BE20200915201539.png"></p>
<p><img src="/2020/10/13/Java/JVM/jvm%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/QQ%E6%88%AA%E5%9B%BE20200915201834.png"></p>
<p>后面的secs是此次GC花费的时间</p>
<h2 id="11-小结内存分配的策略"><a href="#11-小结内存分配的策略" class="headerlink" title="11.小结内存分配的策略"></a>11.小结内存分配的策略</h2><p>​    为什么要将java堆分代，分代的好处是什么？</p>
<p>为了优化GC的性能</p>
<p><img src="/2020/10/13/Java/JVM/jvm%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/QQ%E6%88%AA%E5%9B%BE20200917191004.png"></p>
<p>一些不容易销毁的对象放在老年代中，不让他进行频繁的垃圾回收，这样就可以优化性能</p>
<p><img src="/2020/10/13/Java/JVM/jvm%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/QQ%E6%88%AA%E5%9B%BE20200917191547.png"></p>
<p><img src="/2020/10/13/Java/JVM/jvm%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/QQ%E6%88%AA%E5%9B%BE20200917192109.png"></p>
<p>注意：如果年龄相同的所有对象的综合大于Survivor中空间的一般，这些对象就可以直接进入老年代，空间分配担保指的是进行了minor GC之后，对象在Survivor中放不下，这时候就会直接进入老年代，但是它的前提是老年代必须有这个空间来容纳这个对象（需要用到-XX:HandlePromotionFailure）</p>
<p><img src="/2020/10/13/Java/JVM/jvm%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/QQ%E6%88%AA%E5%9B%BE20200917193154.png"></p>
<h2 id="12-堆空间为每个线程分配的TLAB"><a href="#12-堆空间为每个线程分配的TLAB" class="headerlink" title="12.堆空间为每个线程分配的TLAB"></a>12.堆空间为每个线程分配的TLAB</h2><p><img src="/2020/10/13/Java/JVM/jvm%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/QQ%E6%88%AA%E5%9B%BE20200917193348.png"></p>
<p>那么这个时候TLAB就应运而生</p>
<p><img src="/2020/10/13/Java/JVM/jvm%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/QQ%E6%88%AA%E5%9B%BE20200917193602.png"></p>
<p><img src="/2020/10/13/Java/JVM/jvm%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/QQ%E6%88%AA%E5%9B%BE20200917193746.png"></p>
<p><img src="/2020/10/13/Java/JVM/jvm%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/QQ%E6%88%AA%E5%9B%BE20200917193935.png"></p>
<p><img src="/2020/10/13/Java/JVM/jvm%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/QQ%E6%88%AA%E5%9B%BE20200917194447.png"></p>
<p>所以在面试中就会有个问题，堆空间的内存都是共享的吗？</p>
<p>不一定，因为Eden区为每个线程分配了TLAB。</p>
<h2 id="13-总结"><a href="#13-总结" class="headerlink" title="13.总结"></a>13.总结</h2><p>小结堆空间的参数设置</p>
<p><img src="/2020/10/13/Java/JVM/jvm%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/QQ%E6%88%AA%E5%9B%BE20200917194925.png"></p>
<p>如果Eden区设置的比较大，会出现什么问题？</p>
<blockquote>
<p>Eden区太大，Survivor就会比较小，那么当进行YGC的时候，Survivor只能存放一小部分的对象，这会导致某一部分的对象，直接就进入Old区，即时这个对象的生命周期非常短，这样不利于系统性能 （导致minor GC失去意义了）</p>
</blockquote>
<p>Eden区设置的不够大，Survivor设置的反而比较大，出现的问题？</p>
<blockquote>
<p>YGC触发地更加频繁，会影响用户线程</p>
</blockquote>
<p>关于参数<code>-XX:HandlePromotionFailure</code>的说明：</p>
<p><img src="/2020/10/13/Java/JVM/jvm%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/QQ%E6%88%AA%E5%9B%BE20200917200829.png"></p>
<h2 id="14-拓展"><a href="#14-拓展" class="headerlink" title="14.拓展"></a>14.拓展</h2><p>堆是分配对象存储的唯一选择吗？</p>
<p>我们堆JVM性能地调优，主要是针对于老年代的GC，因为老年代的GC的‘STW’时间比较长</p>
<p><img src="/2020/10/13/Java/JVM/jvm%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/QQ%E6%88%AA%E5%9B%BE20200917201312.png"></p>
<p>最终目的都是希望在堆上分配的对象少一些（因为不用进行垃圾回收）</p>
<h1 id="代码优化"><a href="#代码优化" class="headerlink" title="代码优化"></a>代码优化</h1><h2 id="栈上分配"><a href="#栈上分配" class="headerlink" title="栈上分配"></a>栈上分配</h2><p>通过逃逸分析，发现对象没有逃逸的，才作为栈上分配</p>
<p><img src="/2020/10/13/Java/JVM/jvm%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/QQ%E6%88%AA%E5%9B%BE20200922185900.png"></p>
<p>逃逸：通常是返回一个对象，这个对象在另一个方法外可能会被使用得到，此时就分配在堆空间中</p>
<p>开启逃逸分析：<code>-XX:+DoEscapeAnalysis</code>,（当开启逃逸分析的时候，如果对象没有发生逃逸，那么就会考虑栈上分配）关闭逃逸分析：<code>-XX:-DoEscapeAnalysis</code>。（JDK7之后默认是开启的）</p>
<p>当开启逃逸分析的时候，因为是在站上分配的，所以根本不会发生GC,真正维护的对象的个数也不足我们创建的个数</p>
<h2 id="同步省略"><a href="#同步省略" class="headerlink" title="同步省略"></a>同步省略</h2><p>如果一个对象被发现只能从一个线程被访问到，那么对于这个对象的操作可以考虑不同步</p>
<p><img src="/2020/10/13/Java/JVM/jvm%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/QQ%E6%88%AA%E5%9B%BE20200922191114.png"></p>
<p>就是说，如果一个对象没有发生逃逸，就没有必要使用加锁，因为他根本就不会被其他线程访问到</p>
<p><img src="/2020/10/13/Java/JVM/jvm%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/QQ%E6%88%AA%E5%9B%BE20200922191319.png"></p>
<p>上面的方法，每次线程调用方法是，对象总是自己new出来的，所以这时候加锁就没有必要。JVM虚拟机有了逃逸分析，会自动帮你确定</p>
<p><img src="/2020/10/13/Java/JVM/jvm%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/QQ%E6%88%AA%E5%9B%BE20200922191857.png"></p>
<p>只是在运行的时候，才考虑把它去掉，加载的时候还是会加载原来的文件</p>
<h2 id="标量替换"><a href="#标量替换" class="headerlink" title="标量替换"></a>标量替换</h2><p><img src="/2020/10/13/Java/JVM/jvm%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/QQ%E6%88%AA%E5%9B%BE20200922192101.png"></p>
<p>对象被称作聚合量，聚合量可以分解成最小的标量，标量是不可以再分的量</p>
<p><img src="/2020/10/13/Java/JVM/jvm%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/QQ%E6%88%AA%E5%9B%BE20200922192240.png"></p>
<p><img src="/2020/10/13/Java/JVM/jvm%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/QQ%E6%88%AA%E5%9B%BE20200922192511.png"></p>
<p>相当于，将对象拆解开来，分散在栈上</p>
<p>开启标量替换<code>-XX:+EliminateAllocations</code></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>堆空间是对象分配地唯一选择吗？</p>
<p>逃逸分析在java地服务器端模式才会开启的。</p>
<p>逃逸分析本身并不成熟，分析逃逸分析，无法保证其本身的性能一定高于它的消耗，如果经过逃逸分析，发现没有一个对象是不逃逸的，那么逃逸分析的性能就被白白浪费掉了。</p>
<p><img src="/2020/10/13/Java/JVM/jvm%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/QQ%E6%88%AA%E5%9B%BE20200922193736.png"></p>
<p>注意：这里所说的所有对象都创建在堆上，这是正确的。这里我们先否定了所有的对象都是分配在堆上的，这里我们有否定了。</p>
<p><img src="/2020/10/13/Java/JVM/jvm%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/QQ%E6%88%AA%E5%9B%BE20200922193954.png"></p>
<h1 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h1><h2 id="栈、堆、方法区的关系"><a href="#栈、堆、方法区的关系" class="headerlink" title="栈、堆、方法区的关系"></a>栈、堆、方法区的关系</h2><p><img src="/2020/10/13/Java/JVM/jvm%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/QQ%E6%88%AA%E5%9B%BE20200922194757.png"></p>
<p><img src="/2020/10/13/Java/JVM/jvm%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/QQ%E6%88%AA%E5%9B%BE20200922195203.png"></p>
<h2 id="方法区的理解"><a href="#方法区的理解" class="headerlink" title="方法区的理解"></a>方法区的理解</h2><p>逻辑上我们把方法区当作堆的一部分，但是实际上，方法区的简单实现既没有GC，也没有压缩。</p>
<p><img src="/2020/10/13/Java/JVM/jvm%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/QQ%E6%88%AA%E5%9B%BE20200922200314.png"></p>
<p><img src="/2020/10/13/Java/JVM/jvm%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/QQ%E6%88%AA%E5%9B%BE20200922200419.png"></p>
<p>在实际操作过程中，我们设置堆空间的大小的情况下，实际上也没有影响到方法区空间的大小</p>
<p><img src="/2020/10/13/Java/JVM/jvm%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/QQ%E6%88%AA%E5%9B%BE20200922200910.png"></p>
<p>因为是共享的，在加载类得对象的时候，多个线程加载对象，只有一个对象可以被加载，其他的线程都必须等待。</p>
<p>如果加载了过多的第三方jar包，这个时候就可能出现oom；Tomcat部署的应用程序太多；大量动态地生成反射类</p>
<h2 id="Hotspot中方法区的演进"><a href="#Hotspot中方法区的演进" class="headerlink" title="Hotspot中方法区的演进"></a>Hotspot中方法区的演进</h2><p><img src="/2020/10/13/Java/JVM/jvm%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/QQ%E6%88%AA%E5%9B%BE20200924190716.png"></p>
<p>注意，方法区说成永久代，主要是对于hotspot而言的。</p>
<p>永久代仍然使用的是java虚拟机的内存，更容易oom。</p>
<p><img src="/2020/10/13/Java/JVM/jvm%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/QQ%E6%88%AA%E5%9B%BE20200924191817.png"></p>
<p>生产JRockit的BEA公司被Oracle公司收购，JRockit是世界上公认的最快的虚拟机。</p>
<p>注意：方法区无法满足新的内存分配需求时，将会抛出OOM异常，即使它使用的是本地内存。</p>
<h2 id="设置方法区的大小"><a href="#设置方法区的大小" class="headerlink" title="设置方法区的大小"></a>设置方法区的大小</h2><p><img src="/2020/10/13/Java/JVM/jvm%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/QQ%E6%88%AA%E5%9B%BE20200924192503.png"></p>
<p><img src="/2020/10/13/Java/JVM/jvm%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/QQ%E6%88%AA%E5%9B%BE20200924192926.png"></p>
<p><img src="/2020/10/13/Java/JVM/jvm%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/QQ%E6%88%AA%E5%9B%BE20200924193054.png"></p>
<p>如果想要设置参数：</p>
<p><img src="/2020/10/13/Java/JVM/jvm%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/QQ%E6%88%AA%E5%9B%BE20200924193607.png"></p>
<p>如果在jdk8当中设置jdk7中设置的<code>PermSize</code>会报错。</p>
<p><img src="/2020/10/13/Java/JVM/jvm%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/QQ%E6%88%AA%E5%9B%BE20200924193820.png"></p>
<h2 id="如果解决oom的问题"><a href="#如果解决oom的问题" class="headerlink" title="如果解决oom的问题"></a>如果解决oom的问题</h2><p><img src="/2020/10/13/Java/JVM/jvm%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/QQ%E6%88%AA%E5%9B%BE20200924194747.png"></p>
<p>内存泄露：堆中有对象，栈中存在着引用指向他，但是这个数据我们也没有使用，因为它始终和GC Roots有过关联，所以会导致这个对象始终不会被回收，这样的对象多了之后，就造成了OOM。</p>
<h2 id="方法区的内部结构"><a href="#方法区的内部结构" class="headerlink" title="方法区的内部结构"></a>方法区的内部结构</h2><p><img src="/2020/10/13/Java/JVM/jvm%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/QQ%E6%88%AA%E5%9B%BE20200924195511.png"></p>
<p><img src="/2020/10/13/Java/JVM/jvm%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/QQ%E6%88%AA%E5%9B%BE20200924195645.png"></p>
<p><img src="/2020/10/13/Java/JVM/jvm%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/QQ%E6%88%AA%E5%9B%BE20200924195959.png"></p>
<p><img src="/2020/10/13/Java/JVM/jvm%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/QQ%E6%88%AA%E5%9B%BE20200924200031.png"></p>
<p><img src="/2020/10/13/Java/JVM/jvm%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/QQ%E6%88%AA%E5%9B%BE20200924200215.png"></p>
<p>字节码文件是通过类的加载器加载进来的，所以方法区中还存放了这个字节码文件是由那个类加载器加载进来的，这个classLoader也会记载他加载过谁（彼此互相记录）。</p>
<p><img src="/2020/10/13/Java/JVM/jvm%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/QQ%E6%88%AA%E5%9B%BE20200924201850.png"></p>
<p><img src="/2020/10/13/Java/JVM/jvm%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/QQ%E6%88%AA%E5%9B%BE20200924201952.png"></p>
<p><img src="/2020/10/13/Java/JVM/jvm%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/QQ%E6%88%AA%E5%9B%BE20200924202428.png"></p>
<h2 id="class文件中常量池的理解"><a href="#class文件中常量池的理解" class="headerlink" title="class文件中常量池的理解"></a>class文件中常量池的理解</h2><p><img src="/2020/10/13/Java/JVM/jvm%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/QQ%E6%88%AA%E5%9B%BE20200929190639.png"></p>
<p><img src="/2020/10/13/Java/JVM/jvm%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/QQ%E6%88%AA%E5%9B%BE20200929191119.png"></p>
<p><img src="/2020/10/13/Java/JVM/jvm%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/QQ%E6%88%AA%E5%9B%BE20200929191234.png"></p>
<p><img src="/2020/10/13/Java/JVM/jvm%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/QQ%E6%88%AA%E5%9B%BE20200929191929.png"></p>
<p>这还仅仅只是一个方法中的符号引用，如果不把他们管理起来的话，每个方法中都有这个结构的话，字节码文件就会非常的大了。我们使用的方法的相关细节都是从常量池中调用的</p>
<p><img src="/2020/10/13/Java/JVM/jvm%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/QQ%E6%88%AA%E5%9B%BE20200929192449.png"></p>
<h2 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h2><p><img src="/2020/10/13/Java/JVM/jvm%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/QQ%E6%88%AA%E5%9B%BE20200929192654.png"></p>
<p>字节码中的常量池通过类的加载器放在内存中以后，对应的这个结构称为运行时常量池，运行时常量池就是字节码文件当中每一个类或者接口对应的常量池表对应的一个运行时候的表示形式。并且，运行时常量池具有动态性。</p>
<p>这里所说的动态性的一个具体例子就是String.intern()方法。</p>
<h2 id="图示方法区的使用"><a href="#图示方法区的使用" class="headerlink" title="图示方法区的使用"></a>图示方法区的使用</h2><p><img src="/2020/10/13/Java/JVM/jvm%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/QQ%E6%88%AA%E5%9B%BE20200929194158.png"></p>
<p>针对上图执行过程图示如下</p>
<p><img src="/2020/10/13/Java/JVM/jvm%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/QQ%E6%88%AA%E5%9B%BE20200929194346.png"></p>
<p><img src="/2020/10/13/Java/JVM/jvm%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/QQ%E6%88%AA%E5%9B%BE20200929194446.png"></p>
<p><img src="/2020/10/13/Java/JVM/jvm%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/QQ%E6%88%AA%E5%9B%BE20200929194500.png"></p>
<p><img src="/2020/10/13/Java/JVM/jvm%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/QQ%E6%88%AA%E5%9B%BE20200929194531.png"></p>
<p><img src="/2020/10/13/Java/JVM/jvm%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/QQ%E6%88%AA%E5%9B%BE20200929194549.png"></p>
<p><img src="/2020/10/13/Java/JVM/jvm%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/QQ%E6%88%AA%E5%9B%BE20200929194758.png"></p>
<p><img src="/2020/10/13/Java/JVM/jvm%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/QQ%E6%88%AA%E5%9B%BE20200929194826.png"></p>
<p><img src="/2020/10/13/Java/JVM/jvm%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/QQ%E6%88%AA%E5%9B%BE20200929195121.png"></p>
<p><img src="/2020/10/13/Java/JVM/jvm%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/QQ%E6%88%AA%E5%9B%BE20200929195145.png"></p>
<p><img src="/2020/10/13/Java/JVM/jvm%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/QQ%E6%88%AA%E5%9B%BE20200929195221.png"></p>
<p><img src="/2020/10/13/Java/JVM/jvm%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/QQ%E6%88%AA%E5%9B%BE20200929195245.png"></p>
<h2 id="方法区的演进细节"><a href="#方法区的演进细节" class="headerlink" title="方法区的演进细节"></a>方法区的演进细节</h2><p><img src="/2020/10/13/Java/JVM/jvm%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/QQ%E6%88%AA%E5%9B%BE20201004180851.png"></p>
<p>方法区存储的经典结构如上所示，但是jdk在不同版本的演进当中，方法区的实现也发生了一些变化。</p>
<p><img src="/2020/10/13/Java/JVM/jvm%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/QQ%E6%88%AA%E5%9B%BE20201004181010.png"></p>
<p>注意的是：jdk8之后，网上很多帖子或者书中，说的是静态变量放到了元空间中，实际上仍然在堆中。</p>
<p><img src="/2020/10/13/Java/JVM/jvm%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/QQ%E6%88%AA%E5%9B%BE20201004181842.png"></p>
<p><img src="/2020/10/13/Java/JVM/jvm%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/QQ%E6%88%AA%E5%9B%BE20201004181912.png"></p>
<p><img src="/2020/10/13/Java/JVM/jvm%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/QQ%E6%88%AA%E5%9B%BE20201004181925.png"></p>
<p>永久代为什么要被元空间替换呢？</p>
<blockquote>
<p>相当于把jRockit和J9虚拟机结合hotspot虚拟机了，JRockit认为方法区中的类信息和方法信息等，生命周期比较长，所以把他放在虚拟机内存之外，而hotspot虚拟机则是所有的内存都有我自己来分配（完全受虚拟机控制）</p>
<p><img src="/2020/10/13/Java/JVM/jvm%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/QQ%E6%88%AA%E5%9B%BE20201004182516.png"></p>
</blockquote>
<p>为什么JRockit没有永久代？</p>
<p><img src="/2020/10/13/Java/JVM/jvm%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/QQ%E6%88%AA%E5%9B%BE20201004182834.png"></p>
<p>判断常量或者类是否需要再被使用其实也挺花时间的。</p>
<h2 id="StringTable为什么要调整位置"><a href="#StringTable为什么要调整位置" class="headerlink" title="StringTable为什么要调整位置"></a>StringTable为什么要调整位置</h2><p><img src="/2020/10/13/Java/JVM/jvm%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/QQ%E6%88%AA%E5%9B%BE20201004184629.png"></p>
<h2 id="如何证明静态变量的位置？"><a href="#如何证明静态变量的位置？" class="headerlink" title="如何证明静态变量的位置？"></a>如何证明静态变量的位置？</h2><p>使用JHSDB（JDK9引入的工具）：监控进程的细节</p>
<p><img src="/2020/10/13/Java/JVM/jvm%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/QQ%E6%88%AA%E5%9B%BE20201004185504.png"></p>
<p><img src="/2020/10/13/Java/JVM/jvm%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/QQ%E6%88%AA%E5%9B%BE20201004185739.png"></p>
<p>上图证明的是，三个对象的实体都是放在堆空间当中的（只要是new的对象都放在堆空间当中）</p>
<p><img src="/2020/10/13/Java/JVM/jvm%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/QQ%E6%88%AA%E5%9B%BE20201004190030.png"></p>
<h2 id="方法区的垃圾回收行为"><a href="#方法区的垃圾回收行为" class="headerlink" title="方法区的垃圾回收行为"></a>方法区的垃圾回收行为</h2><p><img src="/2020/10/13/Java/JVM/jvm%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/QQ%E6%88%AA%E5%9B%BE20201013184715.png"></p>
<p>如果不进行gc的话，就真的成了永久代了（永久也仅限于当前的进程存在的生命周期之内），方法区的垃圾回收也主要是针对于针对运行时常量池和类型信息</p>
<p><img src="/2020/10/13/Java/JVM/jvm%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/QQ%E6%88%AA%E5%9B%BE20201013185607.png"></p>
<p><img src="/2020/10/13/Java/JVM/jvm%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/QQ%E6%88%AA%E5%9B%BE20201013185656.png"></p>
<p>类的卸载实际上是很苛刻的。</p>
<h1 id="总结：运行时数据区"><a href="#总结：运行时数据区" class="headerlink" title="总结：运行时数据区"></a>总结：运行时数据区</h1><p><img src="/2020/10/13/Java/JVM/jvm%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/QQ%E6%88%AA%E5%9B%BE20201013190547.png"></p>
<p><img src="/2020/10/13/Java/JVM/jvm%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/QQ%E6%88%AA%E5%9B%BE20201013190742.png"></p>
<p><img src="/2020/10/13/Java/JVM/jvm%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/QQ%E6%88%AA%E5%9B%BE20201013190804.png"></p>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
</search>
