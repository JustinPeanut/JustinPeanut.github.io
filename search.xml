<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>LOL-show项目工程日志</title>
    <url>/2020/08/30/LOL-show%E9%A1%B9%E7%9B%AE%E5%B7%A5%E7%A8%8B%E6%97%A5%E5%BF%97/</url>
    <content><![CDATA[<h1 id="初衷"><a href="#初衷" class="headerlink" title="初衷"></a>初衷</h1><p>  在我学习完了ssm框架，以及跟着B站视频练习了一个<code>尚筹网</code>的项目之后，准备在暑假巩固所学的框架搭建过程，以及业务逻辑、数据库建表、前端页面的知识，本人喜欢打游戏，所以便有了LOL-show这个项目。</p>
<p>如果你想要学习该项目，那么你可以访问我的github！</p>
<a id="more"></a>

<h1 id="工程结构"><a href="#工程结构" class="headerlink" title="工程结构"></a>工程结构</h1><p><img src="/2020/08/30/LOL-show%E9%A1%B9%E7%9B%AE%E5%B7%A5%E7%A8%8B%E6%97%A5%E5%BF%97/LOL-show-%E5%B7%A5%E7%A8%8B%E5%9B%BE.png"></p>
<p>端口号规定：</p>
<p>eureka:1000</p>
<p>zuul:80</p>
<p>mysql:2000</p>
<p>redis:3000</p>
<p>hero:4000</p>
<p>member:5000</p>
<p>market:6000</p>
<p>order:7000</p>
<p>pay:8000</p>
<h1 id="数据库建表语句"><a href="#数据库建表语句" class="headerlink" title="数据库建表语句"></a>数据库建表语句</h1><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> lol_area(</span><br><span class="line"><span class="keyword">id</span> <span class="built_in">int</span>(<span class="number">11</span>) auto_increment,</span><br><span class="line">area_name <span class="built_in">varchar</span>(<span class="number">100</span>) <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">primary <span class="keyword">key</span>(<span class="keyword">id</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> lol_area(area_name)</span><br><span class="line"> <span class="keyword">values</span></span><br><span class="line"> (<span class="string">&quot;比尔吉沃特&quot;</span>),</span><br><span class="line"> (<span class="string">&quot;德玛西亚&quot;</span>),</span><br><span class="line"> (<span class="string">&quot;弗雷尔卓德&quot;</span>),</span><br><span class="line"> (<span class="string">&quot;无畏先锋&quot;</span>),</span><br><span class="line"> (<span class="string">&quot;恕瑞玛&quot;</span>),</span><br><span class="line"> (<span class="string">&quot;扭曲丛林&quot;</span>),</span><br><span class="line"> (<span class="string">&quot;巨龙之巢&quot;</span>),</span><br><span class="line"> (<span class="string">&quot;艾欧尼亚&quot;</span>),</span><br><span class="line"> (<span class="string">&quot;祖安&quot;</span>),</span><br><span class="line"> (<span class="string">&quot;诺克萨斯&quot;</span>),</span><br><span class="line"> (<span class="string">&quot;班德尔城&quot;</span>),</span><br><span class="line"> (<span class="string">&quot;皮尔特沃夫&quot;</span>),</span><br><span class="line"> (<span class="string">&quot;皮尔特沃夫&quot;</span>),</span><br><span class="line"> (<span class="string">&quot;战争学院&quot;</span>),</span><br><span class="line"> (<span class="string">&quot;巨神峰&quot;</span>),</span><br><span class="line"> (<span class="string">&quot;雷瑟守备&quot;</span>),</span><br><span class="line"> (<span class="string">&quot;钢铁烈阳&quot;</span>),</span><br><span class="line"> (<span class="string">&quot;裁决之地&quot;</span>),</span><br><span class="line"> (<span class="string">&quot;黑色玫瑰&quot;</span>),</span><br><span class="line"> (<span class="string">&quot;暗影岛&quot;</span>),</span><br><span class="line"> (<span class="string">&quot;均衡教派&quot;</span>),</span><br><span class="line"> (<span class="string">&quot;水晶之痕&quot;</span>),</span><br><span class="line"> (<span class="string">&quot;影流&quot;</span>),</span><br><span class="line"> (<span class="string">&quot;守望之海&quot;</span>),</span><br><span class="line"> (<span class="string">&quot;征服之海&quot;</span>),</span><br><span class="line"> (<span class="string">&quot;卡拉曼达&quot;</span>),</span><br><span class="line"> (<span class="string">&quot;皮城警备&quot;</span>);</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">create</span> <span class="keyword">table</span> lol_member(</span><br><span class="line"> <span class="keyword">id</span> <span class="built_in">int</span>(<span class="number">11</span>) auto_increment,</span><br><span class="line"> user_name <span class="built_in">varchar</span>(<span class="number">100</span>),</span><br><span class="line"> role_name <span class="built_in">varchar</span>(<span class="number">100</span>),</span><br><span class="line"> age <span class="built_in">int</span>(<span class="number">11</span>),</span><br><span class="line"> <span class="keyword">password</span> <span class="built_in">varchar</span>(<span class="number">255</span>),</span><br><span class="line"> phone_num <span class="built_in">varchar</span>(<span class="number">100</span>),</span><br><span class="line"> area_id <span class="built_in">int</span>(<span class="number">100</span>),</span><br><span class="line"> primary <span class="keyword">key</span>(<span class="keyword">id</span>)</span><br><span class="line"> );</span><br><span class="line"> </span><br><span class="line"> <span class="comment">-- 用户计划表</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> lol_plan(</span><br><span class="line"><span class="keyword">id</span> <span class="built_in">int</span>(<span class="number">11</span>) auto_increment,</span><br><span class="line">plan_date <span class="built_in">varchar</span>(<span class="number">100</span>),</span><br><span class="line">plan_event <span class="built_in">varchar</span>(<span class="number">300</span>),</span><br><span class="line">last_time <span class="built_in">Integer</span>(<span class="number">11</span>),</span><br><span class="line">member_id <span class="built_in">Integer</span>(<span class="number">11</span>),</span><br><span class="line">primary <span class="keyword">key</span>(<span class="keyword">id</span>)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 英雄表</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> lol_hero(</span><br><span class="line"><span class="keyword">id</span> <span class="built_in">int</span>(<span class="number">11</span>) auto_increment,</span><br><span class="line">full_name <span class="built_in">varchar</span>(<span class="number">100</span>),</span><br><span class="line">nick_name <span class="built_in">varchar</span>(<span class="number">100</span>),</span><br><span class="line">back_story <span class="built_in">text</span>,</span><br><span class="line">price <span class="keyword">double</span>(<span class="number">5</span>,<span class="number">3</span>),</span><br><span class="line"><span class="comment">-- 英雄类型</span></span><br><span class="line">hero_type_id <span class="built_in">varchar</span>(<span class="number">100</span>),</span><br><span class="line"><span class="comment">-- 英雄页面小图</span></span><br><span class="line">img_small <span class="built_in">varchar</span>(<span class="number">300</span>),</span><br><span class="line">img_big <span class="built_in">varchar</span>(<span class="number">300</span>),</span><br><span class="line">img_scot <span class="built_in">varchar</span>(<span class="number">300</span>),</span><br><span class="line">img_stick <span class="built_in">varchar</span>(<span class="number">300</span>),</span><br><span class="line">text1 <span class="built_in">varchar</span>(<span class="number">255</span>),</span><br><span class="line">text2 <span class="built_in">varchar</span>(<span class="number">255</span>),</span><br><span class="line">primary <span class="keyword">key</span>(<span class="keyword">id</span>)</span><br><span class="line">)</span><br><span class="line"><span class="comment">-- 英雄类型表</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> lol_hero_type(</span><br><span class="line"><span class="keyword">id</span> <span class="built_in">int</span>(<span class="number">11</span>) auto_increment,</span><br><span class="line"><span class="keyword">type</span> <span class="built_in">varchar</span>(<span class="number">100</span>),</span><br><span class="line">primary <span class="keyword">key</span>(<span class="keyword">id</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 英雄位置表</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> lol_hero_position(</span><br><span class="line"><span class="keyword">id</span> <span class="built_in">int</span>(<span class="number">11</span>) auto_increment,</span><br><span class="line"><span class="keyword">position</span> <span class="built_in">varchar</span>(<span class="number">100</span>),</span><br><span class="line">primary <span class="keyword">key</span>(<span class="keyword">id</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 外键关联表（英雄和位置）</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> position_inner_hero(</span><br><span class="line"><span class="keyword">id</span> <span class="built_in">int</span>(<span class="number">11</span>) auto_increment,</span><br><span class="line">hero_id <span class="built_in">int</span>(<span class="number">11</span>),</span><br><span class="line">position_id <span class="built_in">int</span>(<span class="number">11</span>),</span><br><span class="line">primary <span class="keyword">key</span>(<span class="keyword">id</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h1 id="SpringBoot-pageHelper插件"><a href="#SpringBoot-pageHelper插件" class="headerlink" title="SpringBoot   pageHelper插件"></a>SpringBoot   pageHelper插件</h1><p>添加依赖</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;pagehelper-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.2.5&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p>用法：在需要分页的方法中启动分页，需要注意的是，分页的是在开启分页之后的第一个查询语句</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Transactional(readOnly = false,propagation = Propagation.REQUIRES_NEW,rollbackFor = Exception.class)</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> PageInfo <span class="title">getPagePlanVOList</span><span class="params">(Integer pageNum, Integer pageSize, Integer id)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 开启分页</span></span><br><span class="line">        PageHelper.startPage(pageNum,pageSize);</span><br><span class="line">        PlanPOExample example = <span class="keyword">new</span> PlanPOExample();</span><br><span class="line">        PlanPOExample.Criteria criteria = example.createCriteria();</span><br><span class="line">        criteria.andMemberIdEqualTo(id);</span><br><span class="line">        <span class="comment">// 执行查询</span></span><br><span class="line">        List&lt;PlanPO&gt; planPOList = planPOMapper.selectByExample(example);</span><br><span class="line">        <span class="comment">// 判断结果</span></span><br><span class="line">        <span class="keyword">if</span>(planPOList.size() == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UnKnowNetWorkException(<span class="string">&quot;没有查询到任何数据，快去添加计划吧！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 结果正确就返回</span></span><br><span class="line">        List&lt;PlanVO&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(PlanPO planPO : planPOList)&#123;</span><br><span class="line">            PlanVO planVO = <span class="keyword">new</span> PlanVO();</span><br><span class="line">            BeanUtils.copyProperties(planPO,planVO);</span><br><span class="line">            list.add(planVO);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 封装PageInfo对象</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> PageInfo(list);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>查询出来的list结果封装到PageInfo实例对象中</p>
<p>注意的是，在后台远程方法调用的时候，PageInfo的泛型并不是PageInfo&lt;List<xxx>&gt;</xxx></p>
<p>而是对应的JavaBean类型例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">PageInfo&lt;PlanVO&gt; <span class="title">getPagePlanVOList</span><span class="params">(Integer pageNum,Integer pageSize,Integer id)</span></span>;</span><br></pre></td></tr></table></figure>

<p>否则会报一个</p>
<p>pagehelper 返回前台的json转换异常com.fasterxml.jackson.databind.exc.Mismatch的异常</p>
<h1 id="使用了layui的日期插件"><a href="#使用了layui的日期插件" class="headerlink" title="使用了layui的日期插件"></a>使用了layui的日期插件</h1><p>点击输入框可以弹出日期选择框，如下图所示效果</p>
<p><img src="/2020/08/30/LOL-show%E9%A1%B9%E7%9B%AE%E5%B7%A5%E7%A8%8B%E6%97%A5%E5%BF%97/QQ%E6%88%AA%E5%9B%BE20200804102439.png"></p>
<p>加入layui的css样式和js</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;layui/css/layui.css&quot;</span> <span class="attr">media</span>=<span class="string">&quot;all&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;layui/layui.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 添加日期插件</span></span><br><span class="line">layui.use(<span class="string">&#x27;laydate&#x27;</span>,<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 生成一个日期实例，这个实例变量名自己指定</span></span><br><span class="line">    <span class="keyword">var</span> laydate = layui.laydate;</span><br><span class="line">    <span class="comment">//执行一个laydate实例</span></span><br><span class="line">    laydate.render(&#123;</span><br><span class="line">        <span class="comment">// 指定在哪里生成日期控件</span></span><br><span class="line">        elem: <span class="string">&#x27;#dateText&#x27;</span>, <span class="comment">//指定元素</span></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h1 id="使用了谷歌Kaptcha-生成验证码插件"><a href="#使用了谷歌Kaptcha-生成验证码插件" class="headerlink" title="使用了谷歌Kaptcha 生成验证码插件"></a>使用了谷歌Kaptcha 生成验证码插件</h1><p>加入依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Google Kaptcha --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.penggle<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>kaptcha<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>相关的配置</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KaptchaConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DefaultKaptcha <span class="title">getDefaultKaptcha</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        com.google.code.kaptcha.impl.DefaultKaptcha defaultKaptcha = <span class="keyword">new</span> com.google.code.kaptcha.impl.DefaultKaptcha();</span><br><span class="line">        Properties properties = <span class="keyword">new</span> Properties();</span><br><span class="line">        <span class="comment">// 图片边框</span></span><br><span class="line">        properties.setProperty(<span class="string">&quot;kaptcha.border&quot;</span>, <span class="string">&quot;yes&quot;</span>);</span><br><span class="line">        <span class="comment">// 边框颜色</span></span><br><span class="line">        properties.setProperty(<span class="string">&quot;kaptcha.border.color&quot;</span>, <span class="string">&quot;105,179,90&quot;</span>);</span><br><span class="line">        <span class="comment">// 字体颜色</span></span><br><span class="line">        properties.setProperty(<span class="string">&quot;kaptcha.textproducer.font.color&quot;</span>, <span class="string">&quot;red&quot;</span>);</span><br><span class="line">        <span class="comment">// 图片宽</span></span><br><span class="line">        properties.setProperty(<span class="string">&quot;kaptcha.image.width&quot;</span>, <span class="string">&quot;110&quot;</span>);</span><br><span class="line">        <span class="comment">// 图片高</span></span><br><span class="line">        properties.setProperty(<span class="string">&quot;kaptcha.image.height&quot;</span>, <span class="string">&quot;40&quot;</span>);</span><br><span class="line">        <span class="comment">// 字体大小</span></span><br><span class="line">        properties.setProperty(<span class="string">&quot;kaptcha.textproducer.font.size&quot;</span>, <span class="string">&quot;30&quot;</span>);</span><br><span class="line">        <span class="comment">// session key</span></span><br><span class="line">        properties.setProperty(<span class="string">&quot;kaptcha.session.key&quot;</span>, <span class="string">&quot;code&quot;</span>);</span><br><span class="line">        <span class="comment">// 验证码长度</span></span><br><span class="line">        properties.setProperty(<span class="string">&quot;kaptcha.textproducer.char.length&quot;</span>, <span class="string">&quot;4&quot;</span>);</span><br><span class="line">        <span class="comment">// 字体</span></span><br><span class="line">        properties.setProperty(<span class="string">&quot;kaptcha.textproducer.font.names&quot;</span>, <span class="string">&quot;宋体,楷体,微软雅黑&quot;</span>);</span><br><span class="line"></span><br><span class="line">        properties.setProperty(<span class="string">&quot;kaptcha.noise.color&quot;</span>, <span class="string">&quot;35,37,38&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Config config = <span class="keyword">new</span> Config(properties);</span><br><span class="line">        defaultKaptcha.setConfig(config);</span><br><span class="line">        <span class="keyword">return</span> defaultKaptcha;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>controller代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/api/kaptcha&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestCode</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    DefaultKaptcha defaultKaptcha;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/defaultKaptcha&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">defaultKaptcha</span><span class="params">(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] captchaChallengeAsJpeg = <span class="keyword">null</span>;</span><br><span class="line">        ByteArrayOutputStream jpegOutputStream = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 生产验证码字符串并保存到session中</span></span><br><span class="line">            String createText = defaultKaptcha.createText();</span><br><span class="line">            System.out.println(createText);</span><br><span class="line">            httpServletRequest.getSession().setAttribute(<span class="string">&quot;verificationCode&quot;</span>, createText);</span><br><span class="line">            <span class="comment">// 使用生成的验证码字符串返回一个BufferedImage对象并转为byte写入到byte数组中</span></span><br><span class="line">            BufferedImage challenge = defaultKaptcha.createImage(createText);</span><br><span class="line">            ImageIO.write(challenge, <span class="string">&quot;jpg&quot;</span>, jpegOutputStream);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalArgumentException e) &#123;</span><br><span class="line">            httpServletResponse.sendError(HttpServletResponse.SC_NOT_FOUND);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 定义response输出类型为image/jpeg类型，使用response输出流输出图片的byte数组</span></span><br><span class="line">        captchaChallengeAsJpeg = jpegOutputStream.toByteArray();</span><br><span class="line">        httpServletResponse.setHeader(<span class="string">&quot;Cache-Control&quot;</span>, <span class="string">&quot;no-store&quot;</span>);</span><br><span class="line">        httpServletResponse.setHeader(<span class="string">&quot;Pragma&quot;</span>, <span class="string">&quot;no-cache&quot;</span>);</span><br><span class="line">        httpServletResponse.setDateHeader(<span class="string">&quot;Expires&quot;</span>, <span class="number">0</span>);</span><br><span class="line">        httpServletResponse.setContentType(<span class="string">&quot;image/jpeg&quot;</span>);</span><br><span class="line">        ServletOutputStream responseOutputStream = httpServletResponse.getOutputStream();</span><br><span class="line">        responseOutputStream.write(captchaChallengeAsJpeg);</span><br><span class="line">        responseOutputStream.flush();</span><br><span class="line">        responseOutputStream.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>前台显示</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">id</span>=<span class="string">&quot;verificationCodeImg&quot;</span> <span class="attr">src</span>=<span class="string">&quot;/api/kaptcha/defaultKaptcha&quot;</span> <span class="attr">style</span>=<span class="string">&quot;cursor: pointer;&quot;</span> <span class="attr">title</span>=<span class="string">&quot;看不清？换一张&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p>添加点击“看不清？换一张”的事件</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 刷新验证码</span></span><br><span class="line">            $(<span class="string">&quot;#verificationCodeImg&quot;</span>).bind(<span class="string">&quot;click&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                $(<span class="built_in">this</span>).hide().attr(<span class="string">&#x27;src&#x27;</span>, <span class="string">&#x27;http://localhost/api/kaptcha/defaultKaptcha?&#x27;</span>).fadeIn();</span><br><span class="line">            &#125;);</span><br></pre></td></tr></table></figure>

<p>效果图</p>
<p><img src="/2020/08/30/LOL-show%E9%A1%B9%E7%9B%AE%E5%B7%A5%E7%A8%8B%E6%97%A5%E5%BF%97/QQ%E6%88%AA%E5%9B%BE20200804103206.png"></p>
<h1 id="改变文本输入框获取值"><a href="#改变文本输入框获取值" class="headerlink" title="改变文本输入框获取值"></a>改变文本输入框获取值</h1><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 为输入英雄名称的文本框绑定文本改变的事件</span></span><br><span class="line">            $(<span class="string">&quot;.inputSearch&quot;</span>).on(<span class="string">&quot;input&quot;</span>,<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="keyword">let</span> heroName = $(<span class="built_in">this</span>).val()</span><br><span class="line">            &#125;)</span><br></pre></td></tr></table></figure>

<h1 id="mybatis模糊查询的三种方式"><a href="#mybatis模糊查询的三种方式" class="headerlink" title="mybatis模糊查询的三种方式"></a>mybatis模糊查询的三种方式</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select id,name,age,score from star where name like &quot;%&quot; #&#123;name&#125; &quot;%&quot;</span><br><span class="line"></span><br><span class="line">&lt;!--concat拼接字符串  mysql独有的函数--&gt;</span><br><span class="line">select id,name,age,score from star where name like concat(&quot;%&quot;,#&#123;name&#125;,&quot;%&quot;)</span><br><span class="line"></span><br><span class="line">&lt;!-- 如果传入的参数是简单数据类型，$&#123;&#125;里面必须写value --&gt;</span><br><span class="line">select id,name,age,score from star where name like &quot;%$&#123;value&#125;%&quot;</span><br><span class="line"></span><br><span class="line">作者：叫我不矜持</span><br><span class="line">链接：https:&#x2F;&#x2F;www.jianshu.com&#x2F;p&#x2F;6d244e194859</span><br><span class="line">来源：简书</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>

<h1 id="thymeleaf循环的状态变量"><a href="#thymeleaf循环的状态变量" class="headerlink" title="thymeleaf循环的状态变量"></a>thymeleaf循环的状态变量</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">th:each属性用于迭代循环，语法：th:each&#x3D;&quot;obj,iterStat:$&#123;objList&#125;&quot;</span><br><span class="line">迭代对象可以是Java.util.List,java.util.Map,数组等;</span><br><span class="line">iterStat称作状态变量，属性有：</span><br><span class="line">    index:当前迭代对象的index（从0开始计算）</span><br><span class="line">    count: 当前迭代对象的index(从1开始计算)</span><br><span class="line">    size:被迭代对象的大小</span><br><span class="line">    current:当前迭代变量</span><br><span class="line">    even&#x2F;odd:布尔值，当前循环是否是偶数&#x2F;奇数（从0开始计算）</span><br><span class="line">    first:布尔值，当前循环是否是第一个</span><br><span class="line">    last:布尔值，当前循环是否是最后一个</span><br></pre></td></tr></table></figure>

<h1 id="mysql-根据拼音首字母查询"><a href="#mysql-根据拼音首字母查询" class="headerlink" title="mysql 根据拼音首字母查询"></a>mysql 根据拼音首字母查询</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT id,full_name ,</span><br><span class="line"></span><br><span class="line">ELT(INTERVAL(CONV(HEX(LEFT(CONVERT(full_name USING gbk),1)),16,10),</span><br><span class="line"></span><br><span class="line">0xB0A1,0xB0C5,0xB2C1,0xB4EE,0xB6EA,0xB7A2,0xB8C1,0xB9FE,0xBBF7,</span><br><span class="line"></span><br><span class="line">0xBFA6,0xC0AC,0xC2E8,0xC4C3,0xC5B6,0xC5BE,0xC6DA,0xC8BB,0xC8F6,</span><br><span class="line"></span><br><span class="line">0xCBFA,0xCDDA,0xCEF4,0xD1B9,0xD4D1),</span><br><span class="line"></span><br><span class="line">&#39;A&#39;,&#39;B&#39;,&#39;C&#39;,&#39;D&#39;,&#39;E&#39;,&#39;F&#39;,&#39;G&#39;,&#39;H&#39;,&#39;J&#39;,&#39;K&#39;,&#39;L&#39;,&#39;M&#39;,&#39;N&#39;,&#39;O&#39;,&#39;P&#39;,</span><br><span class="line"></span><br><span class="line">&#39;Q&#39;,&#39;R&#39;,&#39;S&#39;,&#39;T&#39;,&#39;W&#39;,&#39;X&#39;,&#39;Y&#39;,&#39;Z&#39;) AS PY</span><br><span class="line"></span><br><span class="line">FROM lol_hero WHERE ELT(INTERVAL(CONV(HEX(LEFT(CONVERT(full_name USING gbk),1)),16,10),</span><br><span class="line"></span><br><span class="line">0xB0A1,0xB0C5,0xB2C1,0xB4EE,0xB6EA,0xB7A2,0xB8C1,0xB9FE,0xBBF7,</span><br><span class="line"></span><br><span class="line">0xBFA6,0xC0AC,0xC2E8,0xC4C3,0xC5B6,0xC5BE,0xC6DA,0xC8BB,0xC8F6,</span><br><span class="line"></span><br><span class="line">0xCBFA,0xCDDA,0xCEF4,0xD1B9,0xD4D1),</span><br><span class="line"></span><br><span class="line">&#39;A&#39;,&#39;B&#39;,&#39;C&#39;,&#39;D&#39;,&#39;E&#39;,&#39;F&#39;,&#39;G&#39;,&#39;H&#39;,&#39;J&#39;,&#39;K&#39;,&#39;L&#39;,&#39;M&#39;,&#39;N&#39;,&#39;O&#39;,&#39;P&#39;,</span><br><span class="line"></span><br><span class="line">&#39;Q&#39;,&#39;R&#39;,&#39;S&#39;,&#39;T&#39;,&#39;W&#39;,&#39;X&#39;,&#39;Y&#39;,&#39;Z&#39;) &#x3D; &#39;A&#39;</span><br></pre></td></tr></table></figure>

<h1 id="部署项目"><a href="#部署项目" class="headerlink" title="部署项目"></a>部署项目</h1><h2 id="打包"><a href="#打包" class="headerlink" title="打包"></a>打包</h2><p>包含第三方jar包的工程的build</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">                第三方jar包目录</span><br><span class="line">                <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/resources/lib<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">targetPath</span>&gt;</span>BOOT-INF/lib/<span class="tag">&lt;/<span class="name">targetPath</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.jar<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/resources<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">targetPath</span>&gt;</span>BOOT-INF/classes/<span class="tag">&lt;/<span class="name">targetPath</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.1.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;maven-compiler-plugin.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">source</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">skip</span>&gt;</span>true<span class="tag">&lt;/<span class="name">skip</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">encoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">encoding</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">compilerArguments</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">extdirs</span>&gt;</span>$&#123;project.basedir&#125;/src/main/resources/lib<span class="tag">&lt;/<span class="name">extdirs</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">compilerArguments</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>其余的，如果依赖springboot父工程，加上</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.1.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如果不依赖任何工程，直接打包</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mvn clean install -Dmaven.test.skip=true // 忽略test</span><br></pre></td></tr></table></figure>

<h2 id="准备服务器环境"><a href="#准备服务器环境" class="headerlink" title="准备服务器环境"></a>准备服务器环境</h2><p>安装jdk</p>
<p>在/etc/profile文件的最后配置java环境</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">JAVA_HOME=/opt/sorftware/jdk1.8.0_251</span><br><span class="line">PATH=$PATH:$JAVA_HOME/bin</span><br><span class="line">export JAVA_HOME PATH</span><br></pre></td></tr></table></figure>

<p>安装mysql</p>
<p><a href="https://www.cnblogs.com/cannel/p/11104195.html">参考</a></p>
<p>缺少 libaio</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum install libaio</span><br></pre></td></tr></table></figure>

<p>修改密码需要设置密码的级别：注意！</p>
<p>授权远程连接</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GRANT ALL PRIVILEGES ON *.* TO &#39;root&#39;@&#39;%&#39; IDENTIFIED BY &#39;rootroot&#39; WITH GRANT OPTION;</span><br></pre></td></tr></table></figure>

<p>微服务远程调用报错找不到主机，因为我的redisServer以及mysqlServer在另一个服务器上，所以consumer想要调用这两个server的服务，必须找到我的另一个服务器，但是我发现服务器的名字没有使用ip地址，所以依照<code>参考</code>的调试最后成功了！</p>
<p>运行jar包</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nohup java -jar xxx.jar &gt;/dev/null 2&gt;&amp;1 &amp;</span><br></pre></td></tr></table></figure>



<p>报错：UnknownHostException</p>
<p><a href="https://blog.csdn.net/weixin_39032575/article/details/83011334?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param">参考</a></p>
]]></content>
      <categories>
        <category>项目</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>java随笔</title>
    <url>/2020/09/10/java%E9%9A%8F%E7%AC%94/</url>
    <content><![CDATA[<p>  在学习的过程中，难免会碰到自己从未接触过的知识和技巧，有时候一边看过去会忘记，所以把它记录下来是最好的选择，而不是假装自己会了，又继续学习别的知识，这样的话，对后续的工作和学习都会带来一些不必要的麻烦。</p>
<p>  我自认为，在学习的时候，应该自己主动思考，如果这样的话，结果是怎么样，那样的话，结果是怎么样，我们在整个小学、初中、高中，甚至是大学，都被灌输了一种思想，就是，这样就是对的，那么当我们碰到问题的时候，往往就会一头雾水，不知如何下手，如果有主动思考的能力的话，这种问题是不是就会没有那么棘手呢？</p>
<a id="more"></a>

<p>2020.9.10</p>
<p>在阅读《疯狂java讲义》一书中HashMap的介绍，书中实例HashMap类实例的put方法，发现他有一个返回值，并且是Object类型的，这我就纳闷了，添加元素，一般不是返回true就是false啊？我在一篇博客的评论下发现了答案，原来是</p>
<blockquote>
<p>如果此前存在一个相同的key，那么put方法返回的是前面key的value值，这时候后来put的value就会覆盖前面put进去的值；如果当前put方法，put的是一个新的key，那么返回值就是null。</p>
</blockquote>
<h1 id><a href="#" class="headerlink" title></a></h1>]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>peanutMallFollowCoderwhy工程日志</title>
    <url>/2020/09/11/peanutMallFollowCoderwhy%E5%B7%A5%E7%A8%8B%E6%97%A5%E5%BF%97/</url>
    <content><![CDATA[<h1 id="项目工程概述"><a href="#项目工程概述" class="headerlink" title="项目工程概述"></a>项目工程概述</h1><p>项目github仓库地址：<a href="https://github.com/JustinPeanut/peanutMallFollowCoderwhy">peanutMallFollowCoderwhy</a></p>
<p><code>talk is cheap, show me your code</code></p>
<p>一下记录我跟随coderwhy老师开发mall商城应用中碰到的一些问题和需要注意的点。</p>
<a id="more"></a>

<h1 id="碰到的问题"><a href="#碰到的问题" class="headerlink" title="碰到的问题"></a>碰到的问题</h1><h2 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h2><p>在创建项目的时候，不能使用大写或者一些其他特殊字符</p>
<p><code>git remove add origin respostity url</code>:将远程仓库和本地仓库联系起来</p>
<p>划分目录结构：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">assets				<span class="comment">// 资源</span></span><br><span class="line"> --img</span><br><span class="line"> --css</span><br><span class="line">    --normalize.css	<span class="comment">// 对不同浏览器的标签样式统一(在github下载)</span></span><br><span class="line">    --base.css		<span class="comment">// 初始化css设置</span></span><br><span class="line">views				<span class="comment">// 视图</span></span><br><span class="line">componets			<span class="comment">// 公共组件</span></span><br><span class="line"> --common			<span class="comment">// 完全公共的组件，可以给别的项目使用</span></span><br><span class="line"> --content			<span class="comment">// 和当前组件业务相关的组件</span></span><br><span class="line">router				<span class="comment">// 路由相关</span></span><br><span class="line">store				<span class="comment">// vuex公共状态管理</span></span><br><span class="line">network				<span class="comment">// 网络相关封装</span></span><br><span class="line">common				<span class="comment">// 公共的一些常量，或者工具类</span></span><br></pre></td></tr></table></figure>

<p>在根目录下创建vue.config.js配置别名。</p>
<p>在根目录下创建代码规范文件<code>.editorConfig</code>。</p>
<h2 id="开发"><a href="#开发" class="headerlink" title="开发"></a>开发</h2><h3 id="tabBar"><a href="#tabBar" class="headerlink" title="tabBar"></a>tabBar</h3><p>如果你配置了别名，那么dom中引用url的时候，一定要加上~</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;~assets/img/tabbar/home.svg&quot;</span> <span class="attr">slot</span>=<span class="string">&quot;img-common-slot&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>要不然就获取不到相应的图片。</p>
<p>设置点击之后active的样式</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;tab-item&quot;</span> @click=<span class="string">&quot;itemClick&quot;</span>&gt;</span><br><span class="line">        &lt;slot v-<span class="keyword">if</span>=<span class="string">&quot;!isActive&quot;</span> name=<span class="string">&quot;img-common-slot&quot;</span>&gt;&lt;/slot&gt;</span><br><span class="line">        &lt;slot v-<span class="keyword">else</span> name=<span class="string">&quot;img-active-slot&quot;</span>&gt;&lt;/slot&gt;</span><br><span class="line">    &lt;div :style=<span class="string">&quot;isTextActive&quot;</span>&gt;</span><br><span class="line">        &lt;slot name=<span class="string">&quot;textSlot&quot;</span>&gt;&lt;/slot&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    name: <span class="string">&quot;TabBarItem&quot;</span>,</span><br><span class="line">    props: &#123;</span><br><span class="line">      path: &#123;</span><br><span class="line">        type: <span class="built_in">String</span></span><br><span class="line">        &#125;,</span><br><span class="line">      <span class="comment">// 父组件给子组件传值</span></span><br><span class="line">      textColor: &#123;</span><br><span class="line">        type: <span class="built_in">String</span>,</span><br><span class="line">        <span class="keyword">default</span>: <span class="string">&quot;red&quot;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">      itemClick()&#123;</span><br><span class="line">        <span class="built_in">this</span>.$router.replace(<span class="built_in">this</span>.path);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    computed: &#123;</span><br><span class="line">      isActive()&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.$route.path.indexOf(<span class="built_in">this</span>.path) != <span class="number">-1</span>;</span><br><span class="line">      &#125;,</span><br><span class="line">      isTextActive()&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.isActive ? &#123;<span class="attr">color</span>: <span class="built_in">this</span>.textColor&#125;: &#123;&#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line">  .tab-item&#123;</span><br><span class="line">    height: <span class="number">49</span>px;</span><br><span class="line">    text-align: center;</span><br><span class="line">    flex: <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  .tab-item img&#123;</span><br><span class="line">    width: <span class="number">24</span>px;</span><br><span class="line">    height: <span class="number">24</span>px;</span><br><span class="line">    vertical-align: middle;</span><br><span class="line">    margin: <span class="number">4</span>px <span class="number">0</span> <span class="number">2</span>px <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  .active&#123;</span><br><span class="line">    color: red</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="navBar"><a href="#navBar" class="headerlink" title="navBar"></a>navBar</h3><p>注意：插槽如果有多个，要使用具名插槽，在使用的时候也要指定替换哪一个插槽，效果图如下</p>
<p><img src="/2020/09/11/peanutMallFollowCoderwhy%E5%B7%A5%E7%A8%8B%E6%97%A5%E5%BF%97/QQ%E6%88%AA%E5%9B%BE20200911105742.png"></p>
<h3 id="封装网络请求"><a href="#封装网络请求" class="headerlink" title="封装网络请求"></a>封装网络请求</h3><p>我们知道axios是第三方框架，如果有那一天这个第三方框架不更新的话，我们如果在项目中多处使用了axios，代码的重构就会带来很多不必要的麻烦。</p>
]]></content>
      <categories>
        <category>项目</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>BTC九---分叉</title>
    <url>/2020/09/09/%E5%88%86%E5%8F%89/</url>
    <content><![CDATA[<h1 id="分叉"><a href="#分叉" class="headerlink" title="分叉"></a>分叉</h1><p>fork:原来是一条链，现在是两条链形成了分叉。有两种情况：</p>
<p>①如果同时有两个结点发布了区块，这时候就会形成分叉：state fork，由于对比特币这个区块链当前的区块状态有意见分歧而导致的分叉，forking attack也属于state fork，只不过分叉攻击这个意见分歧是故意造成的，所以有时候我们管这个叫deliberate fork。</p>
<p>②比特币的协议发生了改变，要修改比特币的协议，需要软件升级，在一个去中心化的系统里，在升级软件的时候，没有办法保证所有的结点同时都升级软件，我们假设大部分结点升级了软件，少数结点因为种种原因没有升级，有可能还没有来的及升级，也可能是不同意这个协议的修改，这种分叉叫做protocol fork，因为对比特币的协议产生了分歧，因为使用不同的协议造成了分叉。</p>
<a id="more"></a>

<blockquote>
<p>可以根据对协议修改的内容的不同，分为硬分叉（hard fork）和软分叉（soft fork）</p>
</blockquote>
<p>什么是硬分叉？什么是软分叉？</p>
<h2 id="hard-fork"><a href="#hard-fork" class="headerlink" title="hard fork"></a>hard fork</h2><p>出现硬分叉的情况，如果对比特币协议增加新的特性，有一些new feature，这些没有升级软件的那些旧的节点，他是不认可这些新特性的，他认为这些new feature是不合法的。这个时候就属于我们对比特币协议的内容产生了意见分歧，就会导致分叉。一个例子就是：比特币中的区块大小限制（block size limit）。</p>
<blockquote>
<p>比特币规定每个区块是1M字节，有些人认为1M这个限制太小了，增加了比特币的延迟。</p>
<p>一个交易差不多可以认为是250个字节，所以1000000字节大概是4000个交易左右，平均十分钟一个区块，算下来大概是每秒钟七笔交易</p>
<p><img src="/2020/09/09/%E5%88%86%E5%8F%89/QQ%E6%88%AA%E5%9B%BE20200907211038.png"></p>
<p>我们用信用卡处理交易和这个完全不是一个数量级的，很多电商网站很多都不止这些，所以有的人认为这个区块太小了，限制了比特币的throw put（不知道老师是不是说的这个），同时也增加了延迟，因为你区块就只能装这么多区块，如果交易太多了的话，那可能有些交易，就得等到下一个区块才能被发布，平均要等十分钟</p>
</blockquote>
<p>我们假设有人发布了软件更新，把这个block size limit从1M增加到了4M（大多数结点更新了这个软件，少数节点没有更新【这里所说的节点数目不是按照账户的数目来算的，是按照算力的多少来算的】），这个时候系统运行起来会有什么结果？</p>
<p><img src="/2020/09/09/%E5%88%86%E5%8F%89/QQ%E6%88%AA%E5%9B%BE20200907212426.png"></p>
<p>备注：图中的解释有错误，应该是新产生的区块，旧结点不认可</p>
<p><img src="/2020/09/09/%E5%88%86%E5%8F%89/QQ%E6%88%AA%E5%9B%BE20200907212813.png"></p>
<p>备注：图中的“就”为“旧”</p>
<p>只要这些旧结点不更新软件，分叉就不会消失，这就是为什么管他叫硬分叉（hard fork）。</p>
<p>比特币社区中，有些人是比较保守的，像这种block size limit这种new feature，有些人真的是不会同意，而且，区块的大小不是越大越好（详情看比特币网络）。</p>
<p>如果存在了硬分叉，那么下面的那一条链的出块奖励还有吗？</p>
<blockquote>
<p>是有的（在各自的链上是承认的），会造成社区的分裂，如果一直存在下去，就会分家了，相当于变成了两种币，原来没有分裂的币，应该变成上下两条链都认可。</p>
<p><img src="/2020/09/09/%E5%88%86%E5%8F%89/QQ%E6%88%AA%E5%9B%BE20200907214138.png"></p>
<p>后来有了一个措施：在各自的链上加上一个chain ID</p>
</blockquote>
<h2 id="soft-fork"><a href="#soft-fork" class="headerlink" title="soft fork"></a>soft fork</h2><p>软分叉出现的情况？如果我们对比特币协议加一些限制。加这个限制之后，原来合法的交易或者是合法的区块，在新的协议中，有可能变得不是合法了，这就引起软分叉。</p>
<p>举例：</p>
<p>如果有人发布了软件更新，block size limit缩小了，由1M变成0.5M（实际上不会这样做，因为1M已经是比较小的了）</p>
<p><img src="/2020/09/09/%E5%88%86%E5%8F%89/QQ%E6%88%AA%E5%9B%BE20200909193415.png"></p>
<p>实际当中可能出现软分叉的情况</p>
<p>①给某些目前协议中没有规定的域增加一些新的含义，赋予他们一些新的规则：coinBase域，每个发布的区块里可以有一个铸币交易，coinBase可以有个特别的用途（作为extra nonce 拿出8bytes），其实coinBase不止8个字节，那其他字节干嘛用呢？有人就建议，把他作为UTXO集合的根哈希值，目前这个集合只是全节点自己在内存中维护这样一个集合，主要是为了快速查找能够交易是不是double spending，但是这个集合的内容并没有写到区块链，这个和我们说的Merkle proof不太一样。</p>
<p>如果你要证明某个账户上有多少钱，如果你是全节点的话，可以算一下，就是看一下A这个账户在这个UTXO里对应的输出上面一共收到多少个币，就是A账户上有多少钱。</p>
<p>有很多区块链钱包（手机上的app），他不可能在手机上维护一个全结点，他需要知道账户的余额，需要询问其他的全节点，那么全节点返回一个结果，你怎么知道他是不是对的？</p>
<blockquote>
<p>你现在是证不出来的，你自己如果没有维护一个UTXO集合，是没有办法用Merkle proof证出来的，所以有人就提议：</p>
<p>把UTXO集合当中的内容也组织成一条Merkle tree，这个Merkle tree有一个根哈希值，这个哈希值写在coinBase中，因为你block header没有办法再改了（block header动静太大了），coinBase中的内容在网上传递的时候，最终会传递到block header中，这样的话，你就可以用Merkle proof证出来</p>
</blockquote>
<p>有人发布软件更新，规定coinBase域要这样写，这样是硬分叉还是软分叉？软分叉，因为新节点发布的区块，旧结点认为是合法的，因为旧结点不管你coinBase什么内容，都认为是合法的，但是旧结点发布的区块，新节点可能是不认的。</p>
<p>比特币历史上，一个比较著名的软分叉的例子，是P2SH（Pay to Script Hash），这个在最初的比特币版本里是没有的，是后来通过软分叉加进去的：</p>
<p>你支付的时候，不是付给一个Public Key的哈希，而是付给一个赎回脚本的哈希，这是新节点要做的；而对于旧结点，他不理解P2SH的特性，他只会做第一阶段的验证，所以，旧结点认为合法的交易，新节点可能认为是非法的</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>soft fork：只要系统中有半数以上的结点更新了软件，就不会出现永久的分叉，可能会出现临时的分叉。</p>
<p>hard fork：必须是所有的节点都要更新软件，系统才不会出现永久性的分叉，如果有小部分节点不愿意更新，那么这个系统就会分成两条链。</p>
]]></content>
      <categories>
        <category>区块链</category>
      </categories>
      <tags>
        <tag>区块链</tag>
      </tags>
  </entry>
  <entry>
    <title>BTC三---协议</title>
    <url>/2020/08/30/%E5%8D%8F%E8%AE%AE/</url>
    <content><![CDATA[<h1 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h1><h2 id="1-需要解决的问题"><a href="#1-需要解决的问题" class="headerlink" title="1.需要解决的问题"></a>1.需要解决的问题</h2><p>举个例子，央行可以发行数字货币，每张数字货币上都有央行的私钥的签名</p>
<a id="more"></a>

<p><img src="/2020/08/30/%E5%8D%8F%E8%AE%AE/QQ%E6%88%AA%E5%9B%BE20200810202143.png"></p>
<p>央行的公钥我们大家都知道，所以我收到一个数字货币，我可以验证一下是不是真的，买东西的时候，我把数字货币发给你，同理你也可以验证确实是央行发行的，这就完成了支付的一个过程。</p>
<p>这里用到了密码学中的非对称加密体系，但是没有用到区块链，这样会带来什么问题？</p>
<p>这个数字货币是个文件，我们不能篡改，但是可以复制，可以复制很多份，这和人民币不一样，我把人民币给你了，我就没有人民币了。这就是数字货币和纸质货币的区别</p>
<p>double spending attack（双花攻击），数字货币面临的一个主要挑战，就是防范double spending attack</p>
<p>改进的方案：</p>
<p><img src="/2020/08/30/%E5%8D%8F%E8%AE%AE/QQ%E6%88%AA%E5%9B%BE20200810203047.png"></p>
<p>央行发行的货币，再每个数字货币上添加一个编号，并且在数据库中保存这个编号对应的货币目前在谁手上，收款方不仅验证数字货币的真实性，还需要验证付款方是否合法，央行的 数据库进而修改017对应的数字货币的所有者。</p>
<p>这样做是没有问题的，但是这是一个中心化的方案，数字货币的发行是由央行统一控制的，而且每次交易也是由央行控制的。</p>
<p>那么有没有去中心化的方案呢？将央行这个职能，改成由广大用户共同承担，这就是比特币，这个数字货币系统要解决的问题。</p>
<p>去中心化的货币要解决两个问题：数字货币的发行（没有央行了，都是普通群众，那怎么决定数字货币的发行：什么时候发行，该发行多少）、怎么验证交易的有效性（如何防止double spending attack）</p>
<p>①谁来发行货币？在比特币系统中，是由挖矿来决定的，这个在后面详细讲</p>
<p>②如何防止double spending attack：也是维护一个数据结构，检测数字货币有没有花过，被谁花过，只不过这个数据结构不是由央行来维护，而是由所有的用户来维护，这个数据结构就是区块链</p>
<p>比如用户A，拥有了发行货币的能力</p>
<p><img src="/2020/08/30/%E5%8D%8F%E8%AE%AE/QQ%E6%88%AA%E5%9B%BE20200810204843.png"></p>
<p><strong>比特币中的交易都包含输入和输出两部分，输入部分说明币的来源，输出部分要给出收款人公钥的哈希</strong></p>
<p>这里有两个哈希指针，一个哈希指针是用来连接各个区块，把他们串起来构成一个链表，还有一个指针是用来说明币的来源的（用于证明这个数字货币不是凭空捏造的，同时防范double spending attack）</p>
<p><img src="/2020/08/30/%E5%8D%8F%E8%AE%AE/QQ%E6%88%AA%E5%9B%BE20200810205441.png"></p>
<p>A要给B转钱，需要知道B的地址，这个地址是由B的公钥取哈希，经过一些转换推算得到的，那A要怎么知道B的地址呢？</p>
<p>比特币系统没有提供一种功能去查询某个指定人的所对应的比特币地址，这个需要其他的渠道来获得</p>
<p>A要给B转钱，B要知道A的什么信息？币的来源？（B不需要知道，这个其实是A要知道的）</p>
<p>答案是B要知道A的公钥。B要知道A的身份，好知道这笔钱是哪来的。但是不仅仅是B需要知道A的公钥，所有结点都需要知道A的公钥—-&gt;为了验证A的签名，那问题又来了，怎么知道A的公钥？</p>
<p>输入当中不仅要说明币的来源，还需要说明A的公钥是什么</p>
<p><img src="/2020/08/30/%E5%8D%8F%E8%AE%AE/QQ%E6%88%AA%E5%9B%BE20200810211410.png"></p>
<p><img src="/2020/08/30/%E5%8D%8F%E8%AE%AE/QQ%E6%88%AA%E5%9B%BE20200810211619.png"></p>
<p>在比特币系统中，这些验证的过程，是通过执行脚本来实现的—–&gt;BitCoin Script</p>
<p>将后面交易的输入的执行脚本和前面交易的输出的执行脚本拼接，如果能顺利执行，那么这个验证就是通过的</p>
<p>每个区块由block header 和 block body组成</p>
<p>block header：保存每个区块的一些宏观的信息，包括</p>
<p>①：用的是比特币哪个版本的协议</p>
<p>②hash of previous block header：区块中指向前一个区块的指针</p>
<p><strong>注意：</strong>前一个区块的哈希只算的是区块的块头</p>
<p>③Merkle root hash：整棵Merkle tree的根哈希值</p>
<p>④target：挖矿的难度目标阈值</p>
<p><img src="/2020/08/30/%E5%8D%8F%E8%AE%AE/QQ%E6%88%AA%E5%9B%BE20200810213647.png"></p>
<p>block header存的就是target的一个编码：nBits</p>
<p>⑤nonce：随机数nonce    </p>
<p>block body：</p>
<p>①transaction list：交易列表</p>
<p>貌似所有的结点都需要验证区块链中的每一个交易</p>
<p>实际上区块链分为全节点full node 和轻结点light node 两种结点</p>
<p>full node ：保存所有的信息，验证每一个交易，也叫做fully validating node</p>
<p>light node：并不参数验证，只是利用区块链的一些信息做一些查询之类的工作</p>
<p>交易如何写入区块链，按照什么顺序？账本的内容要取得分布式的共识（distributed consensus）</p>
<p>分布式的共识？举个例子，就是简单的哈希表distributed hash table，就是，一台机器在hash表中插入了一条数据（key-value pair），在别的机器也能查询到。</p>
<h2 id="2-分布式系统中的结论和协议"><a href="#2-分布式系统中的结论和协议" class="headerlink" title="2.分布式系统中的结论和协议"></a>2.分布式系统中的结论和协议</h2><p>分布式系统有很多的不可能结论impossibility result，最著名的一个叫做FLP impossibility result:</p>
<p>在一个异步的系统里（asynchronous system），网络传输时延没有上限，即时只有一个成员是有问题的（faulty），也不可能取得共识</p>
<p>还有一个结论CAP Theorem：</p>
<p>C：consistency（一致性）   A：Availability（可用性）   P：Partition tolerance（分区容错性）</p>
<p>任何一个分布式系统CAP三个性质最多只能满足两个，不可能三个性质都满足。</p>
<p>分布式共识的一个重要协议：Paxos，这个协议能够保证Consistency，如果这个协议达成了共识，那么这个共识一定是一致的，不会说一个成员认为的共识和另外一个成员认为的共识不一样。但是，某些情况下，Paxos协议有可能一直没有办法达成共识，这种可能性在实际系统中是比较小的，但是是客观存在的</p>
<h2 id="3-比特币系统中的分布式共识协议"><a href="#3-比特币系统中的分布式共识协议" class="headerlink" title="3.比特币系统中的分布式共识协议"></a>3.比特币系统中的分布式共识协议</h2><p>需要解决的问题是，某些节点可能是有恶意的，我们假设系统中大多数节点是好的，如何去设计共识协议？</p>
<p>一种想法，既然大多数结点是好的，那直接投票行不行，比如说：某一个结点提出一个候选区块，他根据收到的交易信息，选一下那些交易是合法的，然后把这些交易按照某个顺序打包到一个区块里，候选区块发布给所有的结点，每个结点收到这个区块之后，检查这里面的交易是不是都是合法的，如果都是合法的，那么这个结点就投赞成票，如果有个交易是非法的，就投反对票，最后算出得票，如果超过半数，就将这个候选区块正式接受，写道区块链中</p>
<p>会带来什么问题？</p>
<p>①某个结点提出候选区块，万一这个节点是有恶意的呢，就不停的产生一些非法的交易让系统一直投票，会阻塞系统的发展</p>
<p>②并不能强迫每个节点都投票（行政不作为）</p>
<p>③效率的问题，网络的延迟状况不是很清楚</p>
<p>最大的问题：所有基于投票的方案，首先要确定谁有投票权（需要有membership）。如果这个系统的membership是有严格定义的，不是谁都可以加入的，比如hyperledger，只有某些符合条件的大公司才能加入，这种情况下，基于投票的方案是可行的。</p>
<p>但是比特币系统不是这样的，比特币系统中创建一个账户是很容易的，在本地产生一个公私钥对其他人其实都不知道，只有在你和外部交易的时候别人会知道，这种情况下，有恶意的结点，用一台超级计算机，不停的创建账户，当账户超过总数的一半时，就会对投票产生控制权，这种攻击叫做女巫攻击（sybil attack）。</p>
<p>所以简单的随机投票是不行的</p>
<p>比特币中采用了一个巧妙地机制来解决这个问题，也是投票，但不是按照账户的数目投票，而是用计算力来投票，每个结点都可以在本地组装出一个候选区块，把他认为合法的交易放在这个区块里，就开始尝试各种nonce值，看那个结点可以满足不等式的要求，求出的hash落在指定的范围之内，如果某个节点找到了符合要求的nonce，我们就说他获得了记账权（向比特币这个去中心化的账本里写入下一个区块的权力），只有这样的结点，才有权力发布下一个区块，其他节点要先验证这个区块的合法性，block header 中的nBits（挖矿的难度要求）是否正确，然后验证nonce，总的来说，就是先查询block header中的各种值，然后验证block body中的交易是否合法（是否有合法的签名、是否被花过）</p>
<p>有没有可能这个区块的所有内容都符合要求，但是我们仍然不愿意接受他？</p>
<p><img src="/2020/08/30/%E5%8D%8F%E8%AE%AE/QQ%E6%88%AA%E5%9B%BE20200812212804.png"></p>
<p>分叉攻击，通过像区块链中间插入一个区块，来回滚某个已经发生的交易，但是区块链在正常情况下也会出现分叉，</p>
<p>如果同时有两个结点获得了记账权，就有可能发生，可能会出现两个等长的分叉</p>
<p><img src="/2020/08/30/%E5%8D%8F%E8%AE%AE/QQ%E6%88%AA%E5%9B%BE20200812213645.png"></p>
<p>比特币系统中，缺省情况下，每个结点是接受他最早收到的那个，不同的结点在网络中的位置不同，接受的结点可能也不同，什么叫做接受？在接受一个区块之后会向后扩展区块</p>
<p><img src="/2020/08/30/%E5%8D%8F%E8%AE%AE/QQ%E6%88%AA%E5%9B%BE20200812214435.png"></p>
<p><img src="/2020/08/30/%E5%8D%8F%E8%AE%AE/QQ%E6%88%AA%E5%9B%BE20200812214518.png"></p>
<p>那么为什么要争夺记账权？</p>
<p>记账的结点可以拥有某些权力，决定那些交易被写到区块链里，但是设计的时候不应该让这个权力称为争夺记账权的主要动力，因为我们希望所有的合法的交易都应该被写进区块链里</p>
<p>比特币系统规定，获得记账权的哪个结点，在发布的区块里可以有一个特殊的交易，就是铸币交易，可以发布一定数量的比特币。coinbase transaction（交易）</p>
<p>比特币系统要解决两个问题，一个是谁来决定发行货币，另一个是验证交易的合法性，回过头来说明第一个问题：</p>
<p>coninbase transaction （交易）是比特币系统中发行货币的唯一方法，其他所有的交易都是把已有的比特币从一个账户转移到另一个账户，coinbase transaction不用指明币的来源，那能铸多少个币呢</p>
<p>比特币刚上线时，每一个新增的区块可以铸50 BTC，但是每21万个区块之后，这个奖励就要减半，现在的情况就是12.5 BTC</p>
<p><strong>注意：orphan block中的奖励的比特币就无效了</strong></p>
<h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4.总结"></a>4.总结</h2><p>最后，那么比特币要取得的共识是什么？去中心化账本中的内容要取得共识，只有获得记账权的结点才能往里面写东西，</p>
<p>我们通过算例来获得记账权，每秒钟能够试多少个nonce的数目（hash rate），hash rate越高，得到出块奖励的概率越大</p>
]]></content>
      <categories>
        <category>区块链</category>
      </categories>
      <tags>
        <tag>区块链</tag>
      </tags>
  </entry>
  <entry>
    <title>BTC四---实现</title>
    <url>/2020/08/30/%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><h2 id="transaction-based-ledger"><a href="#transaction-based-ledger" class="headerlink" title="transaction-based ledger"></a>transaction-based ledger</h2><p>BTC(比特币):基于交易的账本模式（transaction-based ledger），每个区块记录交易信息，但是系统中没有统一的记录，比如需要知道某个账户有多少钱，这个还需要交易记录来推算</p>
<p>比特币的全节点要维护一个UTXO的数据结构</p>
<a id="more"></a>

<p>UTXO:Unspent Transaction Output,还没有被花出去的交易的输出，区块链中有很多交易，有些交易的输出可能被花掉了，有些还没有被花掉，没有被花掉的交易的输出的集合叫做UTXO</p>
<p>UTXO中的每个元素要给出产生这个输出的交易的hash值，以及他在这个交易里是第几个输出，就可以定位到这个UTXO中的输出，那么这个UTXO集合的作用是什么？为什么要维护这样一个数据结构</p>
<p>作用：防范double spending attack，所以全节点要在内存中维护UTXO数据结构，以便快速检测double spending attack，</p>
<p>随着交易的发布，每个交易要消耗UTXO中的输出，同时也会产生一些新的输出</p>
<p>每个交易所有输入的金额，要等于所有输出的金额：total inputs = total outputs</p>
<p>发布区块的那个结点为什么要把你的交易打包在区块里？这样做对她有什么好处吗？</p>
<p>如果只有出块奖励，那么自私的结点就只会打包他自己的交易，同时也节省带宽</p>
<p>所以比特币系统设定了第二个激励机制：交易费（transaction fee），你把我的交易打包在区块里，我给你点小费，所以就会出现total inputs &gt;= total outputs的情况，多的比特币充当了小费</p>
<p><img src="/2020/08/30/%E5%AE%9E%E7%8E%B0/QQ%E6%88%AA%E5%9B%BE20200817210059.png"></p>
<p>目前矿工去争取记账权，主要还是为了得到出块奖励，但是因为21个区块都会减少出块奖励</p>
<p>比特币系统中差不多10分钟会创建一个区块，计算下来差不多每四年就会减半（出块奖励）</p>
<h2 id="区块的例子"><a href="#区块的例子" class="headerlink" title="区块的例子"></a>区块的例子</h2><p>account-based ledger</p>
<p>以太坊就是这种模式，在这种模式总，系统显式的记录每个账户上有多少个币，比特币的隐私保护就比较好一些</p>
<p><img src="/2020/08/30/%E5%AE%9E%E7%8E%B0/image-20200817210819638.png"></p>
<p>Height:是区块的序号，Difficulty：挖矿的难度（每隔2016个区块要调整这个难度，保持出块时间在10分钟左右）</p>
<p><img src="/2020/08/30/%E5%AE%9E%E7%8E%B0/QQ%E6%88%AA%E5%9B%BE20200817211158.png"></p>
<p>注意：计算hash值都是计算block header的哈希值，不包含block body的哈希值</p>
<p>所谓的挖矿，就是不断地调整随机数nonce，使得整个block header的哈希值小于等于给定的目标阈值，这个目标阈值表示成16进制就是前面有一长串的0，所以凡是符合难度要求的区块，它的块头的哈希值，算出来都是要有一长串的0</p>
<p><img src="/2020/08/30/%E5%AE%9E%E7%8E%B0/QQ%E6%88%AA%E5%9B%BE20200817211615.png"></p>
<p><img src="/2020/08/30/%E5%AE%9E%E7%8E%B0/QQ%E6%88%AA%E5%9B%BE20200817211913.png"></p>
<p><img src="/2020/08/30/%E5%AE%9E%E7%8E%B0/QQ%E6%88%AA%E5%9B%BE20200817212243.png"></p>
<p>每个发布的区块里都包含一个特殊的铸币交易</p>
<p><img src="/2020/08/30/%E5%AE%9E%E7%8E%B0/QQ%E6%88%AA%E5%9B%BE20200817212744.png"></p>
<p>这个对Merkle tree的根哈希值有什么影响吗</p>
<p><img src="/2020/08/30/%E5%AE%9E%E7%8E%B0/QQ%E6%88%AA%E5%9B%BE20200817213102.png"></p>
<p>coinbase中的前八个字节当作extra nonce来用nonce从2^32-&gt;2^96</p>
<p>所以真正挖矿的时候是有两层循环的，外层循环调整coinbase域的extra nonce ，算出block header中的根哈希值之后，内层循环在调整header里的nonce</p>
<p><img src="/2020/08/30/%E5%AE%9E%E7%8E%B0/QQ%E6%88%AA%E5%9B%BE20200817213639.png"></p>
<p><img src="/2020/08/30/%E5%AE%9E%E7%8E%B0/QQ%E6%88%AA%E5%9B%BE20200817213948.png"></p>
<h2 id="概率分析"><a href="#概率分析" class="headerlink" title="概率分析"></a>概率分析</h2><p>每次尝试nonce可以看作是Bernoulli trial：a random experiment with binary outcome</p>
<p>挖矿，每次尝试nonce，成功的概率是微乎其微的，大概率是不行的，如果我们做很多的Bernoulli trial，每个实验都是随机的，这些Bernoulli trial就构成了Bernoulli process：a sequence of independent Bernoulli trials，Bernoulli trial的一个性质是无记忆性：memory less，你做大量的实验，前面的结果和后面的结果是没有关系的</p>
<p>实验很多，每次成功的概率很小，多重伯努利可以用Poisson process来近似，我们关心的是，系统中产生下一个区块的时间，这个在概率中可以推导出来出块时间是服从指数分布的exponential distribution</p>
<p>整个系统平均的出块时间是十分钟，这个时间是比特币协议设计出来的</p>
<p>具体到每个矿工，他能够挖到下一个区块的时间，取决于这个矿工的算力占系统算力的百分比，比如说，你的算力占到系统算力的1%，平均下来，系统里每产生一百个区块，其中有一个区块就是你挖矿挖到的，平均你要等1000分钟才能产生一个区块</p>
<p><img src="/2020/08/30/%E5%AE%9E%E7%8E%B0/QQ%E6%88%AA%E5%9B%BE20200817215856.png"></p>
<p>这个性质有时候也叫：process free，过去的process是不算数的</p>
<p>假设一下，如果有某个puzzle不满足process free，会出现什么情况：算力强的矿工具有不成比例的优势，因为算力强的矿工过去做的工作肯定是多的，比如有两个矿工，一个矿工的算力是另一个的十倍，那么他挖到矿的概率也是另一个的十倍，这样就满足process free，如果不满足，就会大于十倍！其实process free 恰恰是挖矿公平性的保证。</p>
<h2 id="比特币的总量"><a href="#比特币的总量" class="headerlink" title="比特币的总量"></a>比特币的总量</h2><p>挖矿获得的出矿奖励，是比特币长生的唯一途径，然而这个值每四年就会减半，比特币的总量呈现几何趋势</p>
<p>genmetric series</p>
<p><img src="/2020/08/30/%E5%AE%9E%E7%8E%B0/QQ%E6%88%AA%E5%9B%BE20200819203300.png"></p>
<p>挖矿对维护比特币系统的安全是至关重要的：Bitcoin is secured by mining，只要大部分算力在诚实的结点手里，系统的安全就可以得到保证。出矿奖励随着出块会减半，那么人们的动力是否会减少呢？从过去的几年来看，恰恰是相反的，比特币的价格是飙升的，如果趋于0之后，是不是就没有动力挖矿了呢？还有第二种激励机制：交易费</p>
<p>比特币的安全性的分析，①假设大部分算力是掌握在诚实的矿工手里，我们能得到什么样的安全保证，能不能保证写入区块里的交易都是合法的？如果落在了10%的不诚实的结点手里，这个节点能不能偷币？能不能把别人账上的钱转给自己？不能，因为他无法伪造别人的签名（需要知道别人的私钥）。如果把这个交易硬写道区块链里呢？</p>
<p><img src="/2020/08/30/%E5%AE%9E%E7%8E%B0/QQ%E6%88%AA%E5%9B%BE20200819204852.png"></p>
<p>②恶意的结点能不能double spending？</p>
<p>如果M-&gt;A存在某种不可逆的效果，那么M-&gt;M’就可以从中获得不当的利益，比如网上购物，M购买了一些商品，然后网站接受比特币支付，M把帐转给这个网站，网站监听到这个交易写入到区块链里了，以为， 支付成功了，所以把商品给了M，M拿到商品之后，又发起了一个交易M-&gt;M’把钱转给自己，然后按照下面这个区块扩展最长合法链，这样上面那个交易就作废了。</p>
<p><img src="/2020/08/30/%E5%AE%9E%E7%8E%B0/QQ%E6%88%AA%E5%9B%BE20200819205358.png"></p>
<p>如何防范double spending？类似上面这种攻击</p>
<p><img src="/2020/08/30/%E5%AE%9E%E7%8E%B0/QQ%E6%88%AA%E5%9B%BE20200819210210.png"></p>
<p><img src="/2020/08/30/%E5%AE%9E%E7%8E%B0/QQ%E6%88%AA%E5%9B%BE20200819210314.png"></p>
<p>区块链是不可篡改的账本：irrevocable ledger，那是不是说凡是写入区块链的内容，永远改不了呢？根据上面的分析可知，这种不可篡改性，只是一种概率上的保证</p>
<p>其实，还有一种zero confirmation，0个确认，这个意思是说，这个转账交易发布出去了，但是还没有被写入区块链里，商家就确认了这个交易，这种在现实生活中还是比较普遍的，</p>
<p>原因：</p>
<p>①比特币协议缺省的设置是：结点接收最先听到的那个交易，两个交易有冲突，最先听到哪个，接收哪个，所以发布一个M-&gt;A,最先听到这个，在zero confirmation的这个位置，诚实的结点有比较大的几率是不会接收M-&gt;M’这个交易的 </p>
<p>②很多购物网站，从你支付成功，到他把货品发给你，是有一定的时间间隔的，如果发现M-&gt;M’这个转账交易没有在最长合法链里，电商就可以选择取消发货。</p>
<p>假设某个有恶意的结点获得了记账权，他还能干什么坏事？</p>
<p> 能不能不把某些合法的交易写道区块链里？这是可以的，但是会少交易费，比特币规定某个区块的大小是有限制的，最多不能超过1M字节，某个节点交易太多，这些交易就只能等到下个区块在发布</p>
<p>selfish mining：在商家等待6个区块的时候，M-&gt;M’先不发布，在私下偷偷的挖矿，但是不发布，等挖矿创建的区块比6个区块多的时候，一下子全部发布，M-&gt;M’这条链就成了最长合法链；正常的情况是，挖到区块，立马发布，要不然就被别人抢了，所以selfish mining有一个前提，恶意的结点的算力要超过诚实的结点的算力，但是是不可能的</p>
<p>selfish mining还有什么目的，上述是分叉攻击的目的，假设我们能不是为了回滚以前的交易，就是为了正常的挖矿，赚取出块奖励，selfish mining有没有什么好处？减少竞争：别人挖了一个，我已经挖了两个，然后直接抛出去两个,让别人做一些无用功。</p>
]]></content>
      <categories>
        <category>区块链</category>
      </categories>
      <tags>
        <tag>区块链</tag>
      </tags>
  </entry>
  <entry>
    <title>BTC一---密码学基础</title>
    <url>/2020/08/29/%E5%AF%86%E7%A0%81%E5%AD%A6%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h1 id="密码学基础"><a href="#密码学基础" class="headerlink" title="密码学基础"></a>密码学基础</h1><h1 id="1-哈希"><a href="#1-哈希" class="headerlink" title="1.哈希"></a>1.哈希</h1><p>​    比特币属于加密货币，但是区块链上所有的交易都是公开的，包括账户的地址，转账的金额。</p>
<p>比特币用到了密码学的两个内容：哈希和签名</p>
<p>哈希在比特币中：<code>cryptographic hash function</code></p>
<p>它在密码学中要求的两个性质：</p>
<p>​    ①<code>collision</code>（哈希碰撞） 和<code> resistance</code>：没有什么高效的方法人为的制造哈希碰撞，</p>
<p>​        解释为对于一个x，没有什么高效的办法，找到另一个y，使<code>H(x) = H(y)</code>。</p>
<p>​        用法：对于一个m，哈希值为H(m),没有办法篡改内容，而又不被检测出来，因为找不到另外一个m’，使得<code>H(m) = H(m&#39;)</code>。</p>
<p>​        在理论上，这个性质是证明不出来的，只能依靠实际的经验 例如：md5，我们以前没有办法找到制造哈希碰撞的办法，然而现在却可以。</p>
<a id="more"></a>

<p><img src="/2020/08/29/%E5%AF%86%E7%A0%81%E5%AD%A6%E5%8E%9F%E7%90%86/QQ%E6%88%AA%E5%9B%BE20200730213309.png"></p>
<p>  如果我们有一个256位的哈希值，他的输出空间就为2^256，但是输入空间是无限的，根据鸽笼原理（抽屉原理），必然会导致哈希碰撞。</p>
<p>②<code>hiding</code>:哈希函数的计算过程是单向的，不可逆的,x可以计算得到H(x),但是H(x)计算不出x，也就是说，H(x)哈希值没有泄漏x的信息。</p>
<p>这个性质的前提是，x的输入范围要足够的大，使得蛮力，遍历破解的方法是不可行的，输入的分布还要比较均匀，各种取值的概率差不多。</p>
<p><img src="/2020/08/29/%E5%AF%86%E7%A0%81%E5%AD%A6%E5%8E%9F%E7%90%86/QQ%E6%88%AA%E5%9B%BE20200730215143.png"></p>
<p><img src="/2020/08/29/%E5%AF%86%E7%A0%81%E5%AD%A6%E5%8E%9F%E7%90%86/QQ%E6%88%AA%E5%9B%BE20200730215658.png"></p>
<p>将预测结果作为x,算出一个哈希值,将这个哈希值可以公布出去，因为有<code>hiding</code>的性质，只知道这个哈希值，是不能知道预测结果是什么的，在第二天收盘之后，再将预测值公布出去，因为存在<code>collision  resistance</code>的性质，这个预测结果是不可能的被篡改的，这就是一个<code>sealed envelope</code>的功能。</p>
<p>x—-&gt;H(x)</p>
<p><img src="/2020/08/29/%E5%AF%86%E7%A0%81%E5%AD%A6%E5%8E%9F%E7%90%86/QQ%E6%88%AA%E5%9B%BE20200730220318.png"></p>
<p>在实际操作中，不是直接对x取哈希值，而是再x后面加上一个<code>nonce</code>（随机数），保证x的随机性，和分布均匀</p>
<p>哈希函数除了在密码学中要求的这两个性质之外。</p>
<p>在比特币中还要求<code>puzzle friendly</code></p>
<p>哈希值的计算结果是不能被预测的，如果想要得到某个范围之间的哈希值，只能一个一个输入结果去试</p>
<p>那这个性质为什么叫<code>puzzle friendly</code>呢</p>
<blockquote>
<p>在比特币中的挖矿：实际上就是找一个nonce（随机数），这个nonce和区块的块头里的其他信息，合在一起，作为输入，取出一个哈希，这个哈希值要小于等于某个指定的目标阈值</p>
<p><img src="/2020/08/29/%E5%AF%86%E7%A0%81%E5%AD%A6%E5%8E%9F%E7%90%86/QQ%E6%88%AA%E5%9B%BE20200730221330.png"></p>
<p>比特币即区块链，区块链是一个一个区块组成的链表，每个区块有一个块头，块头中有很多的域，其中有一个域是我们可以设置的nonce，挖矿的过程就是不停地去试不同的随机数，使得整个块头取哈希值之后落在指定的范围之内（&lt;=target space）。</p>
<p>puzzle friendly 就是说挖矿的过程，没有捷径，只能靠不停地去试大量的nonce，才能找到符合要求的解，所以这个过程才可以被称为“<strong>工作量证明</strong>（proof of work）”，你找到了nonce，一定是你做了大量的工作，因为没有别的捷径。</p>
<p>虽然挖矿的过程需要大量的工作量，但是只要找到了符合要求的nonce，将这个nonce发布出去，其他人要验证这个nonce是很容易的，只要算一次哈希值就行了。这个就叫做“difficult to solve ，but easy to verify”。</p>
</blockquote>
<p>比特币中用到的哈希函数叫做SHA-256。</p>
<p>SHA:<code>secure Hash Algorithm</code> </p>
<p>我们上面所说的三个性质，他都是满足的</p>
<h1 id="2-签名"><a href="#2-签名" class="headerlink" title="2.签名"></a>2.签名</h1><p>  比特币账户中的账户管理，在日常生活中，可以去中心化的管理机构，比如银行办理手续，</p>
<p>但是在比特币中是去中心化的，那么怎么办理账户呢：每个用户自己决定开户 ，不需要任何人批准，</p>
<p>开户的过程很简单，就是创建一个公钥和私钥的对。</p>
<p><img src="/2020/08/29/%E5%AF%86%E7%A0%81%E5%AD%A6%E5%8E%9F%E7%90%86/QQ%E6%88%AA%E5%9B%BE20200730222824.png"></p>
<p>公私钥是来源于非对称加密体系：<code>asymmetric encryption algorithm</code>。</p>
<p>  最早的加密体系是对称的:<code>symmetric encryption algorithm</code>   —-&gt;两个人之间要进行通讯，但这个过程可能是被窃听的，所以我们两个人之间商量一个密钥，用来加密，发送信息，再用这个密钥来解密，因为这个加密和解密的密钥用的是同一个，所以被称为对称加密体系，这个前提是，有某种安全的渠道，可以把这个密钥分发给通讯的双方（这也是对称加密的一个弱点，密钥的分发不是很方便）</p>
<p><img src="/2020/08/29/%E5%AF%86%E7%A0%81%E5%AD%A6%E5%8E%9F%E7%90%86/QQ%E6%88%AA%E5%9B%BE20200730223101.png"></p>
<p>非对称加密：加密用公钥：<code>public key</code> ，解密用私钥:<code> private key</code>,我要把信息传给你，用你的公钥对信息加密，你收到信息，再用你的私钥解密，得到信息，需要注意的是，加密解密用的公钥私钥，都是接收方的，好处是什么？</p>
<blockquote>
<p>大家都可以知道我的公钥，都可以给我发消息，但是私钥是保存在本地的，不用传给对方，这就解决了对称加密过程，密钥分发带来的不方便的问题</p>
<p>所以比特币创建账户，就是在本地创建一个公钥私钥对，这个公钥就相当于银行账户，私钥相当于银行账户密码，知道私钥就可以把账户上的钱转走。</p>
</blockquote>
<p>  比特币虽然叫加密货币，但是其实他是不加密的，信息都是公开的，那我们要这个公钥私钥干嘛？</p>
<blockquote>
<p>实际上就是用来作签名，在我转比特币给另一个账户的时候，别人怎么知道是不是我转的，还是别人冒名顶替转的？</p>
<p>这个时候就需要我用私钥再这个信息上做一个签名，别人再用我的公钥验证我的私钥生成的签名</p>
<p>万一两个人创建的比特币账户的公私钥对相同怎么办？如果是256位的哈希，产生相同的公私钥对的概率是微乎其微的，</p>
<p>这个概率比地球爆炸的概率还要小！</p>
</blockquote>
<p>在生成比特币账户的公私钥的时候，假设前提是我们有一个好的随机源，如果随机源不好，那么这个时候还是有可能两个人的公私钥是相同的，其实不仅是生成账户的时候，在签名的时候也需要有好的随机源！</p>
<h1 id="3-总结"><a href="#3-总结" class="headerlink" title="3.总结"></a>3.总结</h1><p>  密码学中，两个功能，一个是哈希，一个是签名，这两个功能是可以结合起来使用的；</p>
<p>比特币系统中，一般是先对一个message取一个哈希，然后再对这个哈希值签名。</p>
]]></content>
      <categories>
        <category>区块链</category>
      </categories>
      <tags>
        <tag>区块链</tag>
      </tags>
  </entry>
  <entry>
    <title>BTC七---挖矿</title>
    <url>/2020/08/30/%E6%8C%96%E7%9F%BF/</url>
    <content><![CDATA[<h1 id="挖矿"><a href="#挖矿" class="headerlink" title="挖矿"></a>挖矿</h1><h2 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h2><p><img src="/2020/08/30/%E6%8C%96%E7%9F%BF/QQ%E6%88%AA%E5%9B%BE20200828210256.png"></p>
<a id="more"></a>

<p><img src="/2020/08/30/%E6%8C%96%E7%9F%BF/QQ%E6%88%AA%E5%9B%BE20200828210616.png"></p>
<p>比特币网络中大部分节点是轻结点，如果只需要转账，不需要挖矿的话，没必要运行一个全节点。</p>
<p>在挖矿过程中，如果你监听到别人发布了一个区块，这个区块是合法的，也是在延伸最长合法连，这个时候你应该停止已有的挖矿，然后重新在本地组装一个侯选区块，重新挖矿，因为你要沿着这个新发布的区块向下挖的话，那么你本地所组装的这个区块中，包含的交易就会发生变化，有些交易可能已经包含到已经被发布的这个区块里了，block header的内容也会发生变化，Merkle tree的根哈希值，以及指向前一个区块的指针，这样做是不是有些可惜？</p>
<p>其实是不可惜的，因为前面我们提到一个挖矿的性质：无记忆性memory less（process free），所以你是坚持挖原来的区块，还是改成挖一个新组装的区块，成功的机率是一样的。</p>
<p>即时挖到了合法的区块，发布到区块链上，也不是说就是胜利了，有可能你发布的这个区块，最终没有成为最长合法链，</p>
<p>可能存在一些risk condition，别人同时发布了一个合法的区块，或者是存在一些你不知道的double spending，使得你这个区块中某些交易最后是有冲突的。</p>
<p>比特币是怎么保证安全性的？两方面</p>
<p>一方面：密码学上的保证：别人没有你的私钥，就不能伪造你的签名，这个的前提是，系统中拥有大多数算力的矿工是好的，是遵守协议的；</p>
<p>另一方面：共识机制。</p>
<h2 id="挖矿相关"><a href="#挖矿相关" class="headerlink" title="挖矿相关"></a>挖矿相关</h2><p>挖矿的设备：越来越趋向于专业化，最早的时候大家都是用普通的cpu去挖矿。</p>
<p>如果现在，你专门买一台计算机用来挖矿，其实是不划算的，因为计算机中的大部分内存都是闲置的，挖矿只用到其中很小一部分内存，cpu中的大部分部件也是闲置的，因为挖矿的操作只用到了通用cpu中的很少的一部分指令，硬盘和其他很多资源也用不到。</p>
<p>第二代：GPU–&gt;比cpu挖矿的效率高得多，GPU用于大规模的并行计算（像深度学习就用到了GPU，其中有很多矩阵的乘法），但是GPU用来挖矿，其实还是有点浪费的，里面有很多部件仍然处于闲置状态，比如用于浮点数计算的部件（比特币的挖矿只用到了整数计算）</p>
<blockquote>
<p>最近几年，GPU价格上涨的很快，有些人把它归于深度学习的火热，其实有很多GPU是用来挖矿的，不过有个好消息，现在比特币挖矿难度的提升，用GPU挖矿已经划不来了，所以都不竞争去买GPU用于挖矿了。</p>
</blockquote>
<p>现在用什么挖矿？用ASIC（Application Specific Integrated Circuit）芯片，它上面没有多余的电路逻辑，整个芯片就是为了比特币挖矿计算哈希值的操作而设计的，性价比最高，而且，为某一种加密货币设计的ASIC芯片，只能用来挖这一种加密货币，除非这两个加密货币使用同一个mining puzzle，有些加密货币新发行的时候，为了解决能源启动问题，他故意用一个已有的加密货币的mining puzzle，可以吸引更多的人来挖矿，这样的mining puzzle叫做merge mining。</p>
<p>ASIC芯片的研发周期是很长的，比特币的ASIC的芯片需要使用一年的时间，已经算是很快了，创造了ASIC芯片史上的奇迹，在这么长的时间里面，如果比特币的价格发生了很大的变化的话，前期投入的研发费用有可能就打水漂了。</p>
<p>即时在比特币发展的黄金时期，比特币价格上涨，挖矿是有利可图的，但是竞争也是越来越激烈的，定制的ASIC芯片可能用不了几个月就过时了，相当于一个军备竞赛。</p>
<blockquote>
<p>有研究表明，大部分的ASIC矿机，利润是在他上市的前两个月获得的，这个时候的算力在同类产品中最强，所以购买ASIC矿机的时机很重要，现在一般都是提前预定，如果不能及时发货，对矿工就有损利益，有些不良厂商，生产出了矿机，不立即发售，而是自己先用他挖矿</p>
</blockquote>
<p>有些新的加密货币设计的是Alternative mining puzzle 设计的初衷是：ASIC resistance（能够抗ASIC芯片化，目的是为了让通用的计算机也能参与挖矿）</p>
<p>挖矿的另一个趋势是：大量矿池的出现，单个矿工，即使用了ASIC芯片，挖矿从平均收益上看，是有利可图的，但是收入是十分不稳定的：比特币的平均出块时间是10分钟，但是这是总的矿工的平均，从单个矿工来看，可能他要挖一两年才出一个区块，就有点买彩票的意味了；单矿工还要面临一个困难：他除了挖矿之外，还要承担全节点的责任。</p>
<hr>
<p>矿池：就是把矿工组织起来，作为一个整体，矿池的架构是：一个全节点，会驱动很多的矿机</p>
<p><code>miner</code>只负责计算哈希值，<code>pool manager</code>承担全节点的其他职责，<code>pool manager</code>负责监听网上的交易，把这些交易组织打包成一个候选区块，同时看有没有其他的节点抢先发布区块。</p>
<p>矿池还能解决矿工收入不稳定的问题，有了收入，一起分配。分配的问题：如果矿机和矿池是分布式的（不在同一个机构），矿工和矿主不在同一个地方，矿工要加入一个矿池，就是按照这个矿池规定的通信协议，跟矿主练习，矿主把要计算的哈希值的任务分配给他，矿工计算完之后，把结果返回，有出矿奖励大家一起分配，如何分配？</p>
<blockquote>
<p>平均分配？明显的问题是吃“大锅饭”，干好干坏一个样；因此要按照每个矿工的贡献大小进行分配：这个地方同时需要工作量证明，如何证明？</p>
<p>矿工的收入不稳定是因为挖矿太难了，如果降低难度，收入就能稳定，怎么降低难度？原来的要求，找到nonce，匹配target，和block header算哈希前面至少70个零，现在降低难度，前面只要有60个零就行，这样挖到的叫做一个</p>
<p><code>share</code>：<code>almost valid block</code>,矿工挖到这样一个share之后，把他提交给矿主。</p>
<p>矿主拿到share有什么用？这个除了证明矿工的工作量之外，没有其他的用处，不可能发不出去，因为这个区块不是合法的，所以矿主就记录每个矿工提交了多少个share，将来等到某个矿工真的挖到了某个区块之后，再把这个出块奖励，按照每个矿工提交的share的数目分配。</p>
</blockquote>
<p>每个矿工挖到矿的概率取决于他尝试的nonce的数目，尝试的nonce越多，share就越多，所以可以把share作为工作量的衡量。</p>
<p>有没有可能矿工挖到了区块之后，不把他提交给矿主，自己独享？</p>
<blockquote>
<p>每个矿工的任务是由矿主来决定的，矿主负责组装好区块，然后让矿工尝试nonce，而且，光是调整nonce是不够的，还要调整coinBase parameter，所以矿主可能就是把不同的coinbase parameter对应的nonce的范围交给不同的矿工去尝试，那么这个区块里面包含了什么？</p>
<p>coinbase transaction里面有个收款人的地址，这个地址填的是矿主的地主，如果矿工不提交给矿主，他是收不到钱的。</p>
</blockquote>
<p>他不可能偷出块奖励，但是她有没有可能捣乱？（平时挖到一个share，作为工作量证明，但是等他真正挖到一个合法的区块的之后，他把它扔掉）</p>
<blockquote>
<p>但是这样做对他来说并没有什么经济上的好处，矿池之间是存在竞争关系的，有可能为了打击竞争对手，故意派一些矿工到对手的矿池里挖矿，“卧底”！</p>
</blockquote>
<p><img src="/2020/08/30/%E6%8C%96%E7%9F%BF/QQ%E6%88%AA%E5%9B%BE20200831215109.png"></p>
<p>​                                                                                    矿池在各个国家的分配比例</p>
<p><img src="/2020/08/30/%E6%8C%96%E7%9F%BF/QQ%E6%88%AA%E5%9B%BE20200831215228.png"></p>
<p>​                                                            2014年 GHash.IO矿池总算力占到了全球的51%以上</p>
<p>已经可以发动51攻击了！（当时引起了恐慌）</p>
<p>GHash主动降低总算力，以免动摇大家对比特币的信心</p>
<p><img src="/2020/08/30/%E6%8C%96%E7%9F%BF/QQ%E6%88%AA%E5%9B%BE20200831215554.png"></p>
<p>​                                                                                            2018年算力分布</p>
<p>假设一个机构有了一半以上的算力，他不一定要把算力都集中在一个矿池里，它可以把算力分不到不同的矿池里，平时是隐藏的，真正需要发动攻击的时候就结合起来。</p>
<p>矿工转换矿池是很容易的，所以这就是矿池带来的一个危害，如果没有矿池要发动51攻击的话，攻击者要投入大量的硬件成本来购买到足够的矿机，能够达到系统中半数以上的算力。</p>
<p>一般来说，pool manager也要收取一部分的出块奖励作为管理费，有的有恶意的矿池在发动攻击前，故意把矿池的管理费降得特别低，甚至是赔本，吸引到足够多的矿工之后，就可以发动攻击了。</p>
<hr>
<p>假设有矿池达到了51%的算力，他具体能发动什么攻击呢？</p>
<blockquote>
<p>分叉攻击</p>
<p>Boycott：封锁禁域。所有有关某个节点的交易，他都不包含进去，而且这个攻击也不需要等待6个确认，仗着自己的算力强，公开抵制有关某个结点的交易。</p>
</blockquote>
<p>攻击者的矿池中事不明真相的矿工群众，因为每个矿工只是计算哈希值，他并不知道网上有什么样的交易，发布了什么区块，并不知道double spending的存在。</p>
<p>另外，不要把51%的阈值，当成一个门槛，这个其实都是概率，而且，每个矿池所占的算力比重，本身也是一种估计而已，而且实时变化</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>大型矿池的出现，有一定的好处：给矿工减轻了负担，收入分配也更加稳定。</p>
<p>也有一定的危害：发动51攻击更容易了 <code>on demand mining</code></p>
]]></content>
      <categories>
        <category>区块链</category>
      </categories>
      <tags>
        <tag>区块链</tag>
      </tags>
  </entry>
  <entry>
    <title>BTC六---挖矿难度</title>
    <url>/2020/08/30/%E6%8C%96%E7%9F%BF%E9%9A%BE%E5%BA%A6/</url>
    <content><![CDATA[<h1 id="挖矿难度"><a href="#挖矿难度" class="headerlink" title="挖矿难度"></a>挖矿难度</h1><h2 id="为什么要调整挖矿难度"><a href="#为什么要调整挖矿难度" class="headerlink" title="为什么要调整挖矿难度"></a>为什么要调整挖矿难度</h2><p>调整挖矿难度，就是调整目标空间在整个输出空间中所占的比例</p>
<p>比特币的哈希算法是SHA-256，256位的哈希值，所以输出空间位2^256个可能取值，调整目标空间占输出空间的比例，通俗的说，就是这个哈希值前面要多少个零，合法的哈希，算出来，前面至少要有70个零，但是严格的话还是按照定义来计算哈希值。</p>
<a id="more"></a>

<p>另外一种概念：挖矿难度，挖矿难度和目标阈值成反比</p>
<p><img src="/2020/08/30/%E6%8C%96%E7%9F%BF%E9%9A%BE%E5%BA%A6/QQ%E6%88%AA%E5%9B%BE20200826214434.png"></p>
<p>挖矿难度最小就是1，所以这时候target很大，那我们为什么要调整挖矿难度呢？如果不调，会有什么问题：系统中的总算力越来愈强，挖矿难度不变的话，出块时间就会越来越短，一开始没什么人，按照设计是十分钟出一个区块，后来一分钟就可以出一个区块，再到后来，用的设备越来越先进，不到一秒。</p>
<p>这么快不好吗？我每出现一个交易就可以及时的写入区块里，减少了系统的响应时间，这不是好事吗？其实不是件好事，这样会有什么问题吗？</p>
<p>如果两个结点同时发布了一个区块，那么这个时候可能会出现分叉，分叉就成了常态，可能不仅仅是二分叉，分叉如果过多，对于系统达成共识，是没有好处的，也危害到系统的安全性，比特币系统是假设，大部分算力都掌握在诚实的结点手里，系统当中的总算力越强，安全性就越好（发动51% attack的算力要求就更大）</p>
<p><img src="/2020/08/30/%E6%8C%96%E7%9F%BF%E9%9A%BE%E5%BA%A6/QQ%E6%88%AA%E5%9B%BE20200826220208.png"></p>
<p>这个时候，可能10%的算力就可以发动攻击了，所以出块时间，不是越短越好。比特币系统中设计的10分钟的出块原则是不是最优的呢？这个不一定，这个只是说，出块时间要有一个常熟的波动范围，不能无限的减少下去，这个对于支付系统来说，其实还是比较长了。</p>
<p>以太坊就将出块时间降低到了15秒，这样以太坊就要设计一个新的共识协议：ghost，这个之后会提到，以太坊同样也会调整挖矿难度，是出块时间保持稳定；所以，出块时间没有规定多长，但是不管多长，都要保持稳定，而不能无限地减少下去 </p>
<h2 id="如何调整挖矿难度"><a href="#如何调整挖矿难度" class="headerlink" title="如何调整挖矿难度"></a>如何调整挖矿难度</h2><p>比特币中规定了，每隔2016个区块要重新调整目标阈值，大概是每两个星期调整一下</p>
<p><img src="/2020/08/30/%E6%8C%96%E7%9F%BF%E9%9A%BE%E5%BA%A6/QQ%E6%88%AA%E5%9B%BE20200828203802.png"></p>
<p>调整的公式：</p>
<p><img src="/2020/08/30/%E6%8C%96%E7%9F%BF%E9%9A%BE%E5%BA%A6/QQ%E6%88%AA%E5%9B%BE20200828204035.png"></p>
<p>实际的代码中，上调和下调实际上都是有4倍的限制的，最多增大，下调4倍</p>
<p>那么如何让所有的矿工，都调整目标阈值呢？怎么能让大家都听话？如果恶意的区块不调整target，那么诚实的结点不会认可：检查的内容包括nBits（target的编码版本）域</p>
<p><code>比特币系统中总算力的变化情况</code></p>
<p><img src="/2020/08/30/%E6%8C%96%E7%9F%BF%E9%9A%BE%E5%BA%A6/QQ%E6%88%AA%E5%9B%BE20200828205244.png"></p>
<p><code>算力难度的增长情况</code></p>
<p><img src="/2020/08/30/%E6%8C%96%E7%9F%BF%E9%9A%BE%E5%BA%A6/QQ%E6%88%AA%E5%9B%BE20200828205539.png"></p>
<p>符合难度调整的设计目标</p>
<p><code>难度调整曲线</code></p>
<p><img src="/2020/08/30/%E6%8C%96%E7%9F%BF%E9%9A%BE%E5%BA%A6/QQ%E6%88%AA%E5%9B%BE20200828205648.png"></p>
<p>说明挖矿的人越来越多，设备越来越先进</p>
<p><code>每天的出块时间</code></p>
<p><img src="/2020/08/30/%E6%8C%96%E7%9F%BF%E9%9A%BE%E5%BA%A6/QQ%E6%88%AA%E5%9B%BE20200828205804.png"></p>
<p><code>最近半年的出块事件</code></p>
<p><img src="/2020/08/30/%E6%8C%96%E7%9F%BF%E9%9A%BE%E5%BA%A6/QQ%E6%88%AA%E5%9B%BE20200828205845.png"></p>
<p><img src="/2020/08/30/%E6%8C%96%E7%9F%BF%E9%9A%BE%E5%BA%A6/QQ%E6%88%AA%E5%9B%BE20200828210138.png"></p>
]]></content>
      <categories>
        <category>区块链</category>
      </categories>
      <tags>
        <tag>区块链</tag>
      </tags>
  </entry>
  <entry>
    <title>BTC二---比特币中的数据结构</title>
    <url>/2020/08/29/%E6%AF%94%E7%89%B9%E5%B8%81%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<h1 id="比特币中的数据结构"><a href="#比特币中的数据结构" class="headerlink" title="比特币中的数据结构"></a>比特币中的数据结构</h1><h2 id="1-区块链"><a href="#1-区块链" class="headerlink" title="1.区块链"></a>1.区块链</h2><p>这里要用到一个重要的概念叫做哈希指针。</p>
<p>hash pointers，哈希指针，除了要保存这个结构体的地址之外，还要保存这个结构的的哈希值（不仅可以知道这个结构体在内存中的位置，还可以知道这个结构体的内容有没有被篡改）</p>
<p>区块链相比较于普通的链表有何区别？</p>
<a id="more"></a>

<p>①用哈希指针替代了普通的指针</p>
<p><img src="/2020/08/29/%E6%AF%94%E7%89%B9%E5%B8%81%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/QQ%E6%88%AA%E5%9B%BE20200802193317.png"></p>
<p>区块链示例</p>
<p><img src="/2020/08/29/%E6%AF%94%E7%89%B9%E5%B8%81%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/QQ%E6%88%AA%E5%9B%BE20200802193910.png"></p>
<p><img src="/2020/08/29/%E6%AF%94%E7%89%B9%E5%B8%81%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/QQ%E6%88%AA%E5%9B%BE20200802194121.png"></p>
<p>这样做的好处是</p>
<p>tamper-evident log：篡改-证明 日志，当有人篡改了区块链中某一个区块的某个内容，则它的下一个区块的哈希值就对不上了，以此类推，直到最后一个保存在系统中的哈希值也对不上了，这样我们只需要记住保存在系统中的那最后一个哈希值，就可以检测出对任意区块的修改。这也是区块链和普通链表的一个区别。（多米诺骨牌效应）</p>
<p>有了这个性质，系统中就不需要保存整条区块链的内容，比如它可以只保存最近的几千个区块，如果要用到以前的区块怎么办？</p>
<blockquote>
<p>可以问系统中的其他节点，去要这个区块，有些节点可能是有恶意的（去中心化系统），那么如何知道别人给你的区块是不是正确的呢？就用到哈希指针的这个性质！别人给你的最后的那个区块，算一下哈希值，如果和系统中保存的与之对应的后一个区块的哈希值对比之后相同，则正确</p>
</blockquote>
<h2 id="2-Merkle-tree-默克尔树"><a href="#2-Merkle-tree-默克尔树" class="headerlink" title="2.Merkle tree(默克尔树)"></a>2.Merkle tree(默克尔树)</h2><p>和binary tree（二叉树）的区别是，用哈希指针代替了普通的指针</p>
<p><img src="/2020/08/29/%E6%AF%94%E7%89%B9%E5%B8%81%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/QQ%E6%88%AA%E5%9B%BE20200802200344.png"></p>
<p>和链式结构一样，“牵一发而动全身”。</p>
<p>各个区块由哈希指针连接在一起的，每个区块所包含的交易，是组织成一个Merkle tree的形式，最底层的数据块实际上是某个交易。</p>
<p>每个区块都是由block header和block body组成，block header 保存这个Merkle tree 的根哈希值，不保存这个区块的交易信息，而block body保存交易信息</p>
<p><img src="/2020/08/29/%E6%AF%94%E7%89%B9%E5%B8%81%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/QQ%E6%88%AA%E5%9B%BE20200802200930.png"></p>
<p>Merkle tree的作用？</p>
<p>①提供Merkle proof</p>
<p>比特币中的结点分为两类，一类时全节点，还有一类是轻结点</p>
<p>全节点：保存整个区块的内容，block header和block body都有</p>
<p>轻结点：比如手机上的比特币钱包的应用就属于轻结点，只有一个block header</p>
<p>这样就带来一个问题，如果你想向一个轻结点证明某个交易是写入到了区块链中的 ，该怎么证明？</p>
<p>​    比如我想买你的东西，我就需要向你转钱，我对你说，我对你转钱的交易，已经写到了区块链中了，支付已经完成了，</p>
<p>那么你怎么知道，这个交易已经被写入区块链里了呢？这里就需要用到Merkle proof</p>
<p>一个轻结点，向某个全节点发出请求，请求一个能够证明黄色结点这个交易，被包含在这棵Merkle tree里面的Merkle proof</p>
<p><img src="/2020/08/29/%E6%AF%94%E7%89%B9%E5%B8%81%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/QQ%E6%88%AA%E5%9B%BE20200802202232.png"></p>
<p>最后算出的根哈希值，和block header中存储的root hash比较，就可以证明出tx是否在区块链中</p>
<p>这种证明也叫做：</p>
<p>proof of membership</p>
<p>或</p>
<p>proof of inclusion</p>
<p>如果最底下有n个交易：时间复杂度为O(log(n))</p>
<p>那么可不可以证明，区块链中没有某个交易？也就是proof of non-membership</p>
<p>有一种比较笨的方法，就是把这一整颗Merkle tree都传给轻结点，如果hash值都正确，如果某个交易不在叶结点中，则证明了proof of non-membership，时间复杂度为O(n)，有没有比较高效的方法证明不存在？</p>
<p>如果我们对叶结点的排列顺序不了解，那么是没有办法证明交易不在里面的</p>
<p>如果我们对叶结点的排列顺序做一些要求：对每个交易取哈希值，按照这个哈希值从小到大排序，这个时候是有一个好的证明方法的：但是代价是需要排序</p>
<p><img src="/2020/08/29/%E6%AF%94%E7%89%B9%E5%B8%81%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/QQ%E6%88%AA%E5%9B%BE20200802204313.png"></p>
<p>sorted Merkle tree：排好序的Merkle tree</p>
<p>比特币中没有这种排好序的Merkle tree，因为比特币中根本不需要作这种不存在证明，没有硬性需求，所以比特币中的Merkle tree 不要求排序</p>
<h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3.总结"></a>3.总结</h2><p>比特币中的两种数据结构：区块链和Merkle tree</p>
<p>除了这两种数据结构，哈希指针还用在什么地方？</p>
<p>只要这个数据结构是无环的，都可以用哈希指针来代替普通指针，有环会带来一定的问题</p>
<p><img src="/2020/08/29/%E6%AF%94%E7%89%B9%E5%B8%81%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/QQ%E6%88%AA%E5%9B%BE20200802204834.png"></p>
<p>会出现循环依赖的问题，定不下来任何一个区块，找不到创世纪块</p>
]]></content>
      <categories>
        <category>区块链</category>
      </categories>
      <tags>
        <tag>区块链</tag>
      </tags>
  </entry>
  <entry>
    <title>BTC八---比特币脚本</title>
    <url>/2020/09/02/%E6%AF%94%E7%89%B9%E5%B8%81%E8%84%9A%E6%9C%AC/</url>
    <content><![CDATA[<h1 id="比特币脚本"><a href="#比特币脚本" class="headerlink" title="比特币脚本"></a>比特币脚本</h1><p>比特币脚本，十分简单，不像c++，java，有堆栈的概念，比特币脚本是基于栈的脚本语言</p>
<p>下面来看一个具体的交易：</p>
<a id="more"></a>

<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p><img src="/2020/09/02/%E6%AF%94%E7%89%B9%E5%B8%81%E8%84%9A%E6%9C%AC/QQ%E6%88%AA%E5%9B%BE20200902204839.png"></p>
<p><img src="/2020/09/02/%E6%AF%94%E7%89%B9%E5%B8%81%E8%84%9A%E6%9C%AC/QQ%E6%88%AA%E5%9B%BE20200902205012.png"></p>
<p>size:交易的大小</p>
<p>locktime：用来设定交易的生效时间，0表示立即生效，绝大多数情况下，这个locktime都是0</p>
<p>vin：输入部分</p>
<p>vout：输出部分</p>
<p>time：交易产生的时间</p>
<p>blocktime：区块产生的时间</p>
<p><img src="/2020/09/02/%E6%AF%94%E7%89%B9%E5%B8%81%E8%84%9A%E6%9C%AC/QQ%E6%88%AA%E5%9B%BE20200902205303.png"></p>
<p>交易的输入是一个数组，一个交易可以有多个输入，每个输入都要说明输入花的币都是来自之前那个交易的输出</p>
<p>txid：输出这个币的交易的哈希值，</p>
<p>vout：表示是当前交易里的第几个输出，相当于id</p>
<p>scriptSig：输入脚本，因为最简单的输入脚本就是给一个sianature就行了，证明你有权利花这个钱</p>
<p><img src="/2020/09/02/%E6%AF%94%E7%89%B9%E5%B8%81%E8%84%9A%E6%9C%AC/QQ%E6%88%AA%E5%9B%BE20200902205729.png"></p>
<p>同样是一个数组，</p>
<p>value：表示输出的金额(BTC)，有时候也用Satoshi表示（1Satoshi=0.00000001 BTC）</p>
<p>n：表示这个当前交易的第几个输出，相当于id</p>
<p>scriptPubKey：输出脚本，因为输出脚本最简单的形式就是给出一个public key，所以叫做scriptPubKey</p>
<p>asm：输出脚本的内容，里面包含一系列的操作</p>
<p>reqSigs：表示这个输出需要多少个签名才能兑现</p>
<p>type：输出类型</p>
<p>address：输出地址</p>
<h2 id="脚本执行"><a href="#脚本执行" class="headerlink" title="脚本执行"></a>脚本执行</h2><p><img src="/2020/09/02/%E6%AF%94%E7%89%B9%E5%B8%81%E8%84%9A%E6%9C%AC/QQ%E6%88%AA%E5%9B%BE20200902210638.png"></p>
<p>如果一个交易有多个输入，那么每个输入脚本都要和对应的输出脚本匹配之后再进行验证，如果全都验证通过，这个交易才是合法的</p>
<h4 id="比特币脚本的几种形式"><a href="#比特币脚本的几种形式" class="headerlink" title="比特币脚本的几种形式"></a>比特币脚本的几种形式</h4><p>一、ee</p>
<p><img src="/2020/09/02/%E6%AF%94%E7%89%B9%E5%B8%81%E8%84%9A%E6%9C%AC/QQ%E6%88%AA%E5%9B%BE20200902211305.png"> 这个签名是用私钥，对整个交易的签名，注意：input script实在我要花这个钱的时候的输出，所以签名是收款人的私钥的签名。（而不是付款人的私钥的签名）</p>
<p>①把输入脚本的签名压入栈</p>
<p><img src="/2020/09/02/%E6%AF%94%E7%89%B9%E5%B8%81%E8%84%9A%E6%9C%AC/QQ%E6%88%AA%E5%9B%BE20200902211520.png"></p>
<p>②把输出脚本的收款人的公钥压入栈</p>
<p><img src="/2020/09/02/%E6%AF%94%E7%89%B9%E5%B8%81%E8%84%9A%E6%9C%AC/QQ%E6%88%AA%E5%9B%BE20200902211603.png"></p>
<p>③执行CHECKSIG，用PubKey（那么这个）检查Sig是否正确，如果为true，则合法</p>
<p><img src="/2020/09/02/%E6%AF%94%E7%89%B9%E5%B8%81%E8%84%9A%E6%9C%AC/QQ%E6%88%AA%E5%9B%BE20200902211801.png"></p>
<p>二、</p>
<p><img src="/2020/09/02/%E6%AF%94%E7%89%B9%E5%B8%81%E8%84%9A%E6%9C%AC/QQ%E6%88%AA%E5%9B%BE20200902212706.png"></p>
<p><img src="/2020/09/02/%E6%AF%94%E7%89%B9%E5%B8%81%E8%84%9A%E6%9C%AC/QQ%E6%88%AA%E5%9B%BE20200902213056.png"></p>
<p><img src="/2020/09/02/%E6%AF%94%E7%89%B9%E5%B8%81%E8%84%9A%E6%9C%AC/QQ%E6%88%AA%E5%9B%BE20200902213129.png"></p>
<p><img src="/2020/09/02/%E6%AF%94%E7%89%B9%E5%B8%81%E8%84%9A%E6%9C%AC/QQ%E6%88%AA%E5%9B%BE20200902213225.png"></p>
<p><img src="/2020/09/02/%E6%AF%94%E7%89%B9%E5%B8%81%E8%84%9A%E6%9C%AC/QQ%E6%88%AA%E5%9B%BE20200902213253.png"></p>
<p><img src="/2020/09/02/%E6%AF%94%E7%89%B9%E5%B8%81%E8%84%9A%E6%9C%AC/QQ%E6%88%AA%E5%9B%BE20200902213338.png"></p>
<p>下面这个hash是你要花这个钱的时候，在输入脚本里给出的公钥</p>
<p><img src="/2020/09/02/%E6%AF%94%E7%89%B9%E5%B8%81%E8%84%9A%E6%9C%AC/QQ%E6%88%AA%E5%9B%BE20200902214127.png"></p>
<p><img src="/2020/09/02/%E6%AF%94%E7%89%B9%E5%B8%81%E8%84%9A%E6%9C%AC/QQ%E6%88%AA%E5%9B%BE20200902214623.png"></p>
<p>P2PK是最常用的脚本形式！</p>
<p>三、</p>
<p><img src="/2020/09/02/%E6%AF%94%E7%89%B9%E5%B8%81%E8%84%9A%E6%9C%AC/QQ%E6%88%AA%E5%9B%BE20200902214832.png"></p>
<p>输出脚本给出的不是收款人的公钥的哈希，而是收款人给出的一个脚本的哈希，redeemScript（赎回脚本），将来花这个钱的时候，输入脚本需要给出redeemScript的具体内容，同时还要给出让这个赎回脚本能够顺利运行所需要的签名</p>
<p><img src="/2020/09/02/%E6%AF%94%E7%89%B9%E5%B8%81%E8%84%9A%E6%9C%AC/QQ%E6%88%AA%E5%9B%BE20200902215249.png"></p>
<p>验证分为两步：</p>
<p>①验证输入脚本里给出的redeemScript（赎回脚本）是不是跟输出脚本里给出的哈希值匹配，如果不匹配的话，那么说明给出的赎回脚本是不对的，就类似于P2PKH给出的公钥不对一样，那么验证就失败了；</p>
<p>如果赎回脚本是正确的，那么第二步还要把赎回脚本的内容当作操作指令来执行一遍，看看最后能不能顺利执行，如果两部验证都通过了，那么这个交易才是合法的。</p>
<p><img src="/2020/09/02/%E6%AF%94%E7%89%B9%E5%B8%81%E8%84%9A%E6%9C%AC/QQ%E6%88%AA%E5%9B%BE20200902215724.png"></p>
<p>这里的输入脚本就是给出签名，再给出序列化的赎回脚本</p>
<p>赎回脚本的内容就是给出公钥之后，用CHECKSIG检查签名</p>
<p>下面这个输出脚本是用来验证输入脚本给出的赎回脚本是否正确</p>
<p>验证过程：</p>
<p>①②</p>
<p><img src="/2020/09/02/%E6%AF%94%E7%89%B9%E5%B8%81%E8%84%9A%E6%9C%AC/QQ%E6%88%AA%E5%9B%BE20200902220031.png"></p>
<p>③</p>
<p><img src="/2020/09/02/%E6%AF%94%E7%89%B9%E5%B8%81%E8%84%9A%E6%9C%AC/QQ%E6%88%AA%E5%9B%BE20200902220119.png"></p>
<p>④</p>
<p><img src="/2020/09/02/%E6%AF%94%E7%89%B9%E5%B8%81%E8%84%9A%E6%9C%AC/QQ%E6%88%AA%E5%9B%BE20200902220214.png"></p>
<p>⑤</p>
<p><img src="/2020/09/02/%E6%AF%94%E7%89%B9%E5%B8%81%E8%84%9A%E6%9C%AC/QQ%E6%88%AA%E5%9B%BE20200902220310.png"></p>
<p>至此，第一个阶段的验证就到这里结束了，现在进入第二阶段的验证。</p>
<p>第二个阶段首先要把输入脚本里提供的序列化的赎回脚本进行反序列化（序列化才能去哈希，我是这样理解的，如果有什么不对的地方，欢迎再下方评论给我留言！），反序列化的操作是每个结点自己要完成的，然后执行这个被反序列化之后的赎回脚本（反序列化之后就可以执行了，相当于解压）</p>
<p><img src="/2020/09/02/%E6%AF%94%E7%89%B9%E5%B8%81%E8%84%9A%E6%9C%AC/QQ%E6%88%AA%E5%9B%BE20200902220405.png"></p>
<p>将PubKey压入栈，之后CHECKSIG</p>
<p><img src="/2020/09/02/%E6%AF%94%E7%89%B9%E5%B8%81%E8%84%9A%E6%9C%AC/QQ%E6%88%AA%E5%9B%BE20200902220727.png"></p>
<p>那么这种P2SH的方式有什么好处呢？为什么要搞这么复杂？为什么要把这一部分功能嵌入到赎回脚本里面？</p>
<blockquote>
<p>确实，对这个简单的例子来讲，确实有点复杂了，P2SH在最初版本的比特币中是没有的，后来通过软分叉的形式加进去的，它的一个常见的应用场景就是对<strong>多重签名</strong>的支持。一个输出，可能需要多个签名，才能把钱取出来。</p>
<p>比如某个公司的账户，可能要求五个合伙人中，任意三个人的签名，才能把账上的钱取走，为私钥的泄露提供了一些安全的保护。同时也为私钥的丢失，提供了冗余。</p>
</blockquote>
<p>输出脚本给出的M，对应需要多少人的私钥才能匹配，CHECKMULTISIG操作对应匹配操作</p>
<p>输入脚本中第一行的×：比特币中CHECKMULTISIG的实现有一个bug（执行的时候会从堆栈上多弹出一个元素），这个bug现在已经没有办法改了，去中心化的系统，升级软件带来的代价是很大的，要改的话需要硬分叉，所以解决方案是，往栈上多压入一个没用的元素。</p>
<p>另外输入脚本的M个签名的顺序要对应N个公钥的顺序</p>
<p><img src="/2020/09/02/%E6%AF%94%E7%89%B9%E5%B8%81%E8%84%9A%E6%9C%AC/QQ%E6%88%AA%E5%9B%BE20200904192209.png"></p>
<p><img src="/2020/09/02/%E6%AF%94%E7%89%B9%E5%B8%81%E8%84%9A%E6%9C%AC/QQ%E6%88%AA%E5%9B%BE20200904192224.png"></p>
<p>一次压入栈，看看栈中是否有两个对应的签名，如果有的话，验证通过</p>
<p><img src="/2020/09/02/%E6%AF%94%E7%89%B9%E5%B8%81%E8%84%9A%E6%9C%AC/QQ%E6%88%AA%E5%9B%BE20200904192304.png"></p>
<p>注意，这个过程并没有使用P2SH(早期的多重签名只是使用CHECKMULTISTG的方式来实现)</p>
<p>如果是在网上购物的话，用户再转账的时候就需要传给电商公司对应的N个公钥和M的值，这个N个公钥的值和M会在电商网站上公布出来，用户可以相应地填入（每个电商网站可能都不太一样），这样就给用户交易带来了一些不方便的地方（因为这些复杂性都暴露给用户了）。</p>
<p>那么怎么办呢？</p>
<blockquote>
<p>就需要用到P2SH，它的本质是把复杂度从输出脚本转移到了输入脚本</p>
</blockquote>
<p><img src="/2020/09/02/%E6%AF%94%E7%89%B9%E5%B8%81%E8%84%9A%E6%9C%AC/QQ%E6%88%AA%E5%9B%BE20200904193001.png"></p>
<p>复杂度被转移到了redeemScript（赎回脚本由输入脚本提供），输出脚本只需要给出赎回脚本的哈希就可以了，用户只需要知道赎回脚本的哈希值</p>
<p>执行阶段一、</p>
<p><img src="/2020/09/02/%E6%AF%94%E7%89%B9%E5%B8%81%E8%84%9A%E6%9C%AC/QQ%E6%88%AA%E5%9B%BE20200904193524.png"></p>
<p><img src="/2020/09/02/%E6%AF%94%E7%89%B9%E5%B8%81%E8%84%9A%E6%9C%AC/QQ%E6%88%AA%E5%9B%BE20200904193544.png"></p>
<p><img src="/2020/09/02/%E6%AF%94%E7%89%B9%E5%B8%81%E8%84%9A%E6%9C%AC/QQ%E6%88%AA%E5%9B%BE20200904193708.png"></p>
<p><img src="/2020/09/02/%E6%AF%94%E7%89%B9%E5%B8%81%E8%84%9A%E6%9C%AC/QQ%E6%88%AA%E5%9B%BE20200904193739.png"></p>
<p><img src="/2020/09/02/%E6%AF%94%E7%89%B9%E5%B8%81%E8%84%9A%E6%9C%AC/QQ%E6%88%AA%E5%9B%BE20200904193844.png"></p>
<p>执行阶段二、</p>
<p>把赎回脚本展开后执行</p>
<p><img src="/2020/09/02/%E6%AF%94%E7%89%B9%E5%B8%81%E8%84%9A%E6%9C%AC/QQ%E6%88%AA%E5%9B%BE20200904193944.png"></p>
<p><img src="/2020/09/02/%E6%AF%94%E7%89%B9%E5%B8%81%E8%84%9A%E6%9C%AC/QQ%E6%88%AA%E5%9B%BE20200904194013.png"></p>
<p>第二阶段的验证和前面直接使用CHECKMULTISIG的情况是类似的</p>
<p><img src="/2020/09/02/%E6%AF%94%E7%89%B9%E5%B8%81%E8%84%9A%E6%9C%AC/QQ%E6%88%AA%E5%9B%BE20200904194115.png"></p>
<h4 id="Proof-of-Burn"><a href="#Proof-of-Burn" class="headerlink" title="Proof of Burn"></a>Proof of Burn</h4><p><img src="/2020/09/02/%E6%AF%94%E7%89%B9%E5%B8%81%E8%84%9A%E6%9C%AC/QQ%E6%88%AA%E5%9B%BE20200904194329.png"></p>
<p>比较特殊，输出脚本的开头是RETURN操作，后面可以跟任意的内容，RETURN这个操作的内容是无条件的返回错误，所以包含这个操作的脚本永远不可能通过验证，执行到RETURN这个语句就结束了，后面的内容根本没有机会执行</p>
<p>为什么要设置这样的输出脚本？</p>
<blockquote>
<p>这里的钱不是会永远花不出去？这个脚本是证明销毁比特币的一种方法，为什么要销毁？</p>
<p>这个一般是两种应用场景：</p>
<p>①一些小的币种，要求销毁一定数量的比特币才能够得到这个币种，有时候我们管这种小币种叫做AltCoin（Alternative Coin），有的小币种，可能要求你销毁一个比特币，可以得到1000个这样的小币，也就是说，你需要用Proof of Burn这种方法证明你付出了一定的代价，才能够得到这种小币种。</p>
<p>②往区块链里写入一些内容，我们说区块链是个不可篡改的账本，那么有人就利用这种特性，往里面添加一些需要永久保存的内容，你要证明在某个时间知道某些事情，比如说涉及到知识产权保护的，把某项知识产权的内容去哈希之后，把哈希值放在RETURN语句的后面，这个语句后面的内容反正是永远不会被执行的，写什么都没关系，不会占用太大的空间，也不会泄露知识产权的内容，将来如果出现了知识产权的纠纷，那么你再把这个记录的知识产权公布出去，证明你在某个时间点已经知道了某个知识了。</p>
</blockquote>
<p>注意：Proof of Burn这种方法所有节点都可以使用，而CoinBase 里的 coinbase transaction域只有获得记账权的节点才能使用，任何用户都可以销毁一点比特币，换取向这个区块链里写入内容的机会。甚至有点交易都没有销毁比特币，只是消耗了交易费。</p>
<p>有一点需要注意，图片中的交易为了简单起见，都没有写OP前缀，比如OP_CHECKSIG</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>比特币系统中使用的脚本语言是非常简单的（比特币的脚本语言不支持循环），甚至连专门的名字都没有。虽然在某些方法功能有限，但是在另外一些方面功能却很强大，就是和密码学相关的功能是很强大的，比如CHECKMULITSIG用一条语句就可以完成。</p>
]]></content>
      <categories>
        <category>区块链</category>
      </categories>
      <tags>
        <tag>区块链</tag>
      </tags>
  </entry>
  <entry>
    <title>BTC五---网络</title>
    <url>/2020/08/30/%E7%BD%91%E7%BB%9C/</url>
    <content><![CDATA[<h1 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h1><p>新发布的区块，新发布的交易，再区块链中是怎么传播的？</p>
<a id="more"></a>

<p>比特币网络的工作原理</p>
<p>The BitCoin Network，比特币工作在应用层，它的底层是一个P2P Overlay Network，所有结点都是对等的，他不想有些所谓的P2P网络有所谓的超结点(Super node | master node),你要加入比特币网络，你要至少知道一个种子结点（seed node），你和这个种子节点联系，他会告诉你他所知道的网络中的其他节点，节点之间是通过tcp通信的，这样有利于穿破防火墙，你离开的时候也不需要执行其他操作（比如通知其他结点，退出应用程序即可），别的节点没有听到你的消息，过了一段时间就会把你删掉。</p>
<p>比特币网络的设计原则是简单（simple，robust，but not efficient），每个结点维护一个邻居节点的集合，消息传播在网络中采取flooding（泛洪）的方式，结点第一次听到某个消息的时候，把他传播给所有的邻居结点，同时记录一下，这个消息我已经记录过了，下次再收到这个消息的时候，就不用转发给邻居节点了</p>
<p>邻居结点的选取是随机的，没有考虑底层的拓扑结构，和地区没有关系，这样的好处是增强鲁棒性，没有考虑实际的拓扑结构，但是牺牲的是效率，向身边的人转账和向美国的人转账速度其实是差不多的。</p>
<p>比特币系统中每个节点要维护一个等待上链的交易的集合。第二次听到同样的交易就不会传播给邻居结点，避免交易在网络中无限制的传播下去，转发的前提是这个交易得是合法的，这里有一个risk condition：有可能你有两个有冲突的交易，差不多同时被广播到网络上</p>
<p><img src="/2020/08/30/%E7%BD%91%E7%BB%9C/QQ%E6%88%AA%E5%9B%BE20200826201624.png"></p>
<p>新发布的区块在网络中的传播方式和新发布的交易在网络中传播是相似的，每个结点除了要检查区块的内容之外，还要检查一下是否在最长合法链上，越是大的区块，在网络中传播的速度就越慢，比特币协议对区块大小有一个限制，1M字节的限制，1M大小的区块在区块链中的传播时间就已经达到了50秒（传播完）</p>
<p>我们讲的比特币网络，它的传播是属于best effort，一个交易发布到网络上，不一定所有的节点都能收到，而且不同的节点收到这个交易的顺序也不一定是一样的，网络传播存在延迟，有的节点也不一定按照比特币协议的要求转发，比如有的该转发的它不转发，导致某些合法的交易收不到，有些节点也有可能转发一些不该转发的消息，比如有些不合法的交易，他也会转发，这是去中心化系统中所面临的问题</p>
]]></content>
      <categories>
        <category>区块链</category>
      </categories>
      <tags>
        <tag>区块链</tag>
      </tags>
  </entry>
</search>
